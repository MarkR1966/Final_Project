{"ast":null,"code":"import _defineProperty from \"/home/ubuntu/spring-petclinic-angular/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _possibleConstructorReturn from \"/home/ubuntu/spring-petclinic-angular/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _toArray from \"/home/ubuntu/spring-petclinic-angular/node_modules/@babel/runtime/helpers/esm/toArray\";\nimport _construct from \"/home/ubuntu/spring-petclinic-angular/node_modules/@babel/runtime/helpers/esm/construct\";\nimport _slicedToArray from \"/home/ubuntu/spring-petclinic-angular/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _assertThisInitialized from \"/home/ubuntu/spring-petclinic-angular/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _createForOfIteratorHelper from \"/home/ubuntu/spring-petclinic-angular/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _get from \"/home/ubuntu/spring-petclinic-angular/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/home/ubuntu/spring-petclinic-angular/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/home/ubuntu/spring-petclinic-angular/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/ubuntu/spring-petclinic-angular/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _toConsumableArray from \"/home/ubuntu/spring-petclinic-angular/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/home/ubuntu/spring-petclinic-angular/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/ubuntu/spring-petclinic-angular/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nvar _BoundPropertyMapping;\n\n/**\n * @license Angular v10.0.2\n * (c) 2010-2020 Google LLC. https://angular.io/\n * License: MIT\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nvar TagContentType;\n\n(function (TagContentType) {\n  TagContentType[TagContentType[\"RAW_TEXT\"] = 0] = \"RAW_TEXT\";\n  TagContentType[TagContentType[\"ESCAPABLE_RAW_TEXT\"] = 1] = \"ESCAPABLE_RAW_TEXT\";\n  TagContentType[TagContentType[\"PARSABLE_DATA\"] = 2] = \"PARSABLE_DATA\";\n})(TagContentType || (TagContentType = {}));\n\nfunction splitNsName(elementName) {\n  if (elementName[0] != ':') {\n    return [null, elementName];\n  }\n\n  var colonIndex = elementName.indexOf(':', 1);\n\n  if (colonIndex == -1) {\n    throw new Error(\"Unsupported format \\\"\".concat(elementName, \"\\\" expecting \\\":namespace:name\\\"\"));\n  }\n\n  return [elementName.slice(1, colonIndex), elementName.slice(colonIndex + 1)];\n} // `<ng-container>` tags work the same regardless the namespace\n\n\nfunction isNgContainer(tagName) {\n  return splitNsName(tagName)[1] === 'ng-container';\n} // `<ng-content>` tags work the same regardless the namespace\n\n\nfunction isNgContent(tagName) {\n  return splitNsName(tagName)[1] === 'ng-content';\n} // `<ng-template>` tags work the same regardless the namespace\n\n\nfunction isNgTemplate(tagName) {\n  return splitNsName(tagName)[1] === 'ng-template';\n}\n\nfunction getNsPrefix(fullName) {\n  return fullName === null ? null : splitNsName(fullName)[0];\n}\n\nfunction mergeNsAndName(prefix, localName) {\n  return prefix ? \":\".concat(prefix, \":\").concat(localName) : localName;\n} // see http://www.w3.org/TR/html51/syntax.html#named-character-references\n// see https://html.spec.whatwg.org/multipage/entities.json\n// This list is not exhaustive to keep the compiler footprint low.\n// The `&#123;` / `&#x1ab;` syntax should be used when the named character reference does not\n// exist.\n\n\nvar NAMED_ENTITIES = {\n  'Aacute': \"\\xC1\",\n  'aacute': \"\\xE1\",\n  'Acirc': \"\\xC2\",\n  'acirc': \"\\xE2\",\n  'acute': \"\\xB4\",\n  'AElig': \"\\xC6\",\n  'aelig': \"\\xE6\",\n  'Agrave': \"\\xC0\",\n  'agrave': \"\\xE0\",\n  'alefsym': \"\\u2135\",\n  'Alpha': \"\\u0391\",\n  'alpha': \"\\u03B1\",\n  'amp': '&',\n  'and': \"\\u2227\",\n  'ang': \"\\u2220\",\n  'apos': \"'\",\n  'Aring': \"\\xC5\",\n  'aring': \"\\xE5\",\n  'asymp': \"\\u2248\",\n  'Atilde': \"\\xC3\",\n  'atilde': \"\\xE3\",\n  'Auml': \"\\xC4\",\n  'auml': \"\\xE4\",\n  'bdquo': \"\\u201E\",\n  'Beta': \"\\u0392\",\n  'beta': \"\\u03B2\",\n  'brvbar': \"\\xA6\",\n  'bull': \"\\u2022\",\n  'cap': \"\\u2229\",\n  'Ccedil': \"\\xC7\",\n  'ccedil': \"\\xE7\",\n  'cedil': \"\\xB8\",\n  'cent': \"\\xA2\",\n  'Chi': \"\\u03A7\",\n  'chi': \"\\u03C7\",\n  'circ': \"\\u02C6\",\n  'clubs': \"\\u2663\",\n  'cong': \"\\u2245\",\n  'copy': \"\\xA9\",\n  'crarr': \"\\u21B5\",\n  'cup': \"\\u222A\",\n  'curren': \"\\xA4\",\n  'dagger': \"\\u2020\",\n  'Dagger': \"\\u2021\",\n  'darr': \"\\u2193\",\n  'dArr': \"\\u21D3\",\n  'deg': \"\\xB0\",\n  'Delta': \"\\u0394\",\n  'delta': \"\\u03B4\",\n  'diams': \"\\u2666\",\n  'divide': \"\\xF7\",\n  'Eacute': \"\\xC9\",\n  'eacute': \"\\xE9\",\n  'Ecirc': \"\\xCA\",\n  'ecirc': \"\\xEA\",\n  'Egrave': \"\\xC8\",\n  'egrave': \"\\xE8\",\n  'empty': \"\\u2205\",\n  'emsp': \"\\u2003\",\n  'ensp': \"\\u2002\",\n  'Epsilon': \"\\u0395\",\n  'epsilon': \"\\u03B5\",\n  'equiv': \"\\u2261\",\n  'Eta': \"\\u0397\",\n  'eta': \"\\u03B7\",\n  'ETH': \"\\xD0\",\n  'eth': \"\\xF0\",\n  'Euml': \"\\xCB\",\n  'euml': \"\\xEB\",\n  'euro': \"\\u20AC\",\n  'exist': \"\\u2203\",\n  'fnof': \"\\u0192\",\n  'forall': \"\\u2200\",\n  'frac12': \"\\xBD\",\n  'frac14': \"\\xBC\",\n  'frac34': \"\\xBE\",\n  'frasl': \"\\u2044\",\n  'Gamma': \"\\u0393\",\n  'gamma': \"\\u03B3\",\n  'ge': \"\\u2265\",\n  'gt': '>',\n  'harr': \"\\u2194\",\n  'hArr': \"\\u21D4\",\n  'hearts': \"\\u2665\",\n  'hellip': \"\\u2026\",\n  'Iacute': \"\\xCD\",\n  'iacute': \"\\xED\",\n  'Icirc': \"\\xCE\",\n  'icirc': \"\\xEE\",\n  'iexcl': \"\\xA1\",\n  'Igrave': \"\\xCC\",\n  'igrave': \"\\xEC\",\n  'image': \"\\u2111\",\n  'infin': \"\\u221E\",\n  'int': \"\\u222B\",\n  'Iota': \"\\u0399\",\n  'iota': \"\\u03B9\",\n  'iquest': \"\\xBF\",\n  'isin': \"\\u2208\",\n  'Iuml': \"\\xCF\",\n  'iuml': \"\\xEF\",\n  'Kappa': \"\\u039A\",\n  'kappa': \"\\u03BA\",\n  'Lambda': \"\\u039B\",\n  'lambda': \"\\u03BB\",\n  'lang': \"\\u27E8\",\n  'laquo': \"\\xAB\",\n  'larr': \"\\u2190\",\n  'lArr': \"\\u21D0\",\n  'lceil': \"\\u2308\",\n  'ldquo': \"\\u201C\",\n  'le': \"\\u2264\",\n  'lfloor': \"\\u230A\",\n  'lowast': \"\\u2217\",\n  'loz': \"\\u25CA\",\n  'lrm': \"\\u200E\",\n  'lsaquo': \"\\u2039\",\n  'lsquo': \"\\u2018\",\n  'lt': '<',\n  'macr': \"\\xAF\",\n  'mdash': \"\\u2014\",\n  'micro': \"\\xB5\",\n  'middot': \"\\xB7\",\n  'minus': \"\\u2212\",\n  'Mu': \"\\u039C\",\n  'mu': \"\\u03BC\",\n  'nabla': \"\\u2207\",\n  'nbsp': \"\\xA0\",\n  'ndash': \"\\u2013\",\n  'ne': \"\\u2260\",\n  'ni': \"\\u220B\",\n  'not': \"\\xAC\",\n  'notin': \"\\u2209\",\n  'nsub': \"\\u2284\",\n  'Ntilde': \"\\xD1\",\n  'ntilde': \"\\xF1\",\n  'Nu': \"\\u039D\",\n  'nu': \"\\u03BD\",\n  'Oacute': \"\\xD3\",\n  'oacute': \"\\xF3\",\n  'Ocirc': \"\\xD4\",\n  'ocirc': \"\\xF4\",\n  'OElig': \"\\u0152\",\n  'oelig': \"\\u0153\",\n  'Ograve': \"\\xD2\",\n  'ograve': \"\\xF2\",\n  'oline': \"\\u203E\",\n  'Omega': \"\\u03A9\",\n  'omega': \"\\u03C9\",\n  'Omicron': \"\\u039F\",\n  'omicron': \"\\u03BF\",\n  'oplus': \"\\u2295\",\n  'or': \"\\u2228\",\n  'ordf': \"\\xAA\",\n  'ordm': \"\\xBA\",\n  'Oslash': \"\\xD8\",\n  'oslash': \"\\xF8\",\n  'Otilde': \"\\xD5\",\n  'otilde': \"\\xF5\",\n  'otimes': \"\\u2297\",\n  'Ouml': \"\\xD6\",\n  'ouml': \"\\xF6\",\n  'para': \"\\xB6\",\n  'permil': \"\\u2030\",\n  'perp': \"\\u22A5\",\n  'Phi': \"\\u03A6\",\n  'phi': \"\\u03C6\",\n  'Pi': \"\\u03A0\",\n  'pi': \"\\u03C0\",\n  'piv': \"\\u03D6\",\n  'plusmn': \"\\xB1\",\n  'pound': \"\\xA3\",\n  'prime': \"\\u2032\",\n  'Prime': \"\\u2033\",\n  'prod': \"\\u220F\",\n  'prop': \"\\u221D\",\n  'Psi': \"\\u03A8\",\n  'psi': \"\\u03C8\",\n  'quot': \"\\\"\",\n  'radic': \"\\u221A\",\n  'rang': \"\\u27E9\",\n  'raquo': \"\\xBB\",\n  'rarr': \"\\u2192\",\n  'rArr': \"\\u21D2\",\n  'rceil': \"\\u2309\",\n  'rdquo': \"\\u201D\",\n  'real': \"\\u211C\",\n  'reg': \"\\xAE\",\n  'rfloor': \"\\u230B\",\n  'Rho': \"\\u03A1\",\n  'rho': \"\\u03C1\",\n  'rlm': \"\\u200F\",\n  'rsaquo': \"\\u203A\",\n  'rsquo': \"\\u2019\",\n  'sbquo': \"\\u201A\",\n  'Scaron': \"\\u0160\",\n  'scaron': \"\\u0161\",\n  'sdot': \"\\u22C5\",\n  'sect': \"\\xA7\",\n  'shy': \"\\xAD\",\n  'Sigma': \"\\u03A3\",\n  'sigma': \"\\u03C3\",\n  'sigmaf': \"\\u03C2\",\n  'sim': \"\\u223C\",\n  'spades': \"\\u2660\",\n  'sub': \"\\u2282\",\n  'sube': \"\\u2286\",\n  'sum': \"\\u2211\",\n  'sup': \"\\u2283\",\n  'sup1': \"\\xB9\",\n  'sup2': \"\\xB2\",\n  'sup3': \"\\xB3\",\n  'supe': \"\\u2287\",\n  'szlig': \"\\xDF\",\n  'Tau': \"\\u03A4\",\n  'tau': \"\\u03C4\",\n  'there4': \"\\u2234\",\n  'Theta': \"\\u0398\",\n  'theta': \"\\u03B8\",\n  'thetasym': \"\\u03D1\",\n  'thinsp': \"\\u2009\",\n  'THORN': \"\\xDE\",\n  'thorn': \"\\xFE\",\n  'tilde': \"\\u02DC\",\n  'times': \"\\xD7\",\n  'trade': \"\\u2122\",\n  'Uacute': \"\\xDA\",\n  'uacute': \"\\xFA\",\n  'uarr': \"\\u2191\",\n  'uArr': \"\\u21D1\",\n  'Ucirc': \"\\xDB\",\n  'ucirc': \"\\xFB\",\n  'Ugrave': \"\\xD9\",\n  'ugrave': \"\\xF9\",\n  'uml': \"\\xA8\",\n  'upsih': \"\\u03D2\",\n  'Upsilon': \"\\u03A5\",\n  'upsilon': \"\\u03C5\",\n  'Uuml': \"\\xDC\",\n  'uuml': \"\\xFC\",\n  'weierp': \"\\u2118\",\n  'Xi': \"\\u039E\",\n  'xi': \"\\u03BE\",\n  'Yacute': \"\\xDD\",\n  'yacute': \"\\xFD\",\n  'yen': \"\\xA5\",\n  'yuml': \"\\xFF\",\n  'Yuml': \"\\u0178\",\n  'Zeta': \"\\u0396\",\n  'zeta': \"\\u03B6\",\n  'zwj': \"\\u200D\",\n  'zwnj': \"\\u200C\"\n}; // The &ngsp; pseudo-entity is denoting a space. see:\n// https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart\n\nvar NGSP_UNICODE = \"\\uE500\";\nNAMED_ENTITIES['ngsp'] = NGSP_UNICODE;\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar HtmlTagDefinition = /*#__PURE__*/function () {\n  function HtmlTagDefinition() {\n    var _this = this;\n\n    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        closedByChildren = _ref2.closedByChildren,\n        implicitNamespacePrefix = _ref2.implicitNamespacePrefix,\n        _ref2$contentType = _ref2.contentType,\n        contentType = _ref2$contentType === void 0 ? TagContentType.PARSABLE_DATA : _ref2$contentType,\n        _ref2$closedByParent = _ref2.closedByParent,\n        closedByParent = _ref2$closedByParent === void 0 ? false : _ref2$closedByParent,\n        _ref2$isVoid = _ref2.isVoid,\n        isVoid = _ref2$isVoid === void 0 ? false : _ref2$isVoid,\n        _ref2$ignoreFirstLf = _ref2.ignoreFirstLf,\n        ignoreFirstLf = _ref2$ignoreFirstLf === void 0 ? false : _ref2$ignoreFirstLf;\n\n    _classCallCheck(this, HtmlTagDefinition);\n\n    this.closedByChildren = {};\n    this.closedByParent = false;\n    this.canSelfClose = false;\n\n    if (closedByChildren && closedByChildren.length > 0) {\n      closedByChildren.forEach(function (tagName) {\n        return _this.closedByChildren[tagName] = true;\n      });\n    }\n\n    this.isVoid = isVoid;\n    this.closedByParent = closedByParent || isVoid;\n    this.implicitNamespacePrefix = implicitNamespacePrefix || null;\n    this.contentType = contentType;\n    this.ignoreFirstLf = ignoreFirstLf;\n  }\n\n  _createClass(HtmlTagDefinition, [{\n    key: \"isClosedByChild\",\n    value: function isClosedByChild(name) {\n      return this.isVoid || name.toLowerCase() in this.closedByChildren;\n    }\n  }]);\n\n  return HtmlTagDefinition;\n}();\n\nvar _DEFAULT_TAG_DEFINITION; // see http://www.w3.org/TR/html51/syntax.html#optional-tags\n// This implementation does not fully conform to the HTML5 spec.\n\n\nvar TAG_DEFINITIONS;\n\nfunction getHtmlTagDefinition(tagName) {\n  if (!TAG_DEFINITIONS) {\n    _DEFAULT_TAG_DEFINITION = new HtmlTagDefinition();\n    TAG_DEFINITIONS = {\n      'base': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'meta': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'area': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'embed': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'link': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'img': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'input': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'param': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'hr': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'br': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'source': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'track': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'wbr': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'p': new HtmlTagDefinition({\n        closedByChildren: ['address', 'article', 'aside', 'blockquote', 'div', 'dl', 'fieldset', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'hr', 'main', 'nav', 'ol', 'p', 'pre', 'section', 'table', 'ul'],\n        closedByParent: true\n      }),\n      'thead': new HtmlTagDefinition({\n        closedByChildren: ['tbody', 'tfoot']\n      }),\n      'tbody': new HtmlTagDefinition({\n        closedByChildren: ['tbody', 'tfoot'],\n        closedByParent: true\n      }),\n      'tfoot': new HtmlTagDefinition({\n        closedByChildren: ['tbody'],\n        closedByParent: true\n      }),\n      'tr': new HtmlTagDefinition({\n        closedByChildren: ['tr'],\n        closedByParent: true\n      }),\n      'td': new HtmlTagDefinition({\n        closedByChildren: ['td', 'th'],\n        closedByParent: true\n      }),\n      'th': new HtmlTagDefinition({\n        closedByChildren: ['td', 'th'],\n        closedByParent: true\n      }),\n      'col': new HtmlTagDefinition({\n        isVoid: true\n      }),\n      'svg': new HtmlTagDefinition({\n        implicitNamespacePrefix: 'svg'\n      }),\n      'math': new HtmlTagDefinition({\n        implicitNamespacePrefix: 'math'\n      }),\n      'li': new HtmlTagDefinition({\n        closedByChildren: ['li'],\n        closedByParent: true\n      }),\n      'dt': new HtmlTagDefinition({\n        closedByChildren: ['dt', 'dd']\n      }),\n      'dd': new HtmlTagDefinition({\n        closedByChildren: ['dt', 'dd'],\n        closedByParent: true\n      }),\n      'rb': new HtmlTagDefinition({\n        closedByChildren: ['rb', 'rt', 'rtc', 'rp'],\n        closedByParent: true\n      }),\n      'rt': new HtmlTagDefinition({\n        closedByChildren: ['rb', 'rt', 'rtc', 'rp'],\n        closedByParent: true\n      }),\n      'rtc': new HtmlTagDefinition({\n        closedByChildren: ['rb', 'rtc', 'rp'],\n        closedByParent: true\n      }),\n      'rp': new HtmlTagDefinition({\n        closedByChildren: ['rb', 'rt', 'rtc', 'rp'],\n        closedByParent: true\n      }),\n      'optgroup': new HtmlTagDefinition({\n        closedByChildren: ['optgroup'],\n        closedByParent: true\n      }),\n      'option': new HtmlTagDefinition({\n        closedByChildren: ['option', 'optgroup'],\n        closedByParent: true\n      }),\n      'pre': new HtmlTagDefinition({\n        ignoreFirstLf: true\n      }),\n      'listing': new HtmlTagDefinition({\n        ignoreFirstLf: true\n      }),\n      'style': new HtmlTagDefinition({\n        contentType: TagContentType.RAW_TEXT\n      }),\n      'script': new HtmlTagDefinition({\n        contentType: TagContentType.RAW_TEXT\n      }),\n      'title': new HtmlTagDefinition({\n        contentType: TagContentType.ESCAPABLE_RAW_TEXT\n      }),\n      'textarea': new HtmlTagDefinition({\n        contentType: TagContentType.ESCAPABLE_RAW_TEXT,\n        ignoreFirstLf: true\n      })\n    };\n  }\n\n  return TAG_DEFINITIONS[tagName.toLowerCase()] || _DEFAULT_TAG_DEFINITION;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar _SELECTOR_REGEXP = new RegExp('(\\\\:not\\\\()|' + // 1: \":not(\"\n'(([\\\\.\\\\#]?)[-\\\\w]+)|' + // 2: \"tag\"; 3: \".\"/\"#\";\n// \"-\" should appear first in the regexp below as FF31 parses \"[.-\\w]\" as a range\n// 4: attribute; 5: attribute_string; 6: attribute_value\n'(?:\\\\[([-.\\\\w*]+)(?:=([\\\"\\']?)([^\\\\]\\\"\\']*)\\\\5)?\\\\])|' + // \"[name]\", \"[name=value]\",\n// \"[name=\"value\"]\",\n// \"[name='value']\"\n'(\\\\))|' + // 7: \")\"\n'(\\\\s*,\\\\s*)', // 8: \",\"\n'g');\n/**\n * A css selector contains an element name,\n * css classes and attribute/value pairs with the purpose\n * of selecting subsets out of them.\n */\n\n\nvar CssSelector = /*#__PURE__*/function () {\n  function CssSelector() {\n    _classCallCheck(this, CssSelector);\n\n    this.element = null;\n    this.classNames = [];\n    /**\n     * The selectors are encoded in pairs where:\n     * - even locations are attribute names\n     * - odd locations are attribute values.\n     *\n     * Example:\n     * Selector: `[key1=value1][key2]` would parse to:\n     * ```\n     * ['key1', 'value1', 'key2', '']\n     * ```\n     */\n\n    this.attrs = [];\n    this.notSelectors = [];\n  }\n\n  _createClass(CssSelector, [{\n    key: \"isElementSelector\",\n    value: function isElementSelector() {\n      return this.hasElementSelector() && this.classNames.length == 0 && this.attrs.length == 0 && this.notSelectors.length === 0;\n    }\n  }, {\n    key: \"hasElementSelector\",\n    value: function hasElementSelector() {\n      return !!this.element;\n    }\n  }, {\n    key: \"setElement\",\n    value: function setElement() {\n      var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      this.element = element;\n    }\n    /** Gets a template string for an element that matches the selector. */\n\n  }, {\n    key: \"getMatchingElementTemplate\",\n    value: function getMatchingElementTemplate() {\n      var tagName = this.element || 'div';\n      var classAttr = this.classNames.length > 0 ? \" class=\\\"\".concat(this.classNames.join(' '), \"\\\"\") : '';\n      var attrs = '';\n\n      for (var i = 0; i < this.attrs.length; i += 2) {\n        var attrName = this.attrs[i];\n        var attrValue = this.attrs[i + 1] !== '' ? \"=\\\"\".concat(this.attrs[i + 1], \"\\\"\") : '';\n        attrs += \" \".concat(attrName).concat(attrValue);\n      }\n\n      return getHtmlTagDefinition(tagName).isVoid ? \"<\".concat(tagName).concat(classAttr).concat(attrs, \"/>\") : \"<\".concat(tagName).concat(classAttr).concat(attrs, \"></\").concat(tagName, \">\");\n    }\n  }, {\n    key: \"getAttrs\",\n    value: function getAttrs() {\n      var result = [];\n\n      if (this.classNames.length > 0) {\n        result.push('class', this.classNames.join(' '));\n      }\n\n      return result.concat(this.attrs);\n    }\n  }, {\n    key: \"addAttribute\",\n    value: function addAttribute(name) {\n      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n      this.attrs.push(name, value && value.toLowerCase() || '');\n    }\n  }, {\n    key: \"addClassName\",\n    value: function addClassName(name) {\n      this.classNames.push(name.toLowerCase());\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var res = this.element || '';\n\n      if (this.classNames) {\n        this.classNames.forEach(function (klass) {\n          return res += \".\".concat(klass);\n        });\n      }\n\n      if (this.attrs) {\n        for (var i = 0; i < this.attrs.length; i += 2) {\n          var name = this.attrs[i];\n          var value = this.attrs[i + 1];\n          res += \"[\".concat(name).concat(value ? '=' + value : '', \"]\");\n        }\n      }\n\n      this.notSelectors.forEach(function (notSelector) {\n        return res += \":not(\".concat(notSelector, \")\");\n      });\n      return res;\n    }\n  }], [{\n    key: \"parse\",\n    value: function parse(selector) {\n      var results = [];\n\n      var _addResult = function _addResult(res, cssSel) {\n        if (cssSel.notSelectors.length > 0 && !cssSel.element && cssSel.classNames.length == 0 && cssSel.attrs.length == 0) {\n          cssSel.element = '*';\n        }\n\n        res.push(cssSel);\n      };\n\n      var cssSelector = new CssSelector();\n      var match;\n      var current = cssSelector;\n      var inNot = false;\n      _SELECTOR_REGEXP.lastIndex = 0;\n\n      while (match = _SELECTOR_REGEXP.exec(selector)) {\n        if (match[1\n        /* NOT */\n        ]) {\n          if (inNot) {\n            throw new Error('Nesting :not in a selector is not allowed');\n          }\n\n          inNot = true;\n          current = new CssSelector();\n          cssSelector.notSelectors.push(current);\n        }\n\n        var tag = match[2\n        /* TAG */\n        ];\n\n        if (tag) {\n          var prefix = match[3\n          /* PREFIX */\n          ];\n\n          if (prefix === '#') {\n            // #hash\n            current.addAttribute('id', tag.substr(1));\n          } else if (prefix === '.') {\n            // Class\n            current.addClassName(tag.substr(1));\n          } else {\n            // Element\n            current.setElement(tag);\n          }\n        }\n\n        var attribute = match[4\n        /* ATTRIBUTE */\n        ];\n\n        if (attribute) {\n          current.addAttribute(attribute, match[6\n          /* ATTRIBUTE_VALUE */\n          ]);\n        }\n\n        if (match[7\n        /* NOT_END */\n        ]) {\n          inNot = false;\n          current = cssSelector;\n        }\n\n        if (match[8\n        /* SEPARATOR */\n        ]) {\n          if (inNot) {\n            throw new Error('Multiple selectors in :not are not supported');\n          }\n\n          _addResult(results, cssSelector);\n\n          cssSelector = current = new CssSelector();\n        }\n      }\n\n      _addResult(results, cssSelector);\n\n      return results;\n    }\n  }]);\n\n  return CssSelector;\n}();\n/**\n * Reads a list of CssSelectors and allows to calculate which ones\n * are contained in a given CssSelector.\n */\n\n\nvar SelectorMatcher = /*#__PURE__*/function () {\n  function SelectorMatcher() {\n    _classCallCheck(this, SelectorMatcher);\n\n    this._elementMap = new Map();\n    this._elementPartialMap = new Map();\n    this._classMap = new Map();\n    this._classPartialMap = new Map();\n    this._attrValueMap = new Map();\n    this._attrValuePartialMap = new Map();\n    this._listContexts = [];\n  }\n\n  _createClass(SelectorMatcher, [{\n    key: \"addSelectables\",\n    value: function addSelectables(cssSelectors, callbackCtxt) {\n      var listContext = null;\n\n      if (cssSelectors.length > 1) {\n        listContext = new SelectorListContext(cssSelectors);\n\n        this._listContexts.push(listContext);\n      }\n\n      for (var i = 0; i < cssSelectors.length; i++) {\n        this._addSelectable(cssSelectors[i], callbackCtxt, listContext);\n      }\n    }\n    /**\n     * Add an object that can be found later on by calling `match`.\n     * @param cssSelector A css selector\n     * @param callbackCtxt An opaque object that will be given to the callback of the `match` function\n     */\n\n  }, {\n    key: \"_addSelectable\",\n    value: function _addSelectable(cssSelector, callbackCtxt, listContext) {\n      var matcher = this;\n      var element = cssSelector.element;\n      var classNames = cssSelector.classNames;\n      var attrs = cssSelector.attrs;\n      var selectable = new SelectorContext(cssSelector, callbackCtxt, listContext);\n\n      if (element) {\n        var isTerminal = attrs.length === 0 && classNames.length === 0;\n\n        if (isTerminal) {\n          this._addTerminal(matcher._elementMap, element, selectable);\n        } else {\n          matcher = this._addPartial(matcher._elementPartialMap, element);\n        }\n      }\n\n      if (classNames) {\n        for (var i = 0; i < classNames.length; i++) {\n          var _isTerminal = attrs.length === 0 && i === classNames.length - 1;\n\n          var className = classNames[i];\n\n          if (_isTerminal) {\n            this._addTerminal(matcher._classMap, className, selectable);\n          } else {\n            matcher = this._addPartial(matcher._classPartialMap, className);\n          }\n        }\n      }\n\n      if (attrs) {\n        for (var _i = 0; _i < attrs.length; _i += 2) {\n          var _isTerminal2 = _i === attrs.length - 2;\n\n          var name = attrs[_i];\n          var value = attrs[_i + 1];\n\n          if (_isTerminal2) {\n            var terminalMap = matcher._attrValueMap;\n            var terminalValuesMap = terminalMap.get(name);\n\n            if (!terminalValuesMap) {\n              terminalValuesMap = new Map();\n              terminalMap.set(name, terminalValuesMap);\n            }\n\n            this._addTerminal(terminalValuesMap, value, selectable);\n          } else {\n            var partialMap = matcher._attrValuePartialMap;\n            var partialValuesMap = partialMap.get(name);\n\n            if (!partialValuesMap) {\n              partialValuesMap = new Map();\n              partialMap.set(name, partialValuesMap);\n            }\n\n            matcher = this._addPartial(partialValuesMap, value);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_addTerminal\",\n    value: function _addTerminal(map, name, selectable) {\n      var terminalList = map.get(name);\n\n      if (!terminalList) {\n        terminalList = [];\n        map.set(name, terminalList);\n      }\n\n      terminalList.push(selectable);\n    }\n  }, {\n    key: \"_addPartial\",\n    value: function _addPartial(map, name) {\n      var matcher = map.get(name);\n\n      if (!matcher) {\n        matcher = new SelectorMatcher();\n        map.set(name, matcher);\n      }\n\n      return matcher;\n    }\n    /**\n     * Find the objects that have been added via `addSelectable`\n     * whose css selector is contained in the given css selector.\n     * @param cssSelector A css selector\n     * @param matchedCallback This callback will be called with the object handed into `addSelectable`\n     * @return boolean true if a match was found\n     */\n\n  }, {\n    key: \"match\",\n    value: function match(cssSelector, matchedCallback) {\n      var result = false;\n      var element = cssSelector.element;\n      var classNames = cssSelector.classNames;\n      var attrs = cssSelector.attrs;\n\n      for (var i = 0; i < this._listContexts.length; i++) {\n        this._listContexts[i].alreadyMatched = false;\n      }\n\n      result = this._matchTerminal(this._elementMap, element, cssSelector, matchedCallback) || result;\n      result = this._matchPartial(this._elementPartialMap, element, cssSelector, matchedCallback) || result;\n\n      if (classNames) {\n        for (var _i2 = 0; _i2 < classNames.length; _i2++) {\n          var className = classNames[_i2];\n          result = this._matchTerminal(this._classMap, className, cssSelector, matchedCallback) || result;\n          result = this._matchPartial(this._classPartialMap, className, cssSelector, matchedCallback) || result;\n        }\n      }\n\n      if (attrs) {\n        for (var _i3 = 0; _i3 < attrs.length; _i3 += 2) {\n          var name = attrs[_i3];\n          var value = attrs[_i3 + 1];\n\n          var terminalValuesMap = this._attrValueMap.get(name);\n\n          if (value) {\n            result = this._matchTerminal(terminalValuesMap, '', cssSelector, matchedCallback) || result;\n          }\n\n          result = this._matchTerminal(terminalValuesMap, value, cssSelector, matchedCallback) || result;\n\n          var partialValuesMap = this._attrValuePartialMap.get(name);\n\n          if (value) {\n            result = this._matchPartial(partialValuesMap, '', cssSelector, matchedCallback) || result;\n          }\n\n          result = this._matchPartial(partialValuesMap, value, cssSelector, matchedCallback) || result;\n        }\n      }\n\n      return result;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_matchTerminal\",\n    value: function _matchTerminal(map, name, cssSelector, matchedCallback) {\n      if (!map || typeof name !== 'string') {\n        return false;\n      }\n\n      var selectables = map.get(name) || [];\n      var starSelectables = map.get('*');\n\n      if (starSelectables) {\n        selectables = selectables.concat(starSelectables);\n      }\n\n      if (selectables.length === 0) {\n        return false;\n      }\n\n      var selectable;\n      var result = false;\n\n      for (var i = 0; i < selectables.length; i++) {\n        selectable = selectables[i];\n        result = selectable.finalize(cssSelector, matchedCallback) || result;\n      }\n\n      return result;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_matchPartial\",\n    value: function _matchPartial(map, name, cssSelector, matchedCallback) {\n      if (!map || typeof name !== 'string') {\n        return false;\n      }\n\n      var nestedSelector = map.get(name);\n\n      if (!nestedSelector) {\n        return false;\n      } // TODO(perf): get rid of recursion and measure again\n      // TODO(perf): don't pass the whole selector into the recursion,\n      // but only the not processed parts\n\n\n      return nestedSelector.match(cssSelector, matchedCallback);\n    }\n  }], [{\n    key: \"createNotMatcher\",\n    value: function createNotMatcher(notSelectors) {\n      var notMatcher = new SelectorMatcher();\n      notMatcher.addSelectables(notSelectors, null);\n      return notMatcher;\n    }\n  }]);\n\n  return SelectorMatcher;\n}();\n\nvar SelectorListContext = function SelectorListContext(selectors) {\n  _classCallCheck(this, SelectorListContext);\n\n  this.selectors = selectors;\n  this.alreadyMatched = false;\n}; // Store context to pass back selector and context when a selector is matched\n\n\nvar SelectorContext = /*#__PURE__*/function () {\n  function SelectorContext(selector, cbContext, listContext) {\n    _classCallCheck(this, SelectorContext);\n\n    this.selector = selector;\n    this.cbContext = cbContext;\n    this.listContext = listContext;\n    this.notSelectors = selector.notSelectors;\n  }\n\n  _createClass(SelectorContext, [{\n    key: \"finalize\",\n    value: function finalize(cssSelector, callback) {\n      var result = true;\n\n      if (this.notSelectors.length > 0 && (!this.listContext || !this.listContext.alreadyMatched)) {\n        var notMatcher = SelectorMatcher.createNotMatcher(this.notSelectors);\n        result = !notMatcher.match(cssSelector, null);\n      }\n\n      if (result && callback && (!this.listContext || !this.listContext.alreadyMatched)) {\n        if (this.listContext) {\n          this.listContext.alreadyMatched = true;\n        }\n\n        callback(this.selector, this.cbContext);\n      }\n\n      return result;\n    }\n  }]);\n\n  return SelectorContext;\n}();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar createInject = makeMetadataFactory('Inject', function (token) {\n  return {\n    token: token\n  };\n});\nvar createInjectionToken = makeMetadataFactory('InjectionToken', function (desc) {\n  return {\n    _desc: desc,\n    ɵprov: undefined\n  };\n});\nvar createAttribute = makeMetadataFactory('Attribute', function (attributeName) {\n  return {\n    attributeName: attributeName\n  };\n});\nvar createContentChildren = makeMetadataFactory('ContentChildren', function (selector) {\n  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return Object.assign({\n    selector: selector,\n    first: false,\n    isViewQuery: false,\n    descendants: false\n  }, data);\n});\nvar createContentChild = makeMetadataFactory('ContentChild', function (selector) {\n  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return Object.assign({\n    selector: selector,\n    first: true,\n    isViewQuery: false,\n    descendants: true\n  }, data);\n});\nvar createViewChildren = makeMetadataFactory('ViewChildren', function (selector) {\n  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return Object.assign({\n    selector: selector,\n    first: false,\n    isViewQuery: true,\n    descendants: true\n  }, data);\n});\nvar createViewChild = makeMetadataFactory('ViewChild', function (selector, data) {\n  return Object.assign({\n    selector: selector,\n    first: true,\n    isViewQuery: true,\n    descendants: true\n  }, data);\n});\nvar createDirective = makeMetadataFactory('Directive', function () {\n  var dir = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return dir;\n});\nvar ViewEncapsulation;\n\n(function (ViewEncapsulation) {\n  ViewEncapsulation[ViewEncapsulation[\"Emulated\"] = 0] = \"Emulated\";\n  ViewEncapsulation[ViewEncapsulation[\"Native\"] = 1] = \"Native\";\n  ViewEncapsulation[ViewEncapsulation[\"None\"] = 2] = \"None\";\n  ViewEncapsulation[ViewEncapsulation[\"ShadowDom\"] = 3] = \"ShadowDom\";\n})(ViewEncapsulation || (ViewEncapsulation = {}));\n\nvar ChangeDetectionStrategy;\n\n(function (ChangeDetectionStrategy) {\n  ChangeDetectionStrategy[ChangeDetectionStrategy[\"OnPush\"] = 0] = \"OnPush\";\n  ChangeDetectionStrategy[ChangeDetectionStrategy[\"Default\"] = 1] = \"Default\";\n})(ChangeDetectionStrategy || (ChangeDetectionStrategy = {}));\n\nvar createComponent = makeMetadataFactory('Component', function () {\n  var c = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return Object.assign({\n    changeDetection: ChangeDetectionStrategy.Default\n  }, c);\n});\nvar createPipe = makeMetadataFactory('Pipe', function (p) {\n  return Object.assign({\n    pure: true\n  }, p);\n});\nvar createInput = makeMetadataFactory('Input', function (bindingPropertyName) {\n  return {\n    bindingPropertyName: bindingPropertyName\n  };\n});\nvar createOutput = makeMetadataFactory('Output', function (bindingPropertyName) {\n  return {\n    bindingPropertyName: bindingPropertyName\n  };\n});\nvar createHostBinding = makeMetadataFactory('HostBinding', function (hostPropertyName) {\n  return {\n    hostPropertyName: hostPropertyName\n  };\n});\nvar createHostListener = makeMetadataFactory('HostListener', function (eventName, args) {\n  return {\n    eventName: eventName,\n    args: args\n  };\n});\nvar createNgModule = makeMetadataFactory('NgModule', function (ngModule) {\n  return ngModule;\n});\nvar createInjectable = makeMetadataFactory('Injectable', function () {\n  var injectable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return injectable;\n});\nvar CUSTOM_ELEMENTS_SCHEMA = {\n  name: 'custom-elements'\n};\nvar NO_ERRORS_SCHEMA = {\n  name: 'no-errors-schema'\n};\nvar createOptional = makeMetadataFactory('Optional');\nvar createSelf = makeMetadataFactory('Self');\nvar createSkipSelf = makeMetadataFactory('SkipSelf');\nvar createHost = makeMetadataFactory('Host');\nvar Type = Function;\nvar SecurityContext;\n\n(function (SecurityContext) {\n  SecurityContext[SecurityContext[\"NONE\"] = 0] = \"NONE\";\n  SecurityContext[SecurityContext[\"HTML\"] = 1] = \"HTML\";\n  SecurityContext[SecurityContext[\"STYLE\"] = 2] = \"STYLE\";\n  SecurityContext[SecurityContext[\"SCRIPT\"] = 3] = \"SCRIPT\";\n  SecurityContext[SecurityContext[\"URL\"] = 4] = \"URL\";\n  SecurityContext[SecurityContext[\"RESOURCE_URL\"] = 5] = \"RESOURCE_URL\";\n})(SecurityContext || (SecurityContext = {}));\n\nvar MissingTranslationStrategy;\n\n(function (MissingTranslationStrategy) {\n  MissingTranslationStrategy[MissingTranslationStrategy[\"Error\"] = 0] = \"Error\";\n  MissingTranslationStrategy[MissingTranslationStrategy[\"Warning\"] = 1] = \"Warning\";\n  MissingTranslationStrategy[MissingTranslationStrategy[\"Ignore\"] = 2] = \"Ignore\";\n})(MissingTranslationStrategy || (MissingTranslationStrategy = {}));\n\nfunction makeMetadataFactory(name, props) {\n  // This must be declared as a function, not a fat arrow, so that ES2015 devmode produces code\n  // that works with the static_reflector.ts in the ViewEngine compiler.\n  // In particular, `_registerDecoratorOrConstructor` assumes that the value returned here can be\n  // new'ed.\n  function factory() {\n    var values = props ? props.apply(void 0, arguments) : {};\n    return Object.assign({\n      ngMetadataName: name\n    }, values);\n  }\n\n  factory.isTypeOf = function (obj) {\n    return obj && obj.ngMetadataName === name;\n  };\n\n  factory.ngMetadataName = name;\n  return factory;\n}\n\nfunction parserSelectorToSimpleSelector(selector) {\n  var classes = selector.classNames && selector.classNames.length ? [8\n  /* CLASS */\n  ].concat(_toConsumableArray(selector.classNames)) : [];\n  var elementName = selector.element && selector.element !== '*' ? selector.element : '';\n  return [elementName].concat(_toConsumableArray(selector.attrs), _toConsumableArray(classes));\n}\n\nfunction parserSelectorToNegativeSelector(selector) {\n  var classes = selector.classNames && selector.classNames.length ? [8\n  /* CLASS */\n  ].concat(_toConsumableArray(selector.classNames)) : [];\n\n  if (selector.element) {\n    return [1\n    /* NOT */\n    | 4\n    /* ELEMENT */\n    , selector.element].concat(_toConsumableArray(selector.attrs), _toConsumableArray(classes));\n  } else if (selector.attrs.length) {\n    return [1\n    /* NOT */\n    | 2\n    /* ATTRIBUTE */\n    ].concat(_toConsumableArray(selector.attrs), _toConsumableArray(classes));\n  } else {\n    return selector.classNames && selector.classNames.length ? [1\n    /* NOT */\n    | 8\n    /* CLASS */\n    ].concat(_toConsumableArray(selector.classNames)) : [];\n  }\n}\n\nfunction parserSelectorToR3Selector(selector) {\n  var positive = parserSelectorToSimpleSelector(selector);\n  var negative = selector.notSelectors && selector.notSelectors.length ? selector.notSelectors.map(function (notSelector) {\n    return parserSelectorToNegativeSelector(notSelector);\n  }) : [];\n  return positive.concat.apply(positive, _toConsumableArray(negative));\n}\n\nfunction parseSelectorToR3Selector(selector) {\n  return selector ? CssSelector.parse(selector).map(parserSelectorToR3Selector) : [];\n}\n\nvar core = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  createInject: createInject,\n  createInjectionToken: createInjectionToken,\n  createAttribute: createAttribute,\n  createContentChildren: createContentChildren,\n  createContentChild: createContentChild,\n  createViewChildren: createViewChildren,\n  createViewChild: createViewChild,\n  createDirective: createDirective,\n\n  get ViewEncapsulation() {\n    return ViewEncapsulation;\n  },\n\n  get ChangeDetectionStrategy() {\n    return ChangeDetectionStrategy;\n  },\n\n  createComponent: createComponent,\n  createPipe: createPipe,\n  createInput: createInput,\n  createOutput: createOutput,\n  createHostBinding: createHostBinding,\n  createHostListener: createHostListener,\n  createNgModule: createNgModule,\n  createInjectable: createInjectable,\n  CUSTOM_ELEMENTS_SCHEMA: CUSTOM_ELEMENTS_SCHEMA,\n  NO_ERRORS_SCHEMA: NO_ERRORS_SCHEMA,\n  createOptional: createOptional,\n  createSelf: createSelf,\n  createSkipSelf: createSkipSelf,\n  createHost: createHost,\n  Type: Type,\n\n  get SecurityContext() {\n    return SecurityContext;\n  },\n\n  get MissingTranslationStrategy() {\n    return MissingTranslationStrategy;\n  },\n\n  parseSelectorToR3Selector: parseSelectorToR3Selector\n});\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n//// Types\n\nvar TypeModifier;\n\n(function (TypeModifier) {\n  TypeModifier[TypeModifier[\"Const\"] = 0] = \"Const\";\n})(TypeModifier || (TypeModifier = {}));\n\nvar Type$1 = /*#__PURE__*/function () {\n  function Type$1() {\n    var modifiers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n    _classCallCheck(this, Type$1);\n\n    this.modifiers = modifiers;\n\n    if (!modifiers) {\n      this.modifiers = [];\n    }\n  }\n\n  _createClass(Type$1, [{\n    key: \"hasModifier\",\n    value: function hasModifier(modifier) {\n      return this.modifiers.indexOf(modifier) !== -1;\n    }\n  }]);\n\n  return Type$1;\n}();\n\nvar BuiltinTypeName;\n\n(function (BuiltinTypeName) {\n  BuiltinTypeName[BuiltinTypeName[\"Dynamic\"] = 0] = \"Dynamic\";\n  BuiltinTypeName[BuiltinTypeName[\"Bool\"] = 1] = \"Bool\";\n  BuiltinTypeName[BuiltinTypeName[\"String\"] = 2] = \"String\";\n  BuiltinTypeName[BuiltinTypeName[\"Int\"] = 3] = \"Int\";\n  BuiltinTypeName[BuiltinTypeName[\"Number\"] = 4] = \"Number\";\n  BuiltinTypeName[BuiltinTypeName[\"Function\"] = 5] = \"Function\";\n  BuiltinTypeName[BuiltinTypeName[\"Inferred\"] = 6] = \"Inferred\";\n  BuiltinTypeName[BuiltinTypeName[\"None\"] = 7] = \"None\";\n})(BuiltinTypeName || (BuiltinTypeName = {}));\n\nvar BuiltinType = /*#__PURE__*/function (_Type$) {\n  _inherits(BuiltinType, _Type$);\n\n  var _super = _createSuper(BuiltinType);\n\n  function BuiltinType(name) {\n    var _this2;\n\n    var modifiers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    _classCallCheck(this, BuiltinType);\n\n    _this2 = _super.call(this, modifiers);\n    _this2.name = name;\n    return _this2;\n  }\n\n  _createClass(BuiltinType, [{\n    key: \"visitType\",\n    value: function visitType(visitor, context) {\n      return visitor.visitBuiltinType(this, context);\n    }\n  }]);\n\n  return BuiltinType;\n}(Type$1);\n\nvar ExpressionType = /*#__PURE__*/function (_Type$2) {\n  _inherits(ExpressionType, _Type$2);\n\n  var _super2 = _createSuper(ExpressionType);\n\n  function ExpressionType(value) {\n    var _this3;\n\n    var modifiers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    var typeParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    _classCallCheck(this, ExpressionType);\n\n    _this3 = _super2.call(this, modifiers);\n    _this3.value = value;\n    _this3.typeParams = typeParams;\n    return _this3;\n  }\n\n  _createClass(ExpressionType, [{\n    key: \"visitType\",\n    value: function visitType(visitor, context) {\n      return visitor.visitExpressionType(this, context);\n    }\n  }]);\n\n  return ExpressionType;\n}(Type$1);\n\nvar ArrayType = /*#__PURE__*/function (_Type$3) {\n  _inherits(ArrayType, _Type$3);\n\n  var _super3 = _createSuper(ArrayType);\n\n  function ArrayType(of) {\n    var _this4;\n\n    var modifiers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    _classCallCheck(this, ArrayType);\n\n    _this4 = _super3.call(this, modifiers);\n    _this4.of = of;\n    return _this4;\n  }\n\n  _createClass(ArrayType, [{\n    key: \"visitType\",\n    value: function visitType(visitor, context) {\n      return visitor.visitArrayType(this, context);\n    }\n  }]);\n\n  return ArrayType;\n}(Type$1);\n\nvar MapType = /*#__PURE__*/function (_Type$4) {\n  _inherits(MapType, _Type$4);\n\n  var _super4 = _createSuper(MapType);\n\n  function MapType(valueType) {\n    var _this5;\n\n    var modifiers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    _classCallCheck(this, MapType);\n\n    _this5 = _super4.call(this, modifiers);\n    _this5.valueType = valueType || null;\n    return _this5;\n  }\n\n  _createClass(MapType, [{\n    key: \"visitType\",\n    value: function visitType(visitor, context) {\n      return visitor.visitMapType(this, context);\n    }\n  }]);\n\n  return MapType;\n}(Type$1);\n\nvar DYNAMIC_TYPE = new BuiltinType(BuiltinTypeName.Dynamic);\nvar INFERRED_TYPE = new BuiltinType(BuiltinTypeName.Inferred);\nvar BOOL_TYPE = new BuiltinType(BuiltinTypeName.Bool);\nvar INT_TYPE = new BuiltinType(BuiltinTypeName.Int);\nvar NUMBER_TYPE = new BuiltinType(BuiltinTypeName.Number);\nvar STRING_TYPE = new BuiltinType(BuiltinTypeName.String);\nvar FUNCTION_TYPE = new BuiltinType(BuiltinTypeName.Function);\nvar NONE_TYPE = new BuiltinType(BuiltinTypeName.None); ///// Expressions\n\nvar BinaryOperator;\n\n(function (BinaryOperator) {\n  BinaryOperator[BinaryOperator[\"Equals\"] = 0] = \"Equals\";\n  BinaryOperator[BinaryOperator[\"NotEquals\"] = 1] = \"NotEquals\";\n  BinaryOperator[BinaryOperator[\"Identical\"] = 2] = \"Identical\";\n  BinaryOperator[BinaryOperator[\"NotIdentical\"] = 3] = \"NotIdentical\";\n  BinaryOperator[BinaryOperator[\"Minus\"] = 4] = \"Minus\";\n  BinaryOperator[BinaryOperator[\"Plus\"] = 5] = \"Plus\";\n  BinaryOperator[BinaryOperator[\"Divide\"] = 6] = \"Divide\";\n  BinaryOperator[BinaryOperator[\"Multiply\"] = 7] = \"Multiply\";\n  BinaryOperator[BinaryOperator[\"Modulo\"] = 8] = \"Modulo\";\n  BinaryOperator[BinaryOperator[\"And\"] = 9] = \"And\";\n  BinaryOperator[BinaryOperator[\"Or\"] = 10] = \"Or\";\n  BinaryOperator[BinaryOperator[\"BitwiseAnd\"] = 11] = \"BitwiseAnd\";\n  BinaryOperator[BinaryOperator[\"Lower\"] = 12] = \"Lower\";\n  BinaryOperator[BinaryOperator[\"LowerEquals\"] = 13] = \"LowerEquals\";\n  BinaryOperator[BinaryOperator[\"Bigger\"] = 14] = \"Bigger\";\n  BinaryOperator[BinaryOperator[\"BiggerEquals\"] = 15] = \"BiggerEquals\";\n})(BinaryOperator || (BinaryOperator = {}));\n\nfunction nullSafeIsEquivalent(base, other) {\n  if (base == null || other == null) {\n    return base == other;\n  }\n\n  return base.isEquivalent(other);\n}\n\nfunction areAllEquivalent(base, other) {\n  var len = base.length;\n\n  if (len !== other.length) {\n    return false;\n  }\n\n  for (var i = 0; i < len; i++) {\n    if (!base[i].isEquivalent(other[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nvar Expression = /*#__PURE__*/function () {\n  function Expression(type, sourceSpan) {\n    _classCallCheck(this, Expression);\n\n    this.type = type || null;\n    this.sourceSpan = sourceSpan || null;\n  }\n\n  _createClass(Expression, [{\n    key: \"prop\",\n    value: function prop(name, sourceSpan) {\n      return new ReadPropExpr(this, name, null, sourceSpan);\n    }\n  }, {\n    key: \"key\",\n    value: function key(index, type, sourceSpan) {\n      return new ReadKeyExpr(this, index, type, sourceSpan);\n    }\n  }, {\n    key: \"callMethod\",\n    value: function callMethod(name, params, sourceSpan) {\n      return new InvokeMethodExpr(this, name, params, null, sourceSpan);\n    }\n  }, {\n    key: \"callFn\",\n    value: function callFn(params, sourceSpan) {\n      return new InvokeFunctionExpr(this, params, null, sourceSpan);\n    }\n  }, {\n    key: \"instantiate\",\n    value: function instantiate(params, type, sourceSpan) {\n      return new InstantiateExpr(this, params, type, sourceSpan);\n    }\n  }, {\n    key: \"conditional\",\n    value: function conditional(trueCase) {\n      var falseCase = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var sourceSpan = arguments.length > 2 ? arguments[2] : undefined;\n      return new ConditionalExpr(this, trueCase, falseCase, null, sourceSpan);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(rhs, sourceSpan) {\n      return new BinaryOperatorExpr(BinaryOperator.Equals, this, rhs, null, sourceSpan);\n    }\n  }, {\n    key: \"notEquals\",\n    value: function notEquals(rhs, sourceSpan) {\n      return new BinaryOperatorExpr(BinaryOperator.NotEquals, this, rhs, null, sourceSpan);\n    }\n  }, {\n    key: \"identical\",\n    value: function identical(rhs, sourceSpan) {\n      return new BinaryOperatorExpr(BinaryOperator.Identical, this, rhs, null, sourceSpan);\n    }\n  }, {\n    key: \"notIdentical\",\n    value: function notIdentical(rhs, sourceSpan) {\n      return new BinaryOperatorExpr(BinaryOperator.NotIdentical, this, rhs, null, sourceSpan);\n    }\n  }, {\n    key: \"minus\",\n    value: function minus(rhs, sourceSpan) {\n      return new BinaryOperatorExpr(BinaryOperator.Minus, this, rhs, null, sourceSpan);\n    }\n  }, {\n    key: \"plus\",\n    value: function plus(rhs, sourceSpan) {\n      return new BinaryOperatorExpr(BinaryOperator.Plus, this, rhs, null, sourceSpan);\n    }\n  }, {\n    key: \"divide\",\n    value: function divide(rhs, sourceSpan) {\n      return new BinaryOperatorExpr(BinaryOperator.Divide, this, rhs, null, sourceSpan);\n    }\n  }, {\n    key: \"multiply\",\n    value: function multiply(rhs, sourceSpan) {\n      return new BinaryOperatorExpr(BinaryOperator.Multiply, this, rhs, null, sourceSpan);\n    }\n  }, {\n    key: \"modulo\",\n    value: function modulo(rhs, sourceSpan) {\n      return new BinaryOperatorExpr(BinaryOperator.Modulo, this, rhs, null, sourceSpan);\n    }\n  }, {\n    key: \"and\",\n    value: function and(rhs, sourceSpan) {\n      return new BinaryOperatorExpr(BinaryOperator.And, this, rhs, null, sourceSpan);\n    }\n  }, {\n    key: \"bitwiseAnd\",\n    value: function bitwiseAnd(rhs, sourceSpan) {\n      var parens = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      return new BinaryOperatorExpr(BinaryOperator.BitwiseAnd, this, rhs, null, sourceSpan, parens);\n    }\n  }, {\n    key: \"or\",\n    value: function or(rhs, sourceSpan) {\n      return new BinaryOperatorExpr(BinaryOperator.Or, this, rhs, null, sourceSpan);\n    }\n  }, {\n    key: \"lower\",\n    value: function lower(rhs, sourceSpan) {\n      return new BinaryOperatorExpr(BinaryOperator.Lower, this, rhs, null, sourceSpan);\n    }\n  }, {\n    key: \"lowerEquals\",\n    value: function lowerEquals(rhs, sourceSpan) {\n      return new BinaryOperatorExpr(BinaryOperator.LowerEquals, this, rhs, null, sourceSpan);\n    }\n  }, {\n    key: \"bigger\",\n    value: function bigger(rhs, sourceSpan) {\n      return new BinaryOperatorExpr(BinaryOperator.Bigger, this, rhs, null, sourceSpan);\n    }\n  }, {\n    key: \"biggerEquals\",\n    value: function biggerEquals(rhs, sourceSpan) {\n      return new BinaryOperatorExpr(BinaryOperator.BiggerEquals, this, rhs, null, sourceSpan);\n    }\n  }, {\n    key: \"isBlank\",\n    value: function isBlank(sourceSpan) {\n      // Note: We use equals by purpose here to compare to null and undefined in JS.\n      // We use the typed null to allow strictNullChecks to narrow types.\n      return this.equals(TYPED_NULL_EXPR, sourceSpan);\n    }\n  }, {\n    key: \"cast\",\n    value: function cast(type, sourceSpan) {\n      return new CastExpr(this, type, sourceSpan);\n    }\n  }, {\n    key: \"toStmt\",\n    value: function toStmt() {\n      return new ExpressionStatement(this, null);\n    }\n  }]);\n\n  return Expression;\n}();\n\nvar BuiltinVar;\n\n(function (BuiltinVar) {\n  BuiltinVar[BuiltinVar[\"This\"] = 0] = \"This\";\n  BuiltinVar[BuiltinVar[\"Super\"] = 1] = \"Super\";\n  BuiltinVar[BuiltinVar[\"CatchError\"] = 2] = \"CatchError\";\n  BuiltinVar[BuiltinVar[\"CatchStack\"] = 3] = \"CatchStack\";\n})(BuiltinVar || (BuiltinVar = {}));\n\nvar ReadVarExpr = /*#__PURE__*/function (_Expression) {\n  _inherits(ReadVarExpr, _Expression);\n\n  var _super5 = _createSuper(ReadVarExpr);\n\n  function ReadVarExpr(name, type, sourceSpan) {\n    var _this6;\n\n    _classCallCheck(this, ReadVarExpr);\n\n    _this6 = _super5.call(this, type, sourceSpan);\n\n    if (typeof name === 'string') {\n      _this6.name = name;\n      _this6.builtin = null;\n    } else {\n      _this6.name = null;\n      _this6.builtin = name;\n    }\n\n    return _this6;\n  }\n\n  _createClass(ReadVarExpr, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return e instanceof ReadVarExpr && this.name === e.name && this.builtin === e.builtin;\n    }\n  }, {\n    key: \"isConstant\",\n    value: function isConstant() {\n      return false;\n    }\n  }, {\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      return visitor.visitReadVarExpr(this, context);\n    }\n  }, {\n    key: \"set\",\n    value: function set(value) {\n      if (!this.name) {\n        throw new Error(\"Built in variable \".concat(this.builtin, \" can not be assigned to.\"));\n      }\n\n      return new WriteVarExpr(this.name, value, null, this.sourceSpan);\n    }\n  }]);\n\n  return ReadVarExpr;\n}(Expression);\n\nvar TypeofExpr = /*#__PURE__*/function (_Expression2) {\n  _inherits(TypeofExpr, _Expression2);\n\n  var _super6 = _createSuper(TypeofExpr);\n\n  function TypeofExpr(expr, type, sourceSpan) {\n    var _this7;\n\n    _classCallCheck(this, TypeofExpr);\n\n    _this7 = _super6.call(this, type, sourceSpan);\n    _this7.expr = expr;\n    return _this7;\n  }\n\n  _createClass(TypeofExpr, [{\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      return visitor.visitTypeofExpr(this, context);\n    }\n  }, {\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return e instanceof TypeofExpr && e.expr.isEquivalent(this.expr);\n    }\n  }, {\n    key: \"isConstant\",\n    value: function isConstant() {\n      return this.expr.isConstant();\n    }\n  }]);\n\n  return TypeofExpr;\n}(Expression);\n\nvar WrappedNodeExpr = /*#__PURE__*/function (_Expression3) {\n  _inherits(WrappedNodeExpr, _Expression3);\n\n  var _super7 = _createSuper(WrappedNodeExpr);\n\n  function WrappedNodeExpr(node, type, sourceSpan) {\n    var _this8;\n\n    _classCallCheck(this, WrappedNodeExpr);\n\n    _this8 = _super7.call(this, type, sourceSpan);\n    _this8.node = node;\n    return _this8;\n  }\n\n  _createClass(WrappedNodeExpr, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return e instanceof WrappedNodeExpr && this.node === e.node;\n    }\n  }, {\n    key: \"isConstant\",\n    value: function isConstant() {\n      return false;\n    }\n  }, {\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      return visitor.visitWrappedNodeExpr(this, context);\n    }\n  }]);\n\n  return WrappedNodeExpr;\n}(Expression);\n\nvar WriteVarExpr = /*#__PURE__*/function (_Expression4) {\n  _inherits(WriteVarExpr, _Expression4);\n\n  var _super8 = _createSuper(WriteVarExpr);\n\n  function WriteVarExpr(name, value, type, sourceSpan) {\n    var _this9;\n\n    _classCallCheck(this, WriteVarExpr);\n\n    _this9 = _super8.call(this, type || value.type, sourceSpan);\n    _this9.name = name;\n    _this9.value = value;\n    return _this9;\n  }\n\n  _createClass(WriteVarExpr, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return e instanceof WriteVarExpr && this.name === e.name && this.value.isEquivalent(e.value);\n    }\n  }, {\n    key: \"isConstant\",\n    value: function isConstant() {\n      return false;\n    }\n  }, {\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      return visitor.visitWriteVarExpr(this, context);\n    }\n  }, {\n    key: \"toDeclStmt\",\n    value: function toDeclStmt(type, modifiers) {\n      return new DeclareVarStmt(this.name, this.value, type, modifiers, this.sourceSpan);\n    }\n  }, {\n    key: \"toConstDecl\",\n    value: function toConstDecl() {\n      return this.toDeclStmt(INFERRED_TYPE, [StmtModifier.Final]);\n    }\n  }]);\n\n  return WriteVarExpr;\n}(Expression);\n\nvar WriteKeyExpr = /*#__PURE__*/function (_Expression5) {\n  _inherits(WriteKeyExpr, _Expression5);\n\n  var _super9 = _createSuper(WriteKeyExpr);\n\n  function WriteKeyExpr(receiver, index, value, type, sourceSpan) {\n    var _this10;\n\n    _classCallCheck(this, WriteKeyExpr);\n\n    _this10 = _super9.call(this, type || value.type, sourceSpan);\n    _this10.receiver = receiver;\n    _this10.index = index;\n    _this10.value = value;\n    return _this10;\n  }\n\n  _createClass(WriteKeyExpr, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return e instanceof WriteKeyExpr && this.receiver.isEquivalent(e.receiver) && this.index.isEquivalent(e.index) && this.value.isEquivalent(e.value);\n    }\n  }, {\n    key: \"isConstant\",\n    value: function isConstant() {\n      return false;\n    }\n  }, {\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      return visitor.visitWriteKeyExpr(this, context);\n    }\n  }]);\n\n  return WriteKeyExpr;\n}(Expression);\n\nvar WritePropExpr = /*#__PURE__*/function (_Expression6) {\n  _inherits(WritePropExpr, _Expression6);\n\n  var _super10 = _createSuper(WritePropExpr);\n\n  function WritePropExpr(receiver, name, value, type, sourceSpan) {\n    var _this11;\n\n    _classCallCheck(this, WritePropExpr);\n\n    _this11 = _super10.call(this, type || value.type, sourceSpan);\n    _this11.receiver = receiver;\n    _this11.name = name;\n    _this11.value = value;\n    return _this11;\n  }\n\n  _createClass(WritePropExpr, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return e instanceof WritePropExpr && this.receiver.isEquivalent(e.receiver) && this.name === e.name && this.value.isEquivalent(e.value);\n    }\n  }, {\n    key: \"isConstant\",\n    value: function isConstant() {\n      return false;\n    }\n  }, {\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      return visitor.visitWritePropExpr(this, context);\n    }\n  }]);\n\n  return WritePropExpr;\n}(Expression);\n\nvar BuiltinMethod;\n\n(function (BuiltinMethod) {\n  BuiltinMethod[BuiltinMethod[\"ConcatArray\"] = 0] = \"ConcatArray\";\n  BuiltinMethod[BuiltinMethod[\"SubscribeObservable\"] = 1] = \"SubscribeObservable\";\n  BuiltinMethod[BuiltinMethod[\"Bind\"] = 2] = \"Bind\";\n})(BuiltinMethod || (BuiltinMethod = {}));\n\nvar InvokeMethodExpr = /*#__PURE__*/function (_Expression7) {\n  _inherits(InvokeMethodExpr, _Expression7);\n\n  var _super11 = _createSuper(InvokeMethodExpr);\n\n  function InvokeMethodExpr(receiver, method, args, type, sourceSpan) {\n    var _this12;\n\n    _classCallCheck(this, InvokeMethodExpr);\n\n    _this12 = _super11.call(this, type, sourceSpan);\n    _this12.receiver = receiver;\n    _this12.args = args;\n\n    if (typeof method === 'string') {\n      _this12.name = method;\n      _this12.builtin = null;\n    } else {\n      _this12.name = null;\n      _this12.builtin = method;\n    }\n\n    return _this12;\n  }\n\n  _createClass(InvokeMethodExpr, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return e instanceof InvokeMethodExpr && this.receiver.isEquivalent(e.receiver) && this.name === e.name && this.builtin === e.builtin && areAllEquivalent(this.args, e.args);\n    }\n  }, {\n    key: \"isConstant\",\n    value: function isConstant() {\n      return false;\n    }\n  }, {\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      return visitor.visitInvokeMethodExpr(this, context);\n    }\n  }]);\n\n  return InvokeMethodExpr;\n}(Expression);\n\nvar InvokeFunctionExpr = /*#__PURE__*/function (_Expression8) {\n  _inherits(InvokeFunctionExpr, _Expression8);\n\n  var _super12 = _createSuper(InvokeFunctionExpr);\n\n  function InvokeFunctionExpr(fn, args, type, sourceSpan) {\n    var _this13;\n\n    var pure = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n    _classCallCheck(this, InvokeFunctionExpr);\n\n    _this13 = _super12.call(this, type, sourceSpan);\n    _this13.fn = fn;\n    _this13.args = args;\n    _this13.pure = pure;\n    return _this13;\n  }\n\n  _createClass(InvokeFunctionExpr, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return e instanceof InvokeFunctionExpr && this.fn.isEquivalent(e.fn) && areAllEquivalent(this.args, e.args) && this.pure === e.pure;\n    }\n  }, {\n    key: \"isConstant\",\n    value: function isConstant() {\n      return false;\n    }\n  }, {\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      return visitor.visitInvokeFunctionExpr(this, context);\n    }\n  }]);\n\n  return InvokeFunctionExpr;\n}(Expression);\n\nvar InstantiateExpr = /*#__PURE__*/function (_Expression9) {\n  _inherits(InstantiateExpr, _Expression9);\n\n  var _super13 = _createSuper(InstantiateExpr);\n\n  function InstantiateExpr(classExpr, args, type, sourceSpan) {\n    var _this14;\n\n    _classCallCheck(this, InstantiateExpr);\n\n    _this14 = _super13.call(this, type, sourceSpan);\n    _this14.classExpr = classExpr;\n    _this14.args = args;\n    return _this14;\n  }\n\n  _createClass(InstantiateExpr, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return e instanceof InstantiateExpr && this.classExpr.isEquivalent(e.classExpr) && areAllEquivalent(this.args, e.args);\n    }\n  }, {\n    key: \"isConstant\",\n    value: function isConstant() {\n      return false;\n    }\n  }, {\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      return visitor.visitInstantiateExpr(this, context);\n    }\n  }]);\n\n  return InstantiateExpr;\n}(Expression);\n\nvar LiteralExpr = /*#__PURE__*/function (_Expression10) {\n  _inherits(LiteralExpr, _Expression10);\n\n  var _super14 = _createSuper(LiteralExpr);\n\n  function LiteralExpr(value, type, sourceSpan) {\n    var _this15;\n\n    _classCallCheck(this, LiteralExpr);\n\n    _this15 = _super14.call(this, type, sourceSpan);\n    _this15.value = value;\n    return _this15;\n  }\n\n  _createClass(LiteralExpr, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return e instanceof LiteralExpr && this.value === e.value;\n    }\n  }, {\n    key: \"isConstant\",\n    value: function isConstant() {\n      return true;\n    }\n  }, {\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      return visitor.visitLiteralExpr(this, context);\n    }\n  }]);\n\n  return LiteralExpr;\n}(Expression);\n\nvar LocalizedString = /*#__PURE__*/function (_Expression11) {\n  _inherits(LocalizedString, _Expression11);\n\n  var _super15 = _createSuper(LocalizedString);\n\n  function LocalizedString(metaBlock, messageParts, placeHolderNames, expressions, sourceSpan) {\n    var _this16;\n\n    _classCallCheck(this, LocalizedString);\n\n    _this16 = _super15.call(this, STRING_TYPE, sourceSpan);\n    _this16.metaBlock = metaBlock;\n    _this16.messageParts = messageParts;\n    _this16.placeHolderNames = placeHolderNames;\n    _this16.expressions = expressions;\n    return _this16;\n  }\n\n  _createClass(LocalizedString, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      // return e instanceof LocalizedString && this.message === e.message;\n      return false;\n    }\n  }, {\n    key: \"isConstant\",\n    value: function isConstant() {\n      return false;\n    }\n  }, {\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      return visitor.visitLocalizedString(this, context);\n    }\n    /**\n     * Serialize the given `meta` and `messagePart` into \"cooked\" and \"raw\" strings that can be used\n     * in a `$localize` tagged string. The format of the metadata is the same as that parsed by\n     * `parseI18nMeta()`.\n     *\n     * @param meta The metadata to serialize\n     * @param messagePart The first part of the tagged string\n     */\n\n  }, {\n    key: \"serializeI18nHead\",\n    value: function serializeI18nHead() {\n      var MEANING_SEPARATOR = '|';\n      var ID_SEPARATOR = '@@';\n      var LEGACY_ID_INDICATOR = '␟';\n      var metaBlock = this.metaBlock.description || '';\n\n      if (this.metaBlock.meaning) {\n        metaBlock = \"\".concat(this.metaBlock.meaning).concat(MEANING_SEPARATOR).concat(metaBlock);\n      }\n\n      if (this.metaBlock.customId) {\n        metaBlock = \"\".concat(metaBlock).concat(ID_SEPARATOR).concat(this.metaBlock.customId);\n      }\n\n      if (this.metaBlock.legacyIds) {\n        this.metaBlock.legacyIds.forEach(function (legacyId) {\n          metaBlock = \"\".concat(metaBlock).concat(LEGACY_ID_INDICATOR).concat(legacyId);\n        });\n      }\n\n      return createCookedRawString(metaBlock, this.messageParts[0]);\n    }\n    /**\n     * Serialize the given `placeholderName` and `messagePart` into \"cooked\" and \"raw\" strings that\n     * can be used in a `$localize` tagged string.\n     *\n     * @param placeholderName The placeholder name to serialize\n     * @param messagePart The following message string after this placeholder\n     */\n\n  }, {\n    key: \"serializeI18nTemplatePart\",\n    value: function serializeI18nTemplatePart(partIndex) {\n      var placeholderName = this.placeHolderNames[partIndex - 1];\n      var messagePart = this.messageParts[partIndex];\n      return createCookedRawString(placeholderName, messagePart);\n    }\n  }]);\n\n  return LocalizedString;\n}(Expression);\n\nvar escapeSlashes = function escapeSlashes(str) {\n  return str.replace(/\\\\/g, '\\\\\\\\');\n};\n\nvar escapeStartingColon = function escapeStartingColon(str) {\n  return str.replace(/^:/, '\\\\:');\n};\n\nvar escapeColons = function escapeColons(str) {\n  return str.replace(/:/g, '\\\\:');\n};\n\nvar escapeForMessagePart = function escapeForMessagePart(str) {\n  return str.replace(/`/g, '\\\\`').replace(/\\${/g, '$\\\\{');\n};\n/**\n * Creates a `{cooked, raw}` object from the `metaBlock` and `messagePart`.\n *\n * The `raw` text must have various character sequences escaped:\n * * \"\\\" would otherwise indicate that the next character is a control character.\n * * \"`\" and \"${\" are template string control sequences that would otherwise prematurely indicate\n *   the end of a message part.\n * * \":\" inside a metablock would prematurely indicate the end of the metablock.\n * * \":\" at the start of a messagePart with no metablock would erroneously indicate the start of a\n *   metablock.\n *\n * @param metaBlock Any metadata that should be prepended to the string\n * @param messagePart The message part of the string\n */\n\n\nfunction createCookedRawString(metaBlock, messagePart) {\n  if (metaBlock === '') {\n    return {\n      cooked: messagePart,\n      raw: escapeForMessagePart(escapeStartingColon(escapeSlashes(messagePart)))\n    };\n  } else {\n    return {\n      cooked: \":\".concat(metaBlock, \":\").concat(messagePart),\n      raw: escapeForMessagePart(\":\".concat(escapeColons(escapeSlashes(metaBlock)), \":\").concat(escapeSlashes(messagePart)))\n    };\n  }\n}\n\nvar ExternalExpr = /*#__PURE__*/function (_Expression12) {\n  _inherits(ExternalExpr, _Expression12);\n\n  var _super16 = _createSuper(ExternalExpr);\n\n  function ExternalExpr(value, type) {\n    var _this17;\n\n    var typeParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    var sourceSpan = arguments.length > 3 ? arguments[3] : undefined;\n\n    _classCallCheck(this, ExternalExpr);\n\n    _this17 = _super16.call(this, type, sourceSpan);\n    _this17.value = value;\n    _this17.typeParams = typeParams;\n    return _this17;\n  }\n\n  _createClass(ExternalExpr, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return e instanceof ExternalExpr && this.value.name === e.value.name && this.value.moduleName === e.value.moduleName && this.value.runtime === e.value.runtime;\n    }\n  }, {\n    key: \"isConstant\",\n    value: function isConstant() {\n      return false;\n    }\n  }, {\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      return visitor.visitExternalExpr(this, context);\n    }\n  }]);\n\n  return ExternalExpr;\n}(Expression);\n\nvar ExternalReference = function ExternalReference(moduleName, name, runtime) {\n  _classCallCheck(this, ExternalReference);\n\n  this.moduleName = moduleName;\n  this.name = name;\n  this.runtime = runtime;\n};\n\nvar ConditionalExpr = /*#__PURE__*/function (_Expression13) {\n  _inherits(ConditionalExpr, _Expression13);\n\n  var _super17 = _createSuper(ConditionalExpr);\n\n  function ConditionalExpr(condition, trueCase) {\n    var _this18;\n\n    var falseCase = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    var type = arguments.length > 3 ? arguments[3] : undefined;\n    var sourceSpan = arguments.length > 4 ? arguments[4] : undefined;\n\n    _classCallCheck(this, ConditionalExpr);\n\n    _this18 = _super17.call(this, type || trueCase.type, sourceSpan);\n    _this18.condition = condition;\n    _this18.falseCase = falseCase;\n    _this18.trueCase = trueCase;\n    return _this18;\n  }\n\n  _createClass(ConditionalExpr, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return e instanceof ConditionalExpr && this.condition.isEquivalent(e.condition) && this.trueCase.isEquivalent(e.trueCase) && nullSafeIsEquivalent(this.falseCase, e.falseCase);\n    }\n  }, {\n    key: \"isConstant\",\n    value: function isConstant() {\n      return false;\n    }\n  }, {\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      return visitor.visitConditionalExpr(this, context);\n    }\n  }]);\n\n  return ConditionalExpr;\n}(Expression);\n\nvar NotExpr = /*#__PURE__*/function (_Expression14) {\n  _inherits(NotExpr, _Expression14);\n\n  var _super18 = _createSuper(NotExpr);\n\n  function NotExpr(condition, sourceSpan) {\n    var _this19;\n\n    _classCallCheck(this, NotExpr);\n\n    _this19 = _super18.call(this, BOOL_TYPE, sourceSpan);\n    _this19.condition = condition;\n    return _this19;\n  }\n\n  _createClass(NotExpr, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return e instanceof NotExpr && this.condition.isEquivalent(e.condition);\n    }\n  }, {\n    key: \"isConstant\",\n    value: function isConstant() {\n      return false;\n    }\n  }, {\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      return visitor.visitNotExpr(this, context);\n    }\n  }]);\n\n  return NotExpr;\n}(Expression);\n\nvar AssertNotNull = /*#__PURE__*/function (_Expression15) {\n  _inherits(AssertNotNull, _Expression15);\n\n  var _super19 = _createSuper(AssertNotNull);\n\n  function AssertNotNull(condition, sourceSpan) {\n    var _this20;\n\n    _classCallCheck(this, AssertNotNull);\n\n    _this20 = _super19.call(this, condition.type, sourceSpan);\n    _this20.condition = condition;\n    return _this20;\n  }\n\n  _createClass(AssertNotNull, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return e instanceof AssertNotNull && this.condition.isEquivalent(e.condition);\n    }\n  }, {\n    key: \"isConstant\",\n    value: function isConstant() {\n      return false;\n    }\n  }, {\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      return visitor.visitAssertNotNullExpr(this, context);\n    }\n  }]);\n\n  return AssertNotNull;\n}(Expression);\n\nvar CastExpr = /*#__PURE__*/function (_Expression16) {\n  _inherits(CastExpr, _Expression16);\n\n  var _super20 = _createSuper(CastExpr);\n\n  function CastExpr(value, type, sourceSpan) {\n    var _this21;\n\n    _classCallCheck(this, CastExpr);\n\n    _this21 = _super20.call(this, type, sourceSpan);\n    _this21.value = value;\n    return _this21;\n  }\n\n  _createClass(CastExpr, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return e instanceof CastExpr && this.value.isEquivalent(e.value);\n    }\n  }, {\n    key: \"isConstant\",\n    value: function isConstant() {\n      return false;\n    }\n  }, {\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      return visitor.visitCastExpr(this, context);\n    }\n  }]);\n\n  return CastExpr;\n}(Expression);\n\nvar FnParam = /*#__PURE__*/function () {\n  function FnParam(name) {\n    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    _classCallCheck(this, FnParam);\n\n    this.name = name;\n    this.type = type;\n  }\n\n  _createClass(FnParam, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(param) {\n      return this.name === param.name;\n    }\n  }]);\n\n  return FnParam;\n}();\n\nvar FunctionExpr = /*#__PURE__*/function (_Expression17) {\n  _inherits(FunctionExpr, _Expression17);\n\n  var _super21 = _createSuper(FunctionExpr);\n\n  function FunctionExpr(params, statements, type, sourceSpan, name) {\n    var _this22;\n\n    _classCallCheck(this, FunctionExpr);\n\n    _this22 = _super21.call(this, type, sourceSpan);\n    _this22.params = params;\n    _this22.statements = statements;\n    _this22.name = name;\n    return _this22;\n  }\n\n  _createClass(FunctionExpr, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return e instanceof FunctionExpr && areAllEquivalent(this.params, e.params) && areAllEquivalent(this.statements, e.statements);\n    }\n  }, {\n    key: \"isConstant\",\n    value: function isConstant() {\n      return false;\n    }\n  }, {\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      return visitor.visitFunctionExpr(this, context);\n    }\n  }, {\n    key: \"toDeclStmt\",\n    value: function toDeclStmt(name) {\n      var modifiers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return new DeclareFunctionStmt(name, this.params, this.statements, this.type, modifiers, this.sourceSpan);\n    }\n  }]);\n\n  return FunctionExpr;\n}(Expression);\n\nvar BinaryOperatorExpr = /*#__PURE__*/function (_Expression18) {\n  _inherits(BinaryOperatorExpr, _Expression18);\n\n  var _super22 = _createSuper(BinaryOperatorExpr);\n\n  function BinaryOperatorExpr(operator, lhs, rhs, type, sourceSpan) {\n    var _this23;\n\n    var parens = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : true;\n\n    _classCallCheck(this, BinaryOperatorExpr);\n\n    _this23 = _super22.call(this, type || lhs.type, sourceSpan);\n    _this23.operator = operator;\n    _this23.rhs = rhs;\n    _this23.parens = parens;\n    _this23.lhs = lhs;\n    return _this23;\n  }\n\n  _createClass(BinaryOperatorExpr, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return e instanceof BinaryOperatorExpr && this.operator === e.operator && this.lhs.isEquivalent(e.lhs) && this.rhs.isEquivalent(e.rhs);\n    }\n  }, {\n    key: \"isConstant\",\n    value: function isConstant() {\n      return false;\n    }\n  }, {\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      return visitor.visitBinaryOperatorExpr(this, context);\n    }\n  }]);\n\n  return BinaryOperatorExpr;\n}(Expression);\n\nvar ReadPropExpr = /*#__PURE__*/function (_Expression19) {\n  _inherits(ReadPropExpr, _Expression19);\n\n  var _super23 = _createSuper(ReadPropExpr);\n\n  function ReadPropExpr(receiver, name, type, sourceSpan) {\n    var _this24;\n\n    _classCallCheck(this, ReadPropExpr);\n\n    _this24 = _super23.call(this, type, sourceSpan);\n    _this24.receiver = receiver;\n    _this24.name = name;\n    return _this24;\n  }\n\n  _createClass(ReadPropExpr, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return e instanceof ReadPropExpr && this.receiver.isEquivalent(e.receiver) && this.name === e.name;\n    }\n  }, {\n    key: \"isConstant\",\n    value: function isConstant() {\n      return false;\n    }\n  }, {\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      return visitor.visitReadPropExpr(this, context);\n    }\n  }, {\n    key: \"set\",\n    value: function set(value) {\n      return new WritePropExpr(this.receiver, this.name, value, null, this.sourceSpan);\n    }\n  }]);\n\n  return ReadPropExpr;\n}(Expression);\n\nvar ReadKeyExpr = /*#__PURE__*/function (_Expression20) {\n  _inherits(ReadKeyExpr, _Expression20);\n\n  var _super24 = _createSuper(ReadKeyExpr);\n\n  function ReadKeyExpr(receiver, index, type, sourceSpan) {\n    var _this25;\n\n    _classCallCheck(this, ReadKeyExpr);\n\n    _this25 = _super24.call(this, type, sourceSpan);\n    _this25.receiver = receiver;\n    _this25.index = index;\n    return _this25;\n  }\n\n  _createClass(ReadKeyExpr, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return e instanceof ReadKeyExpr && this.receiver.isEquivalent(e.receiver) && this.index.isEquivalent(e.index);\n    }\n  }, {\n    key: \"isConstant\",\n    value: function isConstant() {\n      return false;\n    }\n  }, {\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      return visitor.visitReadKeyExpr(this, context);\n    }\n  }, {\n    key: \"set\",\n    value: function set(value) {\n      return new WriteKeyExpr(this.receiver, this.index, value, null, this.sourceSpan);\n    }\n  }]);\n\n  return ReadKeyExpr;\n}(Expression);\n\nvar LiteralArrayExpr = /*#__PURE__*/function (_Expression21) {\n  _inherits(LiteralArrayExpr, _Expression21);\n\n  var _super25 = _createSuper(LiteralArrayExpr);\n\n  function LiteralArrayExpr(entries, type, sourceSpan) {\n    var _this26;\n\n    _classCallCheck(this, LiteralArrayExpr);\n\n    _this26 = _super25.call(this, type, sourceSpan);\n    _this26.entries = entries;\n    return _this26;\n  }\n\n  _createClass(LiteralArrayExpr, [{\n    key: \"isConstant\",\n    value: function isConstant() {\n      return this.entries.every(function (e) {\n        return e.isConstant();\n      });\n    }\n  }, {\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return e instanceof LiteralArrayExpr && areAllEquivalent(this.entries, e.entries);\n    }\n  }, {\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      return visitor.visitLiteralArrayExpr(this, context);\n    }\n  }]);\n\n  return LiteralArrayExpr;\n}(Expression);\n\nvar LiteralMapEntry = /*#__PURE__*/function () {\n  function LiteralMapEntry(key, value, quoted) {\n    _classCallCheck(this, LiteralMapEntry);\n\n    this.key = key;\n    this.value = value;\n    this.quoted = quoted;\n  }\n\n  _createClass(LiteralMapEntry, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return this.key === e.key && this.value.isEquivalent(e.value);\n    }\n  }]);\n\n  return LiteralMapEntry;\n}();\n\nvar LiteralMapExpr = /*#__PURE__*/function (_Expression22) {\n  _inherits(LiteralMapExpr, _Expression22);\n\n  var _super26 = _createSuper(LiteralMapExpr);\n\n  function LiteralMapExpr(entries, type, sourceSpan) {\n    var _this27;\n\n    _classCallCheck(this, LiteralMapExpr);\n\n    _this27 = _super26.call(this, type, sourceSpan);\n    _this27.entries = entries;\n    _this27.valueType = null;\n\n    if (type) {\n      _this27.valueType = type.valueType;\n    }\n\n    return _this27;\n  }\n\n  _createClass(LiteralMapExpr, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return e instanceof LiteralMapExpr && areAllEquivalent(this.entries, e.entries);\n    }\n  }, {\n    key: \"isConstant\",\n    value: function isConstant() {\n      return this.entries.every(function (e) {\n        return e.value.isConstant();\n      });\n    }\n  }, {\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      return visitor.visitLiteralMapExpr(this, context);\n    }\n  }]);\n\n  return LiteralMapExpr;\n}(Expression);\n\nvar CommaExpr = /*#__PURE__*/function (_Expression23) {\n  _inherits(CommaExpr, _Expression23);\n\n  var _super27 = _createSuper(CommaExpr);\n\n  function CommaExpr(parts, sourceSpan) {\n    var _this28;\n\n    _classCallCheck(this, CommaExpr);\n\n    _this28 = _super27.call(this, parts[parts.length - 1].type, sourceSpan);\n    _this28.parts = parts;\n    return _this28;\n  }\n\n  _createClass(CommaExpr, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return e instanceof CommaExpr && areAllEquivalent(this.parts, e.parts);\n    }\n  }, {\n    key: \"isConstant\",\n    value: function isConstant() {\n      return false;\n    }\n  }, {\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      return visitor.visitCommaExpr(this, context);\n    }\n  }]);\n\n  return CommaExpr;\n}(Expression);\n\nvar THIS_EXPR = new ReadVarExpr(BuiltinVar.This, null, null);\nvar SUPER_EXPR = new ReadVarExpr(BuiltinVar.Super, null, null);\nvar CATCH_ERROR_VAR = new ReadVarExpr(BuiltinVar.CatchError, null, null);\nvar CATCH_STACK_VAR = new ReadVarExpr(BuiltinVar.CatchStack, null, null);\nvar NULL_EXPR = new LiteralExpr(null, null, null);\nvar TYPED_NULL_EXPR = new LiteralExpr(null, INFERRED_TYPE, null); //// Statements\n\nvar StmtModifier;\n\n(function (StmtModifier) {\n  StmtModifier[StmtModifier[\"Final\"] = 0] = \"Final\";\n  StmtModifier[StmtModifier[\"Private\"] = 1] = \"Private\";\n  StmtModifier[StmtModifier[\"Exported\"] = 2] = \"Exported\";\n  StmtModifier[StmtModifier[\"Static\"] = 3] = \"Static\";\n})(StmtModifier || (StmtModifier = {}));\n\nvar Statement = /*#__PURE__*/function () {\n  function Statement(modifiers, sourceSpan) {\n    _classCallCheck(this, Statement);\n\n    this.modifiers = modifiers || [];\n    this.sourceSpan = sourceSpan || null;\n  }\n\n  _createClass(Statement, [{\n    key: \"hasModifier\",\n    value: function hasModifier(modifier) {\n      return this.modifiers.indexOf(modifier) !== -1;\n    }\n  }]);\n\n  return Statement;\n}();\n\nvar DeclareVarStmt = /*#__PURE__*/function (_Statement) {\n  _inherits(DeclareVarStmt, _Statement);\n\n  var _super28 = _createSuper(DeclareVarStmt);\n\n  function DeclareVarStmt(name, value, type) {\n    var _this29;\n\n    var modifiers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    var sourceSpan = arguments.length > 4 ? arguments[4] : undefined;\n\n    _classCallCheck(this, DeclareVarStmt);\n\n    _this29 = _super28.call(this, modifiers, sourceSpan);\n    _this29.name = name;\n    _this29.value = value;\n    _this29.type = type || value && value.type || null;\n    return _this29;\n  }\n\n  _createClass(DeclareVarStmt, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(stmt) {\n      return stmt instanceof DeclareVarStmt && this.name === stmt.name && (this.value ? !!stmt.value && this.value.isEquivalent(stmt.value) : !stmt.value);\n    }\n  }, {\n    key: \"visitStatement\",\n    value: function visitStatement(visitor, context) {\n      return visitor.visitDeclareVarStmt(this, context);\n    }\n  }]);\n\n  return DeclareVarStmt;\n}(Statement);\n\nvar DeclareFunctionStmt = /*#__PURE__*/function (_Statement2) {\n  _inherits(DeclareFunctionStmt, _Statement2);\n\n  var _super29 = _createSuper(DeclareFunctionStmt);\n\n  function DeclareFunctionStmt(name, params, statements, type) {\n    var _this30;\n\n    var modifiers = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    var sourceSpan = arguments.length > 5 ? arguments[5] : undefined;\n\n    _classCallCheck(this, DeclareFunctionStmt);\n\n    _this30 = _super29.call(this, modifiers, sourceSpan);\n    _this30.name = name;\n    _this30.params = params;\n    _this30.statements = statements;\n    _this30.type = type || null;\n    return _this30;\n  }\n\n  _createClass(DeclareFunctionStmt, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(stmt) {\n      return stmt instanceof DeclareFunctionStmt && areAllEquivalent(this.params, stmt.params) && areAllEquivalent(this.statements, stmt.statements);\n    }\n  }, {\n    key: \"visitStatement\",\n    value: function visitStatement(visitor, context) {\n      return visitor.visitDeclareFunctionStmt(this, context);\n    }\n  }]);\n\n  return DeclareFunctionStmt;\n}(Statement);\n\nvar ExpressionStatement = /*#__PURE__*/function (_Statement3) {\n  _inherits(ExpressionStatement, _Statement3);\n\n  var _super30 = _createSuper(ExpressionStatement);\n\n  function ExpressionStatement(expr, sourceSpan) {\n    var _this31;\n\n    _classCallCheck(this, ExpressionStatement);\n\n    _this31 = _super30.call(this, null, sourceSpan);\n    _this31.expr = expr;\n    return _this31;\n  }\n\n  _createClass(ExpressionStatement, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(stmt) {\n      return stmt instanceof ExpressionStatement && this.expr.isEquivalent(stmt.expr);\n    }\n  }, {\n    key: \"visitStatement\",\n    value: function visitStatement(visitor, context) {\n      return visitor.visitExpressionStmt(this, context);\n    }\n  }]);\n\n  return ExpressionStatement;\n}(Statement);\n\nvar ReturnStatement = /*#__PURE__*/function (_Statement4) {\n  _inherits(ReturnStatement, _Statement4);\n\n  var _super31 = _createSuper(ReturnStatement);\n\n  function ReturnStatement(value, sourceSpan) {\n    var _this32;\n\n    _classCallCheck(this, ReturnStatement);\n\n    _this32 = _super31.call(this, null, sourceSpan);\n    _this32.value = value;\n    return _this32;\n  }\n\n  _createClass(ReturnStatement, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(stmt) {\n      return stmt instanceof ReturnStatement && this.value.isEquivalent(stmt.value);\n    }\n  }, {\n    key: \"visitStatement\",\n    value: function visitStatement(visitor, context) {\n      return visitor.visitReturnStmt(this, context);\n    }\n  }]);\n\n  return ReturnStatement;\n}(Statement);\n\nvar AbstractClassPart = /*#__PURE__*/function () {\n  function AbstractClassPart(type, modifiers) {\n    _classCallCheck(this, AbstractClassPart);\n\n    this.modifiers = modifiers;\n\n    if (!modifiers) {\n      this.modifiers = [];\n    }\n\n    this.type = type || null;\n  }\n\n  _createClass(AbstractClassPart, [{\n    key: \"hasModifier\",\n    value: function hasModifier(modifier) {\n      return this.modifiers.indexOf(modifier) !== -1;\n    }\n  }]);\n\n  return AbstractClassPart;\n}();\n\nvar ClassField = /*#__PURE__*/function (_AbstractClassPart) {\n  _inherits(ClassField, _AbstractClassPart);\n\n  var _super32 = _createSuper(ClassField);\n\n  function ClassField(name, type) {\n    var _this33;\n\n    var modifiers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    var initializer = arguments.length > 3 ? arguments[3] : undefined;\n\n    _classCallCheck(this, ClassField);\n\n    _this33 = _super32.call(this, type, modifiers);\n    _this33.name = name;\n    _this33.initializer = initializer;\n    return _this33;\n  }\n\n  _createClass(ClassField, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(f) {\n      return this.name === f.name;\n    }\n  }]);\n\n  return ClassField;\n}(AbstractClassPart);\n\nvar ClassMethod = /*#__PURE__*/function (_AbstractClassPart2) {\n  _inherits(ClassMethod, _AbstractClassPart2);\n\n  var _super33 = _createSuper(ClassMethod);\n\n  function ClassMethod(name, params, body, type) {\n    var _this34;\n\n    var modifiers = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n\n    _classCallCheck(this, ClassMethod);\n\n    _this34 = _super33.call(this, type, modifiers);\n    _this34.name = name;\n    _this34.params = params;\n    _this34.body = body;\n    return _this34;\n  }\n\n  _createClass(ClassMethod, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(m) {\n      return this.name === m.name && areAllEquivalent(this.body, m.body);\n    }\n  }]);\n\n  return ClassMethod;\n}(AbstractClassPart);\n\nvar ClassGetter = /*#__PURE__*/function (_AbstractClassPart3) {\n  _inherits(ClassGetter, _AbstractClassPart3);\n\n  var _super34 = _createSuper(ClassGetter);\n\n  function ClassGetter(name, body, type) {\n    var _this35;\n\n    var modifiers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n    _classCallCheck(this, ClassGetter);\n\n    _this35 = _super34.call(this, type, modifiers);\n    _this35.name = name;\n    _this35.body = body;\n    return _this35;\n  }\n\n  _createClass(ClassGetter, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(m) {\n      return this.name === m.name && areAllEquivalent(this.body, m.body);\n    }\n  }]);\n\n  return ClassGetter;\n}(AbstractClassPart);\n\nvar ClassStmt = /*#__PURE__*/function (_Statement5) {\n  _inherits(ClassStmt, _Statement5);\n\n  var _super35 = _createSuper(ClassStmt);\n\n  function ClassStmt(name, parent, fields, getters, constructorMethod, methods) {\n    var _this36;\n\n    var modifiers = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;\n    var sourceSpan = arguments.length > 7 ? arguments[7] : undefined;\n\n    _classCallCheck(this, ClassStmt);\n\n    _this36 = _super35.call(this, modifiers, sourceSpan);\n    _this36.name = name;\n    _this36.parent = parent;\n    _this36.fields = fields;\n    _this36.getters = getters;\n    _this36.constructorMethod = constructorMethod;\n    _this36.methods = methods;\n    return _this36;\n  }\n\n  _createClass(ClassStmt, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(stmt) {\n      return stmt instanceof ClassStmt && this.name === stmt.name && nullSafeIsEquivalent(this.parent, stmt.parent) && areAllEquivalent(this.fields, stmt.fields) && areAllEquivalent(this.getters, stmt.getters) && this.constructorMethod.isEquivalent(stmt.constructorMethod) && areAllEquivalent(this.methods, stmt.methods);\n    }\n  }, {\n    key: \"visitStatement\",\n    value: function visitStatement(visitor, context) {\n      return visitor.visitDeclareClassStmt(this, context);\n    }\n  }]);\n\n  return ClassStmt;\n}(Statement);\n\nvar IfStmt = /*#__PURE__*/function (_Statement6) {\n  _inherits(IfStmt, _Statement6);\n\n  var _super36 = _createSuper(IfStmt);\n\n  function IfStmt(condition, trueCase) {\n    var _this37;\n\n    var falseCase = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    var sourceSpan = arguments.length > 3 ? arguments[3] : undefined;\n\n    _classCallCheck(this, IfStmt);\n\n    _this37 = _super36.call(this, null, sourceSpan);\n    _this37.condition = condition;\n    _this37.trueCase = trueCase;\n    _this37.falseCase = falseCase;\n    return _this37;\n  }\n\n  _createClass(IfStmt, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(stmt) {\n      return stmt instanceof IfStmt && this.condition.isEquivalent(stmt.condition) && areAllEquivalent(this.trueCase, stmt.trueCase) && areAllEquivalent(this.falseCase, stmt.falseCase);\n    }\n  }, {\n    key: \"visitStatement\",\n    value: function visitStatement(visitor, context) {\n      return visitor.visitIfStmt(this, context);\n    }\n  }]);\n\n  return IfStmt;\n}(Statement);\n\nvar CommentStmt = /*#__PURE__*/function (_Statement7) {\n  _inherits(CommentStmt, _Statement7);\n\n  var _super37 = _createSuper(CommentStmt);\n\n  function CommentStmt(comment) {\n    var _this38;\n\n    var multiline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var sourceSpan = arguments.length > 2 ? arguments[2] : undefined;\n\n    _classCallCheck(this, CommentStmt);\n\n    _this38 = _super37.call(this, null, sourceSpan);\n    _this38.comment = comment;\n    _this38.multiline = multiline;\n    return _this38;\n  }\n\n  _createClass(CommentStmt, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(stmt) {\n      return stmt instanceof CommentStmt;\n    }\n  }, {\n    key: \"visitStatement\",\n    value: function visitStatement(visitor, context) {\n      return visitor.visitCommentStmt(this, context);\n    }\n  }]);\n\n  return CommentStmt;\n}(Statement);\n\nvar JSDocCommentStmt = /*#__PURE__*/function (_Statement8) {\n  _inherits(JSDocCommentStmt, _Statement8);\n\n  var _super38 = _createSuper(JSDocCommentStmt);\n\n  function JSDocCommentStmt() {\n    var _this39;\n\n    var tags = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var sourceSpan = arguments.length > 1 ? arguments[1] : undefined;\n\n    _classCallCheck(this, JSDocCommentStmt);\n\n    _this39 = _super38.call(this, null, sourceSpan);\n    _this39.tags = tags;\n    return _this39;\n  }\n\n  _createClass(JSDocCommentStmt, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(stmt) {\n      return stmt instanceof JSDocCommentStmt && this.toString() === stmt.toString();\n    }\n  }, {\n    key: \"visitStatement\",\n    value: function visitStatement(visitor, context) {\n      return visitor.visitJSDocCommentStmt(this, context);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return serializeTags(this.tags);\n    }\n  }]);\n\n  return JSDocCommentStmt;\n}(Statement);\n\nvar TryCatchStmt = /*#__PURE__*/function (_Statement9) {\n  _inherits(TryCatchStmt, _Statement9);\n\n  var _super39 = _createSuper(TryCatchStmt);\n\n  function TryCatchStmt(bodyStmts, catchStmts, sourceSpan) {\n    var _this40;\n\n    _classCallCheck(this, TryCatchStmt);\n\n    _this40 = _super39.call(this, null, sourceSpan);\n    _this40.bodyStmts = bodyStmts;\n    _this40.catchStmts = catchStmts;\n    return _this40;\n  }\n\n  _createClass(TryCatchStmt, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(stmt) {\n      return stmt instanceof TryCatchStmt && areAllEquivalent(this.bodyStmts, stmt.bodyStmts) && areAllEquivalent(this.catchStmts, stmt.catchStmts);\n    }\n  }, {\n    key: \"visitStatement\",\n    value: function visitStatement(visitor, context) {\n      return visitor.visitTryCatchStmt(this, context);\n    }\n  }]);\n\n  return TryCatchStmt;\n}(Statement);\n\nvar ThrowStmt = /*#__PURE__*/function (_Statement10) {\n  _inherits(ThrowStmt, _Statement10);\n\n  var _super40 = _createSuper(ThrowStmt);\n\n  function ThrowStmt(error, sourceSpan) {\n    var _this41;\n\n    _classCallCheck(this, ThrowStmt);\n\n    _this41 = _super40.call(this, null, sourceSpan);\n    _this41.error = error;\n    return _this41;\n  }\n\n  _createClass(ThrowStmt, [{\n    key: \"isEquivalent\",\n    value: function isEquivalent(stmt) {\n      return stmt instanceof TryCatchStmt && this.error.isEquivalent(stmt.error);\n    }\n  }, {\n    key: \"visitStatement\",\n    value: function visitStatement(visitor, context) {\n      return visitor.visitThrowStmt(this, context);\n    }\n  }]);\n\n  return ThrowStmt;\n}(Statement);\n\nvar AstTransformer = /*#__PURE__*/function () {\n  function AstTransformer() {\n    _classCallCheck(this, AstTransformer);\n  }\n\n  _createClass(AstTransformer, [{\n    key: \"transformExpr\",\n    value: function transformExpr(expr, context) {\n      return expr;\n    }\n  }, {\n    key: \"transformStmt\",\n    value: function transformStmt(stmt, context) {\n      return stmt;\n    }\n  }, {\n    key: \"visitReadVarExpr\",\n    value: function visitReadVarExpr(ast, context) {\n      return this.transformExpr(ast, context);\n    }\n  }, {\n    key: \"visitWrappedNodeExpr\",\n    value: function visitWrappedNodeExpr(ast, context) {\n      return this.transformExpr(ast, context);\n    }\n  }, {\n    key: \"visitTypeofExpr\",\n    value: function visitTypeofExpr(expr, context) {\n      return this.transformExpr(new TypeofExpr(expr.expr.visitExpression(this, context), expr.type, expr.sourceSpan), context);\n    }\n  }, {\n    key: \"visitWriteVarExpr\",\n    value: function visitWriteVarExpr(expr, context) {\n      return this.transformExpr(new WriteVarExpr(expr.name, expr.value.visitExpression(this, context), expr.type, expr.sourceSpan), context);\n    }\n  }, {\n    key: \"visitWriteKeyExpr\",\n    value: function visitWriteKeyExpr(expr, context) {\n      return this.transformExpr(new WriteKeyExpr(expr.receiver.visitExpression(this, context), expr.index.visitExpression(this, context), expr.value.visitExpression(this, context), expr.type, expr.sourceSpan), context);\n    }\n  }, {\n    key: \"visitWritePropExpr\",\n    value: function visitWritePropExpr(expr, context) {\n      return this.transformExpr(new WritePropExpr(expr.receiver.visitExpression(this, context), expr.name, expr.value.visitExpression(this, context), expr.type, expr.sourceSpan), context);\n    }\n  }, {\n    key: \"visitInvokeMethodExpr\",\n    value: function visitInvokeMethodExpr(ast, context) {\n      var method = ast.builtin || ast.name;\n      return this.transformExpr(new InvokeMethodExpr(ast.receiver.visitExpression(this, context), method, this.visitAllExpressions(ast.args, context), ast.type, ast.sourceSpan), context);\n    }\n  }, {\n    key: \"visitInvokeFunctionExpr\",\n    value: function visitInvokeFunctionExpr(ast, context) {\n      return this.transformExpr(new InvokeFunctionExpr(ast.fn.visitExpression(this, context), this.visitAllExpressions(ast.args, context), ast.type, ast.sourceSpan), context);\n    }\n  }, {\n    key: \"visitInstantiateExpr\",\n    value: function visitInstantiateExpr(ast, context) {\n      return this.transformExpr(new InstantiateExpr(ast.classExpr.visitExpression(this, context), this.visitAllExpressions(ast.args, context), ast.type, ast.sourceSpan), context);\n    }\n  }, {\n    key: \"visitLiteralExpr\",\n    value: function visitLiteralExpr(ast, context) {\n      return this.transformExpr(ast, context);\n    }\n  }, {\n    key: \"visitLocalizedString\",\n    value: function visitLocalizedString(ast, context) {\n      return this.transformExpr(new LocalizedString(ast.metaBlock, ast.messageParts, ast.placeHolderNames, this.visitAllExpressions(ast.expressions, context), ast.sourceSpan), context);\n    }\n  }, {\n    key: \"visitExternalExpr\",\n    value: function visitExternalExpr(ast, context) {\n      return this.transformExpr(ast, context);\n    }\n  }, {\n    key: \"visitConditionalExpr\",\n    value: function visitConditionalExpr(ast, context) {\n      return this.transformExpr(new ConditionalExpr(ast.condition.visitExpression(this, context), ast.trueCase.visitExpression(this, context), ast.falseCase.visitExpression(this, context), ast.type, ast.sourceSpan), context);\n    }\n  }, {\n    key: \"visitNotExpr\",\n    value: function visitNotExpr(ast, context) {\n      return this.transformExpr(new NotExpr(ast.condition.visitExpression(this, context), ast.sourceSpan), context);\n    }\n  }, {\n    key: \"visitAssertNotNullExpr\",\n    value: function visitAssertNotNullExpr(ast, context) {\n      return this.transformExpr(new AssertNotNull(ast.condition.visitExpression(this, context), ast.sourceSpan), context);\n    }\n  }, {\n    key: \"visitCastExpr\",\n    value: function visitCastExpr(ast, context) {\n      return this.transformExpr(new CastExpr(ast.value.visitExpression(this, context), ast.type, ast.sourceSpan), context);\n    }\n  }, {\n    key: \"visitFunctionExpr\",\n    value: function visitFunctionExpr(ast, context) {\n      return this.transformExpr(new FunctionExpr(ast.params, this.visitAllStatements(ast.statements, context), ast.type, ast.sourceSpan), context);\n    }\n  }, {\n    key: \"visitBinaryOperatorExpr\",\n    value: function visitBinaryOperatorExpr(ast, context) {\n      return this.transformExpr(new BinaryOperatorExpr(ast.operator, ast.lhs.visitExpression(this, context), ast.rhs.visitExpression(this, context), ast.type, ast.sourceSpan), context);\n    }\n  }, {\n    key: \"visitReadPropExpr\",\n    value: function visitReadPropExpr(ast, context) {\n      return this.transformExpr(new ReadPropExpr(ast.receiver.visitExpression(this, context), ast.name, ast.type, ast.sourceSpan), context);\n    }\n  }, {\n    key: \"visitReadKeyExpr\",\n    value: function visitReadKeyExpr(ast, context) {\n      return this.transformExpr(new ReadKeyExpr(ast.receiver.visitExpression(this, context), ast.index.visitExpression(this, context), ast.type, ast.sourceSpan), context);\n    }\n  }, {\n    key: \"visitLiteralArrayExpr\",\n    value: function visitLiteralArrayExpr(ast, context) {\n      return this.transformExpr(new LiteralArrayExpr(this.visitAllExpressions(ast.entries, context), ast.type, ast.sourceSpan), context);\n    }\n  }, {\n    key: \"visitLiteralMapExpr\",\n    value: function visitLiteralMapExpr(ast, context) {\n      var _this42 = this;\n\n      var entries = ast.entries.map(function (entry) {\n        return new LiteralMapEntry(entry.key, entry.value.visitExpression(_this42, context), entry.quoted);\n      });\n      var mapType = new MapType(ast.valueType, null);\n      return this.transformExpr(new LiteralMapExpr(entries, mapType, ast.sourceSpan), context);\n    }\n  }, {\n    key: \"visitCommaExpr\",\n    value: function visitCommaExpr(ast, context) {\n      return this.transformExpr(new CommaExpr(this.visitAllExpressions(ast.parts, context), ast.sourceSpan), context);\n    }\n  }, {\n    key: \"visitAllExpressions\",\n    value: function visitAllExpressions(exprs, context) {\n      var _this43 = this;\n\n      return exprs.map(function (expr) {\n        return expr.visitExpression(_this43, context);\n      });\n    }\n  }, {\n    key: \"visitDeclareVarStmt\",\n    value: function visitDeclareVarStmt(stmt, context) {\n      var value = stmt.value && stmt.value.visitExpression(this, context);\n      return this.transformStmt(new DeclareVarStmt(stmt.name, value, stmt.type, stmt.modifiers, stmt.sourceSpan), context);\n    }\n  }, {\n    key: \"visitDeclareFunctionStmt\",\n    value: function visitDeclareFunctionStmt(stmt, context) {\n      return this.transformStmt(new DeclareFunctionStmt(stmt.name, stmt.params, this.visitAllStatements(stmt.statements, context), stmt.type, stmt.modifiers, stmt.sourceSpan), context);\n    }\n  }, {\n    key: \"visitExpressionStmt\",\n    value: function visitExpressionStmt(stmt, context) {\n      return this.transformStmt(new ExpressionStatement(stmt.expr.visitExpression(this, context), stmt.sourceSpan), context);\n    }\n  }, {\n    key: \"visitReturnStmt\",\n    value: function visitReturnStmt(stmt, context) {\n      return this.transformStmt(new ReturnStatement(stmt.value.visitExpression(this, context), stmt.sourceSpan), context);\n    }\n  }, {\n    key: \"visitDeclareClassStmt\",\n    value: function visitDeclareClassStmt(stmt, context) {\n      var _this44 = this;\n\n      var parent = stmt.parent.visitExpression(this, context);\n      var getters = stmt.getters.map(function (getter) {\n        return new ClassGetter(getter.name, _this44.visitAllStatements(getter.body, context), getter.type, getter.modifiers);\n      });\n      var ctorMethod = stmt.constructorMethod && new ClassMethod(stmt.constructorMethod.name, stmt.constructorMethod.params, this.visitAllStatements(stmt.constructorMethod.body, context), stmt.constructorMethod.type, stmt.constructorMethod.modifiers);\n      var methods = stmt.methods.map(function (method) {\n        return new ClassMethod(method.name, method.params, _this44.visitAllStatements(method.body, context), method.type, method.modifiers);\n      });\n      return this.transformStmt(new ClassStmt(stmt.name, parent, stmt.fields, getters, ctorMethod, methods, stmt.modifiers, stmt.sourceSpan), context);\n    }\n  }, {\n    key: \"visitIfStmt\",\n    value: function visitIfStmt(stmt, context) {\n      return this.transformStmt(new IfStmt(stmt.condition.visitExpression(this, context), this.visitAllStatements(stmt.trueCase, context), this.visitAllStatements(stmt.falseCase, context), stmt.sourceSpan), context);\n    }\n  }, {\n    key: \"visitTryCatchStmt\",\n    value: function visitTryCatchStmt(stmt, context) {\n      return this.transformStmt(new TryCatchStmt(this.visitAllStatements(stmt.bodyStmts, context), this.visitAllStatements(stmt.catchStmts, context), stmt.sourceSpan), context);\n    }\n  }, {\n    key: \"visitThrowStmt\",\n    value: function visitThrowStmt(stmt, context) {\n      return this.transformStmt(new ThrowStmt(stmt.error.visitExpression(this, context), stmt.sourceSpan), context);\n    }\n  }, {\n    key: \"visitCommentStmt\",\n    value: function visitCommentStmt(stmt, context) {\n      return this.transformStmt(stmt, context);\n    }\n  }, {\n    key: \"visitJSDocCommentStmt\",\n    value: function visitJSDocCommentStmt(stmt, context) {\n      return this.transformStmt(stmt, context);\n    }\n  }, {\n    key: \"visitAllStatements\",\n    value: function visitAllStatements(stmts, context) {\n      var _this45 = this;\n\n      return stmts.map(function (stmt) {\n        return stmt.visitStatement(_this45, context);\n      });\n    }\n  }]);\n\n  return AstTransformer;\n}();\n\nvar RecursiveAstVisitor = /*#__PURE__*/function () {\n  function RecursiveAstVisitor() {\n    _classCallCheck(this, RecursiveAstVisitor);\n  }\n\n  _createClass(RecursiveAstVisitor, [{\n    key: \"visitType\",\n    value: function visitType(ast, context) {\n      return ast;\n    }\n  }, {\n    key: \"visitExpression\",\n    value: function visitExpression(ast, context) {\n      if (ast.type) {\n        ast.type.visitType(this, context);\n      }\n\n      return ast;\n    }\n  }, {\n    key: \"visitBuiltinType\",\n    value: function visitBuiltinType(type, context) {\n      return this.visitType(type, context);\n    }\n  }, {\n    key: \"visitExpressionType\",\n    value: function visitExpressionType(type, context) {\n      var _this46 = this;\n\n      type.value.visitExpression(this, context);\n\n      if (type.typeParams !== null) {\n        type.typeParams.forEach(function (param) {\n          return _this46.visitType(param, context);\n        });\n      }\n\n      return this.visitType(type, context);\n    }\n  }, {\n    key: \"visitArrayType\",\n    value: function visitArrayType(type, context) {\n      return this.visitType(type, context);\n    }\n  }, {\n    key: \"visitMapType\",\n    value: function visitMapType(type, context) {\n      return this.visitType(type, context);\n    }\n  }, {\n    key: \"visitWrappedNodeExpr\",\n    value: function visitWrappedNodeExpr(ast, context) {\n      return ast;\n    }\n  }, {\n    key: \"visitTypeofExpr\",\n    value: function visitTypeofExpr(ast, context) {\n      return this.visitExpression(ast, context);\n    }\n  }, {\n    key: \"visitReadVarExpr\",\n    value: function visitReadVarExpr(ast, context) {\n      return this.visitExpression(ast, context);\n    }\n  }, {\n    key: \"visitWriteVarExpr\",\n    value: function visitWriteVarExpr(ast, context) {\n      ast.value.visitExpression(this, context);\n      return this.visitExpression(ast, context);\n    }\n  }, {\n    key: \"visitWriteKeyExpr\",\n    value: function visitWriteKeyExpr(ast, context) {\n      ast.receiver.visitExpression(this, context);\n      ast.index.visitExpression(this, context);\n      ast.value.visitExpression(this, context);\n      return this.visitExpression(ast, context);\n    }\n  }, {\n    key: \"visitWritePropExpr\",\n    value: function visitWritePropExpr(ast, context) {\n      ast.receiver.visitExpression(this, context);\n      ast.value.visitExpression(this, context);\n      return this.visitExpression(ast, context);\n    }\n  }, {\n    key: \"visitInvokeMethodExpr\",\n    value: function visitInvokeMethodExpr(ast, context) {\n      ast.receiver.visitExpression(this, context);\n      this.visitAllExpressions(ast.args, context);\n      return this.visitExpression(ast, context);\n    }\n  }, {\n    key: \"visitInvokeFunctionExpr\",\n    value: function visitInvokeFunctionExpr(ast, context) {\n      ast.fn.visitExpression(this, context);\n      this.visitAllExpressions(ast.args, context);\n      return this.visitExpression(ast, context);\n    }\n  }, {\n    key: \"visitInstantiateExpr\",\n    value: function visitInstantiateExpr(ast, context) {\n      ast.classExpr.visitExpression(this, context);\n      this.visitAllExpressions(ast.args, context);\n      return this.visitExpression(ast, context);\n    }\n  }, {\n    key: \"visitLiteralExpr\",\n    value: function visitLiteralExpr(ast, context) {\n      return this.visitExpression(ast, context);\n    }\n  }, {\n    key: \"visitLocalizedString\",\n    value: function visitLocalizedString(ast, context) {\n      return this.visitExpression(ast, context);\n    }\n  }, {\n    key: \"visitExternalExpr\",\n    value: function visitExternalExpr(ast, context) {\n      var _this47 = this;\n\n      if (ast.typeParams) {\n        ast.typeParams.forEach(function (type) {\n          return type.visitType(_this47, context);\n        });\n      }\n\n      return this.visitExpression(ast, context);\n    }\n  }, {\n    key: \"visitConditionalExpr\",\n    value: function visitConditionalExpr(ast, context) {\n      ast.condition.visitExpression(this, context);\n      ast.trueCase.visitExpression(this, context);\n      ast.falseCase.visitExpression(this, context);\n      return this.visitExpression(ast, context);\n    }\n  }, {\n    key: \"visitNotExpr\",\n    value: function visitNotExpr(ast, context) {\n      ast.condition.visitExpression(this, context);\n      return this.visitExpression(ast, context);\n    }\n  }, {\n    key: \"visitAssertNotNullExpr\",\n    value: function visitAssertNotNullExpr(ast, context) {\n      ast.condition.visitExpression(this, context);\n      return this.visitExpression(ast, context);\n    }\n  }, {\n    key: \"visitCastExpr\",\n    value: function visitCastExpr(ast, context) {\n      ast.value.visitExpression(this, context);\n      return this.visitExpression(ast, context);\n    }\n  }, {\n    key: \"visitFunctionExpr\",\n    value: function visitFunctionExpr(ast, context) {\n      this.visitAllStatements(ast.statements, context);\n      return this.visitExpression(ast, context);\n    }\n  }, {\n    key: \"visitBinaryOperatorExpr\",\n    value: function visitBinaryOperatorExpr(ast, context) {\n      ast.lhs.visitExpression(this, context);\n      ast.rhs.visitExpression(this, context);\n      return this.visitExpression(ast, context);\n    }\n  }, {\n    key: \"visitReadPropExpr\",\n    value: function visitReadPropExpr(ast, context) {\n      ast.receiver.visitExpression(this, context);\n      return this.visitExpression(ast, context);\n    }\n  }, {\n    key: \"visitReadKeyExpr\",\n    value: function visitReadKeyExpr(ast, context) {\n      ast.receiver.visitExpression(this, context);\n      ast.index.visitExpression(this, context);\n      return this.visitExpression(ast, context);\n    }\n  }, {\n    key: \"visitLiteralArrayExpr\",\n    value: function visitLiteralArrayExpr(ast, context) {\n      this.visitAllExpressions(ast.entries, context);\n      return this.visitExpression(ast, context);\n    }\n  }, {\n    key: \"visitLiteralMapExpr\",\n    value: function visitLiteralMapExpr(ast, context) {\n      var _this48 = this;\n\n      ast.entries.forEach(function (entry) {\n        return entry.value.visitExpression(_this48, context);\n      });\n      return this.visitExpression(ast, context);\n    }\n  }, {\n    key: \"visitCommaExpr\",\n    value: function visitCommaExpr(ast, context) {\n      this.visitAllExpressions(ast.parts, context);\n      return this.visitExpression(ast, context);\n    }\n  }, {\n    key: \"visitAllExpressions\",\n    value: function visitAllExpressions(exprs, context) {\n      var _this49 = this;\n\n      exprs.forEach(function (expr) {\n        return expr.visitExpression(_this49, context);\n      });\n    }\n  }, {\n    key: \"visitDeclareVarStmt\",\n    value: function visitDeclareVarStmt(stmt, context) {\n      if (stmt.value) {\n        stmt.value.visitExpression(this, context);\n      }\n\n      if (stmt.type) {\n        stmt.type.visitType(this, context);\n      }\n\n      return stmt;\n    }\n  }, {\n    key: \"visitDeclareFunctionStmt\",\n    value: function visitDeclareFunctionStmt(stmt, context) {\n      this.visitAllStatements(stmt.statements, context);\n\n      if (stmt.type) {\n        stmt.type.visitType(this, context);\n      }\n\n      return stmt;\n    }\n  }, {\n    key: \"visitExpressionStmt\",\n    value: function visitExpressionStmt(stmt, context) {\n      stmt.expr.visitExpression(this, context);\n      return stmt;\n    }\n  }, {\n    key: \"visitReturnStmt\",\n    value: function visitReturnStmt(stmt, context) {\n      stmt.value.visitExpression(this, context);\n      return stmt;\n    }\n  }, {\n    key: \"visitDeclareClassStmt\",\n    value: function visitDeclareClassStmt(stmt, context) {\n      var _this50 = this;\n\n      stmt.parent.visitExpression(this, context);\n      stmt.getters.forEach(function (getter) {\n        return _this50.visitAllStatements(getter.body, context);\n      });\n\n      if (stmt.constructorMethod) {\n        this.visitAllStatements(stmt.constructorMethod.body, context);\n      }\n\n      stmt.methods.forEach(function (method) {\n        return _this50.visitAllStatements(method.body, context);\n      });\n      return stmt;\n    }\n  }, {\n    key: \"visitIfStmt\",\n    value: function visitIfStmt(stmt, context) {\n      stmt.condition.visitExpression(this, context);\n      this.visitAllStatements(stmt.trueCase, context);\n      this.visitAllStatements(stmt.falseCase, context);\n      return stmt;\n    }\n  }, {\n    key: \"visitTryCatchStmt\",\n    value: function visitTryCatchStmt(stmt, context) {\n      this.visitAllStatements(stmt.bodyStmts, context);\n      this.visitAllStatements(stmt.catchStmts, context);\n      return stmt;\n    }\n  }, {\n    key: \"visitThrowStmt\",\n    value: function visitThrowStmt(stmt, context) {\n      stmt.error.visitExpression(this, context);\n      return stmt;\n    }\n  }, {\n    key: \"visitCommentStmt\",\n    value: function visitCommentStmt(stmt, context) {\n      return stmt;\n    }\n  }, {\n    key: \"visitJSDocCommentStmt\",\n    value: function visitJSDocCommentStmt(stmt, context) {\n      return stmt;\n    }\n  }, {\n    key: \"visitAllStatements\",\n    value: function visitAllStatements(stmts, context) {\n      var _this51 = this;\n\n      stmts.forEach(function (stmt) {\n        return stmt.visitStatement(_this51, context);\n      });\n    }\n  }]);\n\n  return RecursiveAstVisitor;\n}();\n\nfunction findReadVarNames(stmts) {\n  var visitor = new _ReadVarVisitor();\n  visitor.visitAllStatements(stmts, null);\n  return visitor.varNames;\n}\n\nvar _ReadVarVisitor = /*#__PURE__*/function (_RecursiveAstVisitor) {\n  _inherits(_ReadVarVisitor, _RecursiveAstVisitor);\n\n  var _super41 = _createSuper(_ReadVarVisitor);\n\n  function _ReadVarVisitor() {\n    var _this52;\n\n    _classCallCheck(this, _ReadVarVisitor);\n\n    _this52 = _super41.apply(this, arguments);\n    _this52.varNames = new Set();\n    return _this52;\n  }\n\n  _createClass(_ReadVarVisitor, [{\n    key: \"visitDeclareFunctionStmt\",\n    value: function visitDeclareFunctionStmt(stmt, context) {\n      // Don't descend into nested functions\n      return stmt;\n    }\n  }, {\n    key: \"visitDeclareClassStmt\",\n    value: function visitDeclareClassStmt(stmt, context) {\n      // Don't descend into nested classes\n      return stmt;\n    }\n  }, {\n    key: \"visitReadVarExpr\",\n    value: function visitReadVarExpr(ast, context) {\n      if (ast.name) {\n        this.varNames.add(ast.name);\n      }\n\n      return null;\n    }\n  }]);\n\n  return _ReadVarVisitor;\n}(RecursiveAstVisitor);\n\nfunction collectExternalReferences(stmts) {\n  var visitor = new _FindExternalReferencesVisitor();\n  visitor.visitAllStatements(stmts, null);\n  return visitor.externalReferences;\n}\n\nvar _FindExternalReferencesVisitor = /*#__PURE__*/function (_RecursiveAstVisitor2) {\n  _inherits(_FindExternalReferencesVisitor, _RecursiveAstVisitor2);\n\n  var _super42 = _createSuper(_FindExternalReferencesVisitor);\n\n  function _FindExternalReferencesVisitor() {\n    var _this53;\n\n    _classCallCheck(this, _FindExternalReferencesVisitor);\n\n    _this53 = _super42.apply(this, arguments);\n    _this53.externalReferences = [];\n    return _this53;\n  }\n\n  _createClass(_FindExternalReferencesVisitor, [{\n    key: \"visitExternalExpr\",\n    value: function visitExternalExpr(e, context) {\n      this.externalReferences.push(e.value);\n      return _get(_getPrototypeOf(_FindExternalReferencesVisitor.prototype), \"visitExternalExpr\", this).call(this, e, context);\n    }\n  }]);\n\n  return _FindExternalReferencesVisitor;\n}(RecursiveAstVisitor);\n\nfunction applySourceSpanToStatementIfNeeded(stmt, sourceSpan) {\n  if (!sourceSpan) {\n    return stmt;\n  }\n\n  var transformer = new _ApplySourceSpanTransformer(sourceSpan);\n  return stmt.visitStatement(transformer, null);\n}\n\nfunction applySourceSpanToExpressionIfNeeded(expr, sourceSpan) {\n  if (!sourceSpan) {\n    return expr;\n  }\n\n  var transformer = new _ApplySourceSpanTransformer(sourceSpan);\n  return expr.visitExpression(transformer, null);\n}\n\nvar _ApplySourceSpanTransformer = /*#__PURE__*/function (_AstTransformer) {\n  _inherits(_ApplySourceSpanTransformer, _AstTransformer);\n\n  var _super43 = _createSuper(_ApplySourceSpanTransformer);\n\n  function _ApplySourceSpanTransformer(sourceSpan) {\n    var _this54;\n\n    _classCallCheck(this, _ApplySourceSpanTransformer);\n\n    _this54 = _super43.call(this);\n    _this54.sourceSpan = sourceSpan;\n    return _this54;\n  }\n\n  _createClass(_ApplySourceSpanTransformer, [{\n    key: \"_clone\",\n    value: function _clone(obj) {\n      var clone = Object.create(obj.constructor.prototype);\n\n      for (var _i4 = 0, _Object$keys = Object.keys(obj); _i4 < _Object$keys.length; _i4++) {\n        var prop = _Object$keys[_i4];\n        clone[prop] = obj[prop];\n      }\n\n      return clone;\n    }\n  }, {\n    key: \"transformExpr\",\n    value: function transformExpr(expr, context) {\n      if (!expr.sourceSpan) {\n        expr = this._clone(expr);\n        expr.sourceSpan = this.sourceSpan;\n      }\n\n      return expr;\n    }\n  }, {\n    key: \"transformStmt\",\n    value: function transformStmt(stmt, context) {\n      if (!stmt.sourceSpan) {\n        stmt = this._clone(stmt);\n        stmt.sourceSpan = this.sourceSpan;\n      }\n\n      return stmt;\n    }\n  }]);\n\n  return _ApplySourceSpanTransformer;\n}(AstTransformer);\n\nfunction variable(name, type, sourceSpan) {\n  return new ReadVarExpr(name, type, sourceSpan);\n}\n\nfunction importExpr(id) {\n  var typeParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var sourceSpan = arguments.length > 2 ? arguments[2] : undefined;\n  return new ExternalExpr(id, null, typeParams, sourceSpan);\n}\n\nfunction importType(id) {\n  var typeParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var typeModifiers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return id != null ? expressionType(importExpr(id, typeParams, null), typeModifiers) : null;\n}\n\nfunction expressionType(expr) {\n  var typeModifiers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var typeParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  return new ExpressionType(expr, typeModifiers, typeParams);\n}\n\nfunction typeofExpr(expr) {\n  return new TypeofExpr(expr);\n}\n\nfunction literalArr(values, type, sourceSpan) {\n  return new LiteralArrayExpr(values, type, sourceSpan);\n}\n\nfunction literalMap(values) {\n  var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  return new LiteralMapExpr(values.map(function (e) {\n    return new LiteralMapEntry(e.key, e.value, e.quoted);\n  }), type, null);\n}\n\nfunction not(expr, sourceSpan) {\n  return new NotExpr(expr, sourceSpan);\n}\n\nfunction assertNotNull(expr, sourceSpan) {\n  return new AssertNotNull(expr, sourceSpan);\n}\n\nfunction fn(params, body, type, sourceSpan, name) {\n  return new FunctionExpr(params, body, type, sourceSpan, name);\n}\n\nfunction ifStmt(condition, thenClause, elseClause) {\n  return new IfStmt(condition, thenClause, elseClause);\n}\n\nfunction literal(value, type, sourceSpan) {\n  return new LiteralExpr(value, type, sourceSpan);\n}\n\nfunction localizedString(metaBlock, messageParts, placeholderNames, expressions, sourceSpan) {\n  return new LocalizedString(metaBlock, messageParts, placeholderNames, expressions, sourceSpan);\n}\n\nfunction isNull(exp) {\n  return exp instanceof LiteralExpr && exp.value === null;\n}\n/*\n * Serializes a `Tag` into a string.\n * Returns a string like \" @foo {bar} baz\" (note the leading whitespace before `@foo`).\n */\n\n\nfunction tagToString(tag) {\n  var out = '';\n\n  if (tag.tagName) {\n    out += \" @\".concat(tag.tagName);\n  }\n\n  if (tag.text) {\n    if (tag.text.match(/\\/\\*|\\*\\//)) {\n      throw new Error('JSDoc text cannot contain \"/*\" and \"*/\"');\n    }\n\n    out += ' ' + tag.text.replace(/@/g, '\\\\@');\n  }\n\n  return out;\n}\n\nfunction serializeTags(tags) {\n  if (tags.length === 0) return '';\n  var out = '*\\n';\n\n  var _iterator = _createForOfIteratorHelper(tags),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var tag = _step.value;\n      out += ' *'; // If the tagToString is multi-line, insert \" * \" prefixes on subsequent lines.\n\n      out += tagToString(tag).replace(/\\n/g, '\\n * ');\n      out += '\\n';\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  out += ' ';\n  return out;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar DASH_CASE_REGEXP = /-+([a-z0-9])/g;\n\nfunction dashCaseToCamelCase(input) {\n  return input.replace(DASH_CASE_REGEXP, function () {\n    for (var _len = arguments.length, m = new Array(_len), _key = 0; _key < _len; _key++) {\n      m[_key] = arguments[_key];\n    }\n\n    return m[1].toUpperCase();\n  });\n}\n\nfunction splitAtColon(input, defaultValues) {\n  return _splitAt(input, ':', defaultValues);\n}\n\nfunction splitAtPeriod(input, defaultValues) {\n  return _splitAt(input, '.', defaultValues);\n}\n\nfunction _splitAt(input, character, defaultValues) {\n  var characterIndex = input.indexOf(character);\n  if (characterIndex == -1) return defaultValues;\n  return [input.slice(0, characterIndex).trim(), input.slice(characterIndex + 1).trim()];\n}\n\nfunction visitValue(value, visitor, context) {\n  if (Array.isArray(value)) {\n    return visitor.visitArray(value, context);\n  }\n\n  if (isStrictStringMap(value)) {\n    return visitor.visitStringMap(value, context);\n  }\n\n  if (value == null || typeof value == 'string' || typeof value == 'number' || typeof value == 'boolean') {\n    return visitor.visitPrimitive(value, context);\n  }\n\n  return visitor.visitOther(value, context);\n}\n\nfunction isDefined(val) {\n  return val !== null && val !== undefined;\n}\n\nfunction noUndefined(val) {\n  return val === undefined ? null : val;\n}\n\nvar ValueTransformer = /*#__PURE__*/function () {\n  function ValueTransformer() {\n    _classCallCheck(this, ValueTransformer);\n  }\n\n  _createClass(ValueTransformer, [{\n    key: \"visitArray\",\n    value: function visitArray(arr, context) {\n      var _this55 = this;\n\n      return arr.map(function (value) {\n        return visitValue(value, _this55, context);\n      });\n    }\n  }, {\n    key: \"visitStringMap\",\n    value: function visitStringMap(map, context) {\n      var _this56 = this;\n\n      var result = {};\n      Object.keys(map).forEach(function (key) {\n        result[key] = visitValue(map[key], _this56, context);\n      });\n      return result;\n    }\n  }, {\n    key: \"visitPrimitive\",\n    value: function visitPrimitive(value, context) {\n      return value;\n    }\n  }, {\n    key: \"visitOther\",\n    value: function visitOther(value, context) {\n      return value;\n    }\n  }]);\n\n  return ValueTransformer;\n}();\n\nvar SyncAsync = {\n  assertSync: function assertSync(value) {\n    if (isPromise(value)) {\n      throw new Error(\"Illegal state: value cannot be a promise\");\n    }\n\n    return value;\n  },\n  then: function then(value, cb) {\n    return isPromise(value) ? value.then(cb) : cb(value);\n  },\n  all: function all(syncAsyncValues) {\n    return syncAsyncValues.some(isPromise) ? Promise.all(syncAsyncValues) : syncAsyncValues;\n  }\n};\n\nfunction error(msg) {\n  throw new Error(\"Internal Error: \".concat(msg));\n}\n\nfunction syntaxError(msg, parseErrors) {\n  var error = Error(msg);\n  error[ERROR_SYNTAX_ERROR] = true;\n  if (parseErrors) error[ERROR_PARSE_ERRORS] = parseErrors;\n  return error;\n}\n\nvar ERROR_SYNTAX_ERROR = 'ngSyntaxError';\nvar ERROR_PARSE_ERRORS = 'ngParseErrors';\n\nfunction isSyntaxError(error) {\n  return error[ERROR_SYNTAX_ERROR];\n}\n\nfunction getParseErrors(error) {\n  return error[ERROR_PARSE_ERRORS] || [];\n} // Escape characters that have a special meaning in Regular Expressions\n\n\nfunction escapeRegExp(s) {\n  return s.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, '\\\\$1');\n}\n\nvar STRING_MAP_PROTO = Object.getPrototypeOf({});\n\nfunction isStrictStringMap(obj) {\n  return typeof obj === 'object' && obj !== null && Object.getPrototypeOf(obj) === STRING_MAP_PROTO;\n}\n\nfunction utf8Encode(str) {\n  var encoded = '';\n\n  for (var index = 0; index < str.length; index++) {\n    var codePoint = str.charCodeAt(index); // decode surrogate\n    // see https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\n    if (codePoint >= 0xd800 && codePoint <= 0xdbff && str.length > index + 1) {\n      var low = str.charCodeAt(index + 1);\n\n      if (low >= 0xdc00 && low <= 0xdfff) {\n        index++;\n        codePoint = (codePoint - 0xd800 << 10) + low - 0xdc00 + 0x10000;\n      }\n    }\n\n    if (codePoint <= 0x7f) {\n      encoded += String.fromCharCode(codePoint);\n    } else if (codePoint <= 0x7ff) {\n      encoded += String.fromCharCode(codePoint >> 6 & 0x1F | 0xc0, codePoint & 0x3f | 0x80);\n    } else if (codePoint <= 0xffff) {\n      encoded += String.fromCharCode(codePoint >> 12 | 0xe0, codePoint >> 6 & 0x3f | 0x80, codePoint & 0x3f | 0x80);\n    } else if (codePoint <= 0x1fffff) {\n      encoded += String.fromCharCode(codePoint >> 18 & 0x07 | 0xf0, codePoint >> 12 & 0x3f | 0x80, codePoint >> 6 & 0x3f | 0x80, codePoint & 0x3f | 0x80);\n    }\n  }\n\n  return encoded;\n}\n\nfunction stringify(token) {\n  if (typeof token === 'string') {\n    return token;\n  }\n\n  if (Array.isArray(token)) {\n    return '[' + token.map(stringify).join(', ') + ']';\n  }\n\n  if (token == null) {\n    return '' + token;\n  }\n\n  if (token.overriddenName) {\n    return \"\".concat(token.overriddenName);\n  }\n\n  if (token.name) {\n    return \"\".concat(token.name);\n  }\n\n  if (!token.toString) {\n    return 'object';\n  } // WARNING: do not try to `JSON.stringify(token)` here\n  // see https://github.com/angular/angular/issues/23440\n\n\n  var res = token.toString();\n\n  if (res == null) {\n    return '' + res;\n  }\n\n  var newLineIndex = res.indexOf('\\n');\n  return newLineIndex === -1 ? res : res.substring(0, newLineIndex);\n}\n/**\n * Lazily retrieves the reference value from a forwardRef.\n */\n\n\nfunction resolveForwardRef(type) {\n  if (typeof type === 'function' && type.hasOwnProperty('__forward_ref__')) {\n    return type();\n  } else {\n    return type;\n  }\n}\n/**\n * Determine if the argument is shaped like a Promise\n */\n\n\nfunction isPromise(obj) {\n  // allow any Promise/A+ compliant thenable.\n  // It's up to the caller to ensure that obj.then conforms to the spec\n  return !!obj && typeof obj.then === 'function';\n}\n\nvar Version = function Version(full) {\n  _classCallCheck(this, Version);\n\n  this.full = full;\n  var splits = full.split('.');\n  this.major = splits[0];\n  this.minor = splits[1];\n  this.patch = splits.slice(2).join('.');\n};\n\nvar __window = typeof window !== 'undefined' && window;\n\nvar __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope && self;\n\nvar __global = typeof global !== 'undefined' && global; // Check __global first, because in Node tests both __global and __window may be defined and _global\n// should be __global in that case.\n\n\nvar _global = __global || __window || __self;\n\nfunction newArray(size, value) {\n  var list = [];\n\n  for (var i = 0; i < size; i++) {\n    list.push(value);\n  }\n\n  return list;\n}\n/**\n * Partitions a given array into 2 arrays, based on a boolean value returned by the condition\n * function.\n *\n * @param arr Input array that should be partitioned\n * @param conditionFn Condition function that is called for each item in a given array and returns a\n * boolean value.\n */\n\n\nfunction partitionArray(arr, conditionFn) {\n  var truthy = [];\n  var falsy = [];\n  arr.forEach(function (item) {\n    (conditionFn(item) ? truthy : falsy).push(item);\n  });\n  return [truthy, falsy];\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar CONSTANT_PREFIX = '_c';\n/**\n * `ConstantPool` tries to reuse literal factories when two or more literals are identical.\n * We determine whether literals are identical by creating a key out of their AST using the\n * `KeyVisitor`. This constant is used to replace dynamic expressions which can't be safely\n * converted into a key. E.g. given an expression `{foo: bar()}`, since we don't know what\n * the result of `bar` will be, we create a key that looks like `{foo: <unknown>}`. Note\n * that we use a variable, rather than something like `null` in order to avoid collisions.\n */\n\nvar UNKNOWN_VALUE_KEY = variable('<unknown>');\n/**\n * Context to use when producing a key.\n *\n * This ensures we see the constant not the reference variable when producing\n * a key.\n */\n\nvar KEY_CONTEXT = {};\n/**\n * A node that is a place-holder that allows the node to be replaced when the actual\n * node is known.\n *\n * This allows the constant pool to change an expression from a direct reference to\n * a constant to a shared constant. It returns a fix-up node that is later allowed to\n * change the referenced expression.\n */\n\nvar FixupExpression = /*#__PURE__*/function (_Expression24) {\n  _inherits(FixupExpression, _Expression24);\n\n  var _super44 = _createSuper(FixupExpression);\n\n  function FixupExpression(resolved) {\n    var _this57;\n\n    _classCallCheck(this, FixupExpression);\n\n    _this57 = _super44.call(this, resolved.type);\n    _this57.resolved = resolved;\n    _this57.original = resolved;\n    return _this57;\n  }\n\n  _createClass(FixupExpression, [{\n    key: \"visitExpression\",\n    value: function visitExpression(visitor, context) {\n      if (context === KEY_CONTEXT) {\n        // When producing a key we want to traverse the constant not the\n        // variable used to refer to it.\n        return this.original.visitExpression(visitor, context);\n      } else {\n        return this.resolved.visitExpression(visitor, context);\n      }\n    }\n  }, {\n    key: \"isEquivalent\",\n    value: function isEquivalent(e) {\n      return e instanceof FixupExpression && this.resolved.isEquivalent(e.resolved);\n    }\n  }, {\n    key: \"isConstant\",\n    value: function isConstant() {\n      return true;\n    }\n  }, {\n    key: \"fixup\",\n    value: function fixup(expression) {\n      this.resolved = expression;\n      this.shared = true;\n    }\n  }]);\n\n  return FixupExpression;\n}(Expression);\n/**\n * A constant pool allows a code emitter to share constant in an output context.\n *\n * The constant pool also supports sharing access to ivy definitions references.\n */\n\n\nvar ConstantPool = /*#__PURE__*/function () {\n  function ConstantPool() {\n    _classCallCheck(this, ConstantPool);\n\n    this.statements = [];\n    this.literals = new Map();\n    this.literalFactories = new Map();\n    this.injectorDefinitions = new Map();\n    this.directiveDefinitions = new Map();\n    this.componentDefinitions = new Map();\n    this.pipeDefinitions = new Map();\n    this.nextNameIndex = 0;\n  }\n\n  _createClass(ConstantPool, [{\n    key: \"getConstLiteral\",\n    value: function getConstLiteral(literal, forceShared) {\n      if (literal instanceof LiteralExpr || literal instanceof FixupExpression) {\n        // Do no put simple literals into the constant pool or try to produce a constant for a\n        // reference to a constant.\n        return literal;\n      }\n\n      var key = this.keyOf(literal);\n      var fixup = this.literals.get(key);\n      var newValue = false;\n\n      if (!fixup) {\n        fixup = new FixupExpression(literal);\n        this.literals.set(key, fixup);\n        newValue = true;\n      }\n\n      if (!newValue && !fixup.shared || newValue && forceShared) {\n        // Replace the expression with a variable\n        var name = this.freshName();\n        this.statements.push(variable(name).set(literal).toDeclStmt(INFERRED_TYPE, [StmtModifier.Final]));\n        fixup.fixup(variable(name));\n      }\n\n      return fixup;\n    }\n  }, {\n    key: \"getDefinition\",\n    value: function getDefinition(type, kind, ctx) {\n      var forceShared = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var definitions = this.definitionsOf(kind);\n      var fixup = definitions.get(type);\n      var newValue = false;\n\n      if (!fixup) {\n        var property = this.propertyNameOf(kind);\n        fixup = new FixupExpression(ctx.importExpr(type).prop(property));\n        definitions.set(type, fixup);\n        newValue = true;\n      }\n\n      if (!newValue && !fixup.shared || newValue && forceShared) {\n        var name = this.freshName();\n        this.statements.push(variable(name).set(fixup.resolved).toDeclStmt(INFERRED_TYPE, [StmtModifier.Final]));\n        fixup.fixup(variable(name));\n      }\n\n      return fixup;\n    }\n  }, {\n    key: \"getLiteralFactory\",\n    value: function getLiteralFactory(literal) {\n      // Create a pure function that builds an array of a mix of constant and variable expressions\n      if (literal instanceof LiteralArrayExpr) {\n        var argumentsForKey = literal.entries.map(function (e) {\n          return e.isConstant() ? e : UNKNOWN_VALUE_KEY;\n        });\n        var key = this.keyOf(literalArr(argumentsForKey));\n        return this._getLiteralFactory(key, literal.entries, function (entries) {\n          return literalArr(entries);\n        });\n      } else {\n        var expressionForKey = literalMap(literal.entries.map(function (e) {\n          return {\n            key: e.key,\n            value: e.value.isConstant() ? e.value : UNKNOWN_VALUE_KEY,\n            quoted: e.quoted\n          };\n        }));\n\n        var _key2 = this.keyOf(expressionForKey);\n\n        return this._getLiteralFactory(_key2, literal.entries.map(function (e) {\n          return e.value;\n        }), function (entries) {\n          return literalMap(entries.map(function (value, index) {\n            return {\n              key: literal.entries[index].key,\n              value: value,\n              quoted: literal.entries[index].quoted\n            };\n          }));\n        });\n      }\n    }\n  }, {\n    key: \"_getLiteralFactory\",\n    value: function _getLiteralFactory(key, values, resultMap) {\n      var _this58 = this;\n\n      var literalFactory = this.literalFactories.get(key);\n      var literalFactoryArguments = values.filter(function (e) {\n        return !e.isConstant();\n      });\n\n      if (!literalFactory) {\n        var resultExpressions = values.map(function (e, index) {\n          return e.isConstant() ? _this58.getConstLiteral(e, true) : variable(\"a\".concat(index));\n        });\n        var parameters = resultExpressions.filter(isVariable).map(function (e) {\n          return new FnParam(e.name, DYNAMIC_TYPE);\n        });\n        var pureFunctionDeclaration = fn(parameters, [new ReturnStatement(resultMap(resultExpressions))], INFERRED_TYPE);\n        var name = this.freshName();\n        this.statements.push(variable(name).set(pureFunctionDeclaration).toDeclStmt(INFERRED_TYPE, [StmtModifier.Final]));\n        literalFactory = variable(name);\n        this.literalFactories.set(key, literalFactory);\n      }\n\n      return {\n        literalFactory: literalFactory,\n        literalFactoryArguments: literalFactoryArguments\n      };\n    }\n    /**\n     * Produce a unique name.\n     *\n     * The name might be unique among different prefixes if any of the prefixes end in\n     * a digit so the prefix should be a constant string (not based on user input) and\n     * must not end in a digit.\n     */\n\n  }, {\n    key: \"uniqueName\",\n    value: function uniqueName(prefix) {\n      return \"\".concat(prefix).concat(this.nextNameIndex++);\n    }\n  }, {\n    key: \"definitionsOf\",\n    value: function definitionsOf(kind) {\n      switch (kind) {\n        case 2\n        /* Component */\n        :\n          return this.componentDefinitions;\n\n        case 1\n        /* Directive */\n        :\n          return this.directiveDefinitions;\n\n        case 0\n        /* Injector */\n        :\n          return this.injectorDefinitions;\n\n        case 3\n        /* Pipe */\n        :\n          return this.pipeDefinitions;\n      }\n\n      error(\"Unknown definition kind \".concat(kind));\n      return this.componentDefinitions;\n    }\n  }, {\n    key: \"propertyNameOf\",\n    value: function propertyNameOf(kind) {\n      switch (kind) {\n        case 2\n        /* Component */\n        :\n          return 'ɵcmp';\n\n        case 1\n        /* Directive */\n        :\n          return 'ɵdir';\n\n        case 0\n        /* Injector */\n        :\n          return 'ɵinj';\n\n        case 3\n        /* Pipe */\n        :\n          return 'ɵpipe';\n      }\n\n      error(\"Unknown definition kind \".concat(kind));\n      return '<unknown>';\n    }\n  }, {\n    key: \"freshName\",\n    value: function freshName() {\n      return this.uniqueName(CONSTANT_PREFIX);\n    }\n  }, {\n    key: \"keyOf\",\n    value: function keyOf(expression) {\n      return expression.visitExpression(new KeyVisitor(), KEY_CONTEXT);\n    }\n  }]);\n\n  return ConstantPool;\n}();\n/**\n * Visitor used to determine if 2 expressions are equivalent and can be shared in the\n * `ConstantPool`.\n *\n * When the id (string) generated by the visitor is equal, expressions are considered equivalent.\n */\n\n\nvar KeyVisitor = /*#__PURE__*/function () {\n  function KeyVisitor() {\n    _classCallCheck(this, KeyVisitor);\n\n    this.visitWrappedNodeExpr = invalid;\n    this.visitWriteVarExpr = invalid;\n    this.visitWriteKeyExpr = invalid;\n    this.visitWritePropExpr = invalid;\n    this.visitInvokeMethodExpr = invalid;\n    this.visitInvokeFunctionExpr = invalid;\n    this.visitInstantiateExpr = invalid;\n    this.visitConditionalExpr = invalid;\n    this.visitNotExpr = invalid;\n    this.visitAssertNotNullExpr = invalid;\n    this.visitCastExpr = invalid;\n    this.visitFunctionExpr = invalid;\n    this.visitBinaryOperatorExpr = invalid;\n    this.visitReadPropExpr = invalid;\n    this.visitReadKeyExpr = invalid;\n    this.visitCommaExpr = invalid;\n    this.visitLocalizedString = invalid;\n  }\n\n  _createClass(KeyVisitor, [{\n    key: \"visitLiteralExpr\",\n    value: function visitLiteralExpr(ast) {\n      return \"\".concat(typeof ast.value === 'string' ? '\"' + ast.value + '\"' : ast.value);\n    }\n  }, {\n    key: \"visitLiteralArrayExpr\",\n    value: function visitLiteralArrayExpr(ast, context) {\n      var _this59 = this;\n\n      return \"[\".concat(ast.entries.map(function (entry) {\n        return entry.visitExpression(_this59, context);\n      }).join(','), \"]\");\n    }\n  }, {\n    key: \"visitLiteralMapExpr\",\n    value: function visitLiteralMapExpr(ast, context) {\n      var _this60 = this;\n\n      var mapKey = function mapKey(entry) {\n        var quote = entry.quoted ? '\"' : '';\n        return \"\".concat(quote).concat(entry.key).concat(quote);\n      };\n\n      var mapEntry = function mapEntry(entry) {\n        return \"\".concat(mapKey(entry), \":\").concat(entry.value.visitExpression(_this60, context));\n      };\n\n      return \"{\".concat(ast.entries.map(mapEntry).join(','));\n    }\n  }, {\n    key: \"visitExternalExpr\",\n    value: function visitExternalExpr(ast) {\n      return ast.value.moduleName ? \"EX:\".concat(ast.value.moduleName, \":\").concat(ast.value.name) : \"EX:\".concat(ast.value.runtime.name);\n    }\n  }, {\n    key: \"visitReadVarExpr\",\n    value: function visitReadVarExpr(node) {\n      return \"VAR:\".concat(node.name);\n    }\n  }, {\n    key: \"visitTypeofExpr\",\n    value: function visitTypeofExpr(node, context) {\n      return \"TYPEOF:\".concat(node.expr.visitExpression(this, context));\n    }\n  }]);\n\n  return KeyVisitor;\n}();\n\nfunction invalid(arg) {\n  throw new Error(\"Invalid state: Visitor \".concat(this.constructor.name, \" doesn't handle \").concat(arg.constructor.name));\n}\n\nfunction isVariable(e) {\n  return e instanceof ReadVarExpr;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar CORE = '@angular/core';\n\nvar Identifiers = function Identifiers() {\n  _classCallCheck(this, Identifiers);\n};\n\nIdentifiers.ANALYZE_FOR_ENTRY_COMPONENTS = {\n  name: 'ANALYZE_FOR_ENTRY_COMPONENTS',\n  moduleName: CORE\n};\nIdentifiers.ElementRef = {\n  name: 'ElementRef',\n  moduleName: CORE\n};\nIdentifiers.NgModuleRef = {\n  name: 'NgModuleRef',\n  moduleName: CORE\n};\nIdentifiers.ViewContainerRef = {\n  name: 'ViewContainerRef',\n  moduleName: CORE\n};\nIdentifiers.ChangeDetectorRef = {\n  name: 'ChangeDetectorRef',\n  moduleName: CORE\n};\nIdentifiers.QueryList = {\n  name: 'QueryList',\n  moduleName: CORE\n};\nIdentifiers.TemplateRef = {\n  name: 'TemplateRef',\n  moduleName: CORE\n};\nIdentifiers.Renderer2 = {\n  name: 'Renderer2',\n  moduleName: CORE\n};\nIdentifiers.CodegenComponentFactoryResolver = {\n  name: 'ɵCodegenComponentFactoryResolver',\n  moduleName: CORE\n};\nIdentifiers.ComponentFactoryResolver = {\n  name: 'ComponentFactoryResolver',\n  moduleName: CORE\n};\nIdentifiers.ComponentFactory = {\n  name: 'ComponentFactory',\n  moduleName: CORE\n};\nIdentifiers.ComponentRef = {\n  name: 'ComponentRef',\n  moduleName: CORE\n};\nIdentifiers.NgModuleFactory = {\n  name: 'NgModuleFactory',\n  moduleName: CORE\n};\nIdentifiers.createModuleFactory = {\n  name: 'ɵcmf',\n  moduleName: CORE\n};\nIdentifiers.moduleDef = {\n  name: 'ɵmod',\n  moduleName: CORE\n};\nIdentifiers.moduleProviderDef = {\n  name: 'ɵmpd',\n  moduleName: CORE\n};\nIdentifiers.RegisterModuleFactoryFn = {\n  name: 'ɵregisterModuleFactory',\n  moduleName: CORE\n};\nIdentifiers.inject = {\n  name: 'ɵɵinject',\n  moduleName: CORE\n};\nIdentifiers.directiveInject = {\n  name: 'ɵɵdirectiveInject',\n  moduleName: CORE\n};\nIdentifiers.INJECTOR = {\n  name: 'INJECTOR',\n  moduleName: CORE\n};\nIdentifiers.Injector = {\n  name: 'Injector',\n  moduleName: CORE\n};\nIdentifiers.ɵɵdefineInjectable = {\n  name: 'ɵɵdefineInjectable',\n  moduleName: CORE\n};\nIdentifiers.InjectableDef = {\n  name: 'ɵɵInjectableDef',\n  moduleName: CORE\n};\nIdentifiers.ViewEncapsulation = {\n  name: 'ViewEncapsulation',\n  moduleName: CORE\n};\nIdentifiers.ChangeDetectionStrategy = {\n  name: 'ChangeDetectionStrategy',\n  moduleName: CORE\n};\nIdentifiers.SecurityContext = {\n  name: 'SecurityContext',\n  moduleName: CORE\n};\nIdentifiers.LOCALE_ID = {\n  name: 'LOCALE_ID',\n  moduleName: CORE\n};\nIdentifiers.TRANSLATIONS_FORMAT = {\n  name: 'TRANSLATIONS_FORMAT',\n  moduleName: CORE\n};\nIdentifiers.inlineInterpolate = {\n  name: 'ɵinlineInterpolate',\n  moduleName: CORE\n};\nIdentifiers.interpolate = {\n  name: 'ɵinterpolate',\n  moduleName: CORE\n};\nIdentifiers.EMPTY_ARRAY = {\n  name: 'ɵEMPTY_ARRAY',\n  moduleName: CORE\n};\nIdentifiers.EMPTY_MAP = {\n  name: 'ɵEMPTY_MAP',\n  moduleName: CORE\n};\nIdentifiers.Renderer = {\n  name: 'Renderer',\n  moduleName: CORE\n};\nIdentifiers.viewDef = {\n  name: 'ɵvid',\n  moduleName: CORE\n};\nIdentifiers.elementDef = {\n  name: 'ɵeld',\n  moduleName: CORE\n};\nIdentifiers.anchorDef = {\n  name: 'ɵand',\n  moduleName: CORE\n};\nIdentifiers.textDef = {\n  name: 'ɵted',\n  moduleName: CORE\n};\nIdentifiers.directiveDef = {\n  name: 'ɵdid',\n  moduleName: CORE\n};\nIdentifiers.providerDef = {\n  name: 'ɵprd',\n  moduleName: CORE\n};\nIdentifiers.queryDef = {\n  name: 'ɵqud',\n  moduleName: CORE\n};\nIdentifiers.pureArrayDef = {\n  name: 'ɵpad',\n  moduleName: CORE\n};\nIdentifiers.pureObjectDef = {\n  name: 'ɵpod',\n  moduleName: CORE\n};\nIdentifiers.purePipeDef = {\n  name: 'ɵppd',\n  moduleName: CORE\n};\nIdentifiers.pipeDef = {\n  name: 'ɵpid',\n  moduleName: CORE\n};\nIdentifiers.nodeValue = {\n  name: 'ɵnov',\n  moduleName: CORE\n};\nIdentifiers.ngContentDef = {\n  name: 'ɵncd',\n  moduleName: CORE\n};\nIdentifiers.unwrapValue = {\n  name: 'ɵunv',\n  moduleName: CORE\n};\nIdentifiers.createRendererType2 = {\n  name: 'ɵcrt',\n  moduleName: CORE\n}; // type only\n\nIdentifiers.RendererType2 = {\n  name: 'RendererType2',\n  moduleName: CORE\n}; // type only\n\nIdentifiers.ViewDefinition = {\n  name: 'ɵViewDefinition',\n  moduleName: CORE\n};\nIdentifiers.createComponentFactory = {\n  name: 'ɵccf',\n  moduleName: CORE\n};\nIdentifiers.setClassMetadata = {\n  name: 'ɵsetClassMetadata',\n  moduleName: CORE\n};\n\nfunction createTokenForReference(reference) {\n  return {\n    identifier: {\n      reference: reference\n    }\n  };\n}\n\nfunction createTokenForExternalReference(reflector, reference) {\n  return createTokenForReference(reflector.resolveExternalReference(reference));\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * A token representing the a reference to a static type.\n *\n * This token is unique for a filePath and name and can be used as a hash table key.\n */\n\n\nvar StaticSymbol = /*#__PURE__*/function () {\n  function StaticSymbol(filePath, name, members) {\n    _classCallCheck(this, StaticSymbol);\n\n    this.filePath = filePath;\n    this.name = name;\n    this.members = members;\n  }\n\n  _createClass(StaticSymbol, [{\n    key: \"assertNoMembers\",\n    value: function assertNoMembers() {\n      if (this.members.length) {\n        throw new Error(\"Illegal state: symbol without members expected, but got \".concat(JSON.stringify(this), \".\"));\n      }\n    }\n  }]);\n\n  return StaticSymbol;\n}();\n/**\n * A cache of static symbol used by the StaticReflector to return the same symbol for the\n * same symbol values.\n */\n\n\nvar StaticSymbolCache = /*#__PURE__*/function () {\n  function StaticSymbolCache() {\n    _classCallCheck(this, StaticSymbolCache);\n\n    this.cache = new Map();\n  }\n\n  _createClass(StaticSymbolCache, [{\n    key: \"get\",\n    value: function get(declarationFile, name, members) {\n      members = members || [];\n      var memberSuffix = members.length ? \".\".concat(members.join('.')) : '';\n      var key = \"\\\"\".concat(declarationFile, \"\\\".\").concat(name).concat(memberSuffix);\n      var result = this.cache.get(key);\n\n      if (!result) {\n        result = new StaticSymbol(declarationFile, name, members);\n        this.cache.set(key, result);\n      }\n\n      return result;\n    }\n  }]);\n\n  return StaticSymbolCache;\n}();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// group 0: \"[prop] or (event) or @trigger\"\n// group 1: \"prop\" from \"[prop]\"\n// group 2: \"event\" from \"(event)\"\n// group 3: \"@trigger\" from \"@trigger\"\n\n\nvar HOST_REG_EXP = /^(?:(?:\\[([^\\]]+)\\])|(?:\\(([^\\)]+)\\)))|(\\@[-\\w]+)$/;\n\nfunction sanitizeIdentifier(name) {\n  return name.replace(/\\W/g, '_');\n}\n\nvar _anonymousTypeIndex = 0;\n\nfunction identifierName(compileIdentifier) {\n  if (!compileIdentifier || !compileIdentifier.reference) {\n    return null;\n  }\n\n  var ref = compileIdentifier.reference;\n\n  if (ref instanceof StaticSymbol) {\n    return ref.name;\n  }\n\n  if (ref['__anonymousType']) {\n    return ref['__anonymousType'];\n  }\n\n  var identifier = stringify(ref);\n\n  if (identifier.indexOf('(') >= 0) {\n    // case: anonymous functions!\n    identifier = \"anonymous_\".concat(_anonymousTypeIndex++);\n    ref['__anonymousType'] = identifier;\n  } else {\n    identifier = sanitizeIdentifier(identifier);\n  }\n\n  return identifier;\n}\n\nfunction identifierModuleUrl(compileIdentifier) {\n  var ref = compileIdentifier.reference;\n\n  if (ref instanceof StaticSymbol) {\n    return ref.filePath;\n  } // Runtime type\n\n\n  return \"./\".concat(stringify(ref));\n}\n\nfunction viewClassName(compType, embeddedTemplateIndex) {\n  return \"View_\".concat(identifierName({\n    reference: compType\n  }), \"_\").concat(embeddedTemplateIndex);\n}\n\nfunction rendererTypeName(compType) {\n  return \"RenderType_\".concat(identifierName({\n    reference: compType\n  }));\n}\n\nfunction hostViewClassName(compType) {\n  return \"HostView_\".concat(identifierName({\n    reference: compType\n  }));\n}\n\nfunction componentFactoryName(compType) {\n  return \"\".concat(identifierName({\n    reference: compType\n  }), \"NgFactory\");\n}\n\nvar CompileSummaryKind;\n\n(function (CompileSummaryKind) {\n  CompileSummaryKind[CompileSummaryKind[\"Pipe\"] = 0] = \"Pipe\";\n  CompileSummaryKind[CompileSummaryKind[\"Directive\"] = 1] = \"Directive\";\n  CompileSummaryKind[CompileSummaryKind[\"NgModule\"] = 2] = \"NgModule\";\n  CompileSummaryKind[CompileSummaryKind[\"Injectable\"] = 3] = \"Injectable\";\n})(CompileSummaryKind || (CompileSummaryKind = {}));\n\nfunction tokenName(token) {\n  return token.value != null ? sanitizeIdentifier(token.value) : identifierName(token.identifier);\n}\n\nfunction tokenReference(token) {\n  if (token.identifier != null) {\n    return token.identifier.reference;\n  } else {\n    return token.value;\n  }\n}\n/**\n * Metadata about a stylesheet\n */\n\n\nvar CompileStylesheetMetadata = function CompileStylesheetMetadata() {\n  var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      moduleUrl = _ref3.moduleUrl,\n      styles = _ref3.styles,\n      styleUrls = _ref3.styleUrls;\n\n  _classCallCheck(this, CompileStylesheetMetadata);\n\n  this.moduleUrl = moduleUrl || null;\n  this.styles = _normalizeArray(styles);\n  this.styleUrls = _normalizeArray(styleUrls);\n};\n/**\n * Metadata regarding compilation of a template.\n */\n\n\nvar CompileTemplateMetadata = /*#__PURE__*/function () {\n  function CompileTemplateMetadata(_ref4) {\n    var encapsulation = _ref4.encapsulation,\n        template = _ref4.template,\n        templateUrl = _ref4.templateUrl,\n        htmlAst = _ref4.htmlAst,\n        styles = _ref4.styles,\n        styleUrls = _ref4.styleUrls,\n        externalStylesheets = _ref4.externalStylesheets,\n        animations = _ref4.animations,\n        ngContentSelectors = _ref4.ngContentSelectors,\n        interpolation = _ref4.interpolation,\n        isInline = _ref4.isInline,\n        preserveWhitespaces = _ref4.preserveWhitespaces;\n\n    _classCallCheck(this, CompileTemplateMetadata);\n\n    this.encapsulation = encapsulation;\n    this.template = template;\n    this.templateUrl = templateUrl;\n    this.htmlAst = htmlAst;\n    this.styles = _normalizeArray(styles);\n    this.styleUrls = _normalizeArray(styleUrls);\n    this.externalStylesheets = _normalizeArray(externalStylesheets);\n    this.animations = animations ? flatten(animations) : [];\n    this.ngContentSelectors = ngContentSelectors || [];\n\n    if (interpolation && interpolation.length != 2) {\n      throw new Error(\"'interpolation' should have a start and an end symbol.\");\n    }\n\n    this.interpolation = interpolation;\n    this.isInline = isInline;\n    this.preserveWhitespaces = preserveWhitespaces;\n  }\n\n  _createClass(CompileTemplateMetadata, [{\n    key: \"toSummary\",\n    value: function toSummary() {\n      return {\n        ngContentSelectors: this.ngContentSelectors,\n        encapsulation: this.encapsulation,\n        styles: this.styles,\n        animations: this.animations\n      };\n    }\n  }]);\n\n  return CompileTemplateMetadata;\n}();\n/**\n * Metadata regarding compilation of a directive.\n */\n\n\nvar CompileDirectiveMetadata = /*#__PURE__*/function () {\n  function CompileDirectiveMetadata(_ref5) {\n    var isHost = _ref5.isHost,\n        type = _ref5.type,\n        isComponent = _ref5.isComponent,\n        selector = _ref5.selector,\n        exportAs = _ref5.exportAs,\n        changeDetection = _ref5.changeDetection,\n        inputs = _ref5.inputs,\n        outputs = _ref5.outputs,\n        hostListeners = _ref5.hostListeners,\n        hostProperties = _ref5.hostProperties,\n        hostAttributes = _ref5.hostAttributes,\n        providers = _ref5.providers,\n        viewProviders = _ref5.viewProviders,\n        queries = _ref5.queries,\n        guards = _ref5.guards,\n        viewQueries = _ref5.viewQueries,\n        entryComponents = _ref5.entryComponents,\n        template = _ref5.template,\n        componentViewType = _ref5.componentViewType,\n        rendererType = _ref5.rendererType,\n        componentFactory = _ref5.componentFactory;\n\n    _classCallCheck(this, CompileDirectiveMetadata);\n\n    this.isHost = !!isHost;\n    this.type = type;\n    this.isComponent = isComponent;\n    this.selector = selector;\n    this.exportAs = exportAs;\n    this.changeDetection = changeDetection;\n    this.inputs = inputs;\n    this.outputs = outputs;\n    this.hostListeners = hostListeners;\n    this.hostProperties = hostProperties;\n    this.hostAttributes = hostAttributes;\n    this.providers = _normalizeArray(providers);\n    this.viewProviders = _normalizeArray(viewProviders);\n    this.queries = _normalizeArray(queries);\n    this.guards = guards;\n    this.viewQueries = _normalizeArray(viewQueries);\n    this.entryComponents = _normalizeArray(entryComponents);\n    this.template = template;\n    this.componentViewType = componentViewType;\n    this.rendererType = rendererType;\n    this.componentFactory = componentFactory;\n  }\n\n  _createClass(CompileDirectiveMetadata, [{\n    key: \"toSummary\",\n    value: function toSummary() {\n      return {\n        summaryKind: CompileSummaryKind.Directive,\n        type: this.type,\n        isComponent: this.isComponent,\n        selector: this.selector,\n        exportAs: this.exportAs,\n        inputs: this.inputs,\n        outputs: this.outputs,\n        hostListeners: this.hostListeners,\n        hostProperties: this.hostProperties,\n        hostAttributes: this.hostAttributes,\n        providers: this.providers,\n        viewProviders: this.viewProviders,\n        queries: this.queries,\n        guards: this.guards,\n        viewQueries: this.viewQueries,\n        entryComponents: this.entryComponents,\n        changeDetection: this.changeDetection,\n        template: this.template && this.template.toSummary(),\n        componentViewType: this.componentViewType,\n        rendererType: this.rendererType,\n        componentFactory: this.componentFactory\n      };\n    }\n  }], [{\n    key: \"create\",\n    value: function create(_ref6) {\n      var isHost = _ref6.isHost,\n          type = _ref6.type,\n          isComponent = _ref6.isComponent,\n          selector = _ref6.selector,\n          exportAs = _ref6.exportAs,\n          changeDetection = _ref6.changeDetection,\n          inputs = _ref6.inputs,\n          outputs = _ref6.outputs,\n          host = _ref6.host,\n          providers = _ref6.providers,\n          viewProviders = _ref6.viewProviders,\n          queries = _ref6.queries,\n          guards = _ref6.guards,\n          viewQueries = _ref6.viewQueries,\n          entryComponents = _ref6.entryComponents,\n          template = _ref6.template,\n          componentViewType = _ref6.componentViewType,\n          rendererType = _ref6.rendererType,\n          componentFactory = _ref6.componentFactory;\n      var hostListeners = {};\n      var hostProperties = {};\n      var hostAttributes = {};\n\n      if (host != null) {\n        Object.keys(host).forEach(function (key) {\n          var value = host[key];\n          var matches = key.match(HOST_REG_EXP);\n\n          if (matches === null) {\n            hostAttributes[key] = value;\n          } else if (matches[1] != null) {\n            hostProperties[matches[1]] = value;\n          } else if (matches[2] != null) {\n            hostListeners[matches[2]] = value;\n          }\n        });\n      }\n\n      var inputsMap = {};\n\n      if (inputs != null) {\n        inputs.forEach(function (bindConfig) {\n          // canonical syntax: `dirProp: elProp`\n          // if there is no `:`, use dirProp = elProp\n          var parts = splitAtColon(bindConfig, [bindConfig, bindConfig]);\n          inputsMap[parts[0]] = parts[1];\n        });\n      }\n\n      var outputsMap = {};\n\n      if (outputs != null) {\n        outputs.forEach(function (bindConfig) {\n          // canonical syntax: `dirProp: elProp`\n          // if there is no `:`, use dirProp = elProp\n          var parts = splitAtColon(bindConfig, [bindConfig, bindConfig]);\n          outputsMap[parts[0]] = parts[1];\n        });\n      }\n\n      return new CompileDirectiveMetadata({\n        isHost: isHost,\n        type: type,\n        isComponent: !!isComponent,\n        selector: selector,\n        exportAs: exportAs,\n        changeDetection: changeDetection,\n        inputs: inputsMap,\n        outputs: outputsMap,\n        hostListeners: hostListeners,\n        hostProperties: hostProperties,\n        hostAttributes: hostAttributes,\n        providers: providers,\n        viewProviders: viewProviders,\n        queries: queries,\n        guards: guards,\n        viewQueries: viewQueries,\n        entryComponents: entryComponents,\n        template: template,\n        componentViewType: componentViewType,\n        rendererType: rendererType,\n        componentFactory: componentFactory\n      });\n    }\n  }]);\n\n  return CompileDirectiveMetadata;\n}();\n\nvar CompilePipeMetadata = /*#__PURE__*/function () {\n  function CompilePipeMetadata(_ref7) {\n    var type = _ref7.type,\n        name = _ref7.name,\n        pure = _ref7.pure;\n\n    _classCallCheck(this, CompilePipeMetadata);\n\n    this.type = type;\n    this.name = name;\n    this.pure = !!pure;\n  }\n\n  _createClass(CompilePipeMetadata, [{\n    key: \"toSummary\",\n    value: function toSummary() {\n      return {\n        summaryKind: CompileSummaryKind.Pipe,\n        type: this.type,\n        name: this.name,\n        pure: this.pure\n      };\n    }\n  }]);\n\n  return CompilePipeMetadata;\n}();\n\nvar CompileShallowModuleMetadata = function CompileShallowModuleMetadata() {\n  _classCallCheck(this, CompileShallowModuleMetadata);\n};\n/**\n * Metadata regarding compilation of a module.\n */\n\n\nvar CompileNgModuleMetadata = /*#__PURE__*/function () {\n  function CompileNgModuleMetadata(_ref8) {\n    var type = _ref8.type,\n        providers = _ref8.providers,\n        declaredDirectives = _ref8.declaredDirectives,\n        exportedDirectives = _ref8.exportedDirectives,\n        declaredPipes = _ref8.declaredPipes,\n        exportedPipes = _ref8.exportedPipes,\n        entryComponents = _ref8.entryComponents,\n        bootstrapComponents = _ref8.bootstrapComponents,\n        importedModules = _ref8.importedModules,\n        exportedModules = _ref8.exportedModules,\n        schemas = _ref8.schemas,\n        transitiveModule = _ref8.transitiveModule,\n        id = _ref8.id;\n\n    _classCallCheck(this, CompileNgModuleMetadata);\n\n    this.type = type || null;\n    this.declaredDirectives = _normalizeArray(declaredDirectives);\n    this.exportedDirectives = _normalizeArray(exportedDirectives);\n    this.declaredPipes = _normalizeArray(declaredPipes);\n    this.exportedPipes = _normalizeArray(exportedPipes);\n    this.providers = _normalizeArray(providers);\n    this.entryComponents = _normalizeArray(entryComponents);\n    this.bootstrapComponents = _normalizeArray(bootstrapComponents);\n    this.importedModules = _normalizeArray(importedModules);\n    this.exportedModules = _normalizeArray(exportedModules);\n    this.schemas = _normalizeArray(schemas);\n    this.id = id || null;\n    this.transitiveModule = transitiveModule || null;\n  }\n\n  _createClass(CompileNgModuleMetadata, [{\n    key: \"toSummary\",\n    value: function toSummary() {\n      var module = this.transitiveModule;\n      return {\n        summaryKind: CompileSummaryKind.NgModule,\n        type: this.type,\n        entryComponents: module.entryComponents,\n        providers: module.providers,\n        modules: module.modules,\n        exportedDirectives: module.exportedDirectives,\n        exportedPipes: module.exportedPipes\n      };\n    }\n  }]);\n\n  return CompileNgModuleMetadata;\n}();\n\nvar TransitiveCompileNgModuleMetadata = /*#__PURE__*/function () {\n  function TransitiveCompileNgModuleMetadata() {\n    _classCallCheck(this, TransitiveCompileNgModuleMetadata);\n\n    this.directivesSet = new Set();\n    this.directives = [];\n    this.exportedDirectivesSet = new Set();\n    this.exportedDirectives = [];\n    this.pipesSet = new Set();\n    this.pipes = [];\n    this.exportedPipesSet = new Set();\n    this.exportedPipes = [];\n    this.modulesSet = new Set();\n    this.modules = [];\n    this.entryComponentsSet = new Set();\n    this.entryComponents = [];\n    this.providers = [];\n  }\n\n  _createClass(TransitiveCompileNgModuleMetadata, [{\n    key: \"addProvider\",\n    value: function addProvider(provider, module) {\n      this.providers.push({\n        provider: provider,\n        module: module\n      });\n    }\n  }, {\n    key: \"addDirective\",\n    value: function addDirective(id) {\n      if (!this.directivesSet.has(id.reference)) {\n        this.directivesSet.add(id.reference);\n        this.directives.push(id);\n      }\n    }\n  }, {\n    key: \"addExportedDirective\",\n    value: function addExportedDirective(id) {\n      if (!this.exportedDirectivesSet.has(id.reference)) {\n        this.exportedDirectivesSet.add(id.reference);\n        this.exportedDirectives.push(id);\n      }\n    }\n  }, {\n    key: \"addPipe\",\n    value: function addPipe(id) {\n      if (!this.pipesSet.has(id.reference)) {\n        this.pipesSet.add(id.reference);\n        this.pipes.push(id);\n      }\n    }\n  }, {\n    key: \"addExportedPipe\",\n    value: function addExportedPipe(id) {\n      if (!this.exportedPipesSet.has(id.reference)) {\n        this.exportedPipesSet.add(id.reference);\n        this.exportedPipes.push(id);\n      }\n    }\n  }, {\n    key: \"addModule\",\n    value: function addModule(id) {\n      if (!this.modulesSet.has(id.reference)) {\n        this.modulesSet.add(id.reference);\n        this.modules.push(id);\n      }\n    }\n  }, {\n    key: \"addEntryComponent\",\n    value: function addEntryComponent(ec) {\n      if (!this.entryComponentsSet.has(ec.componentType)) {\n        this.entryComponentsSet.add(ec.componentType);\n        this.entryComponents.push(ec);\n      }\n    }\n  }]);\n\n  return TransitiveCompileNgModuleMetadata;\n}();\n\nfunction _normalizeArray(obj) {\n  return obj || [];\n}\n\nvar ProviderMeta = function ProviderMeta(token, _ref9) {\n  var useClass = _ref9.useClass,\n      useValue = _ref9.useValue,\n      useExisting = _ref9.useExisting,\n      useFactory = _ref9.useFactory,\n      deps = _ref9.deps,\n      multi = _ref9.multi;\n\n  _classCallCheck(this, ProviderMeta);\n\n  this.token = token;\n  this.useClass = useClass || null;\n  this.useValue = useValue;\n  this.useExisting = useExisting;\n  this.useFactory = useFactory || null;\n  this.dependencies = deps || null;\n  this.multi = !!multi;\n};\n\nfunction flatten(list) {\n  return list.reduce(function (flat, item) {\n    var flatItem = Array.isArray(item) ? flatten(item) : item;\n    return flat.concat(flatItem);\n  }, []);\n}\n\nfunction jitSourceUrl(url) {\n  // Note: We need 3 \"/\" so that ng shows up as a separate domain\n  // in the chrome dev tools.\n  return url.replace(/(\\w+:\\/\\/[\\w:-]+)?(\\/+)?/, 'ng:///');\n}\n\nfunction templateSourceUrl(ngModuleType, compMeta, templateMeta) {\n  var url;\n\n  if (templateMeta.isInline) {\n    if (compMeta.type.reference instanceof StaticSymbol) {\n      // Note: a .ts file might contain multiple components with inline templates,\n      // so we need to give them unique urls, as these will be used for sourcemaps.\n      url = \"\".concat(compMeta.type.reference.filePath, \".\").concat(compMeta.type.reference.name, \".html\");\n    } else {\n      url = \"\".concat(identifierName(ngModuleType), \"/\").concat(identifierName(compMeta.type), \".html\");\n    }\n  } else {\n    url = templateMeta.templateUrl;\n  }\n\n  return compMeta.type.reference instanceof StaticSymbol ? url : jitSourceUrl(url);\n}\n\nfunction sharedStylesheetJitUrl(meta, id) {\n  var pathParts = meta.moduleUrl.split(/\\/\\\\/g);\n  var baseName = pathParts[pathParts.length - 1];\n  return jitSourceUrl(\"css/\".concat(id).concat(baseName, \".ngstyle.js\"));\n}\n\nfunction ngModuleJitUrl(moduleMeta) {\n  return jitSourceUrl(\"\".concat(identifierName(moduleMeta.type), \"/module.ngfactory.js\"));\n}\n\nfunction templateJitUrl(ngModuleType, compMeta) {\n  return jitSourceUrl(\"\".concat(identifierName(ngModuleType), \"/\").concat(identifierName(compMeta.type), \".ngfactory.js\"));\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar CORE$1 = '@angular/core';\n\nvar Identifiers$1 = function Identifiers$1() {\n  _classCallCheck(this, Identifiers$1);\n};\n/* Methods */\n\n\nIdentifiers$1.NEW_METHOD = 'factory';\nIdentifiers$1.TRANSFORM_METHOD = 'transform';\nIdentifiers$1.PATCH_DEPS = 'patchedDeps';\n/* Instructions */\n\nIdentifiers$1.namespaceHTML = {\n  name: 'ɵɵnamespaceHTML',\n  moduleName: CORE$1\n};\nIdentifiers$1.namespaceMathML = {\n  name: 'ɵɵnamespaceMathML',\n  moduleName: CORE$1\n};\nIdentifiers$1.namespaceSVG = {\n  name: 'ɵɵnamespaceSVG',\n  moduleName: CORE$1\n};\nIdentifiers$1.element = {\n  name: 'ɵɵelement',\n  moduleName: CORE$1\n};\nIdentifiers$1.elementStart = {\n  name: 'ɵɵelementStart',\n  moduleName: CORE$1\n};\nIdentifiers$1.elementEnd = {\n  name: 'ɵɵelementEnd',\n  moduleName: CORE$1\n};\nIdentifiers$1.select = {\n  name: 'ɵɵselect',\n  moduleName: CORE$1\n};\nIdentifiers$1.advance = {\n  name: 'ɵɵadvance',\n  moduleName: CORE$1\n};\nIdentifiers$1.updateSyntheticHostBinding = {\n  name: 'ɵɵupdateSyntheticHostBinding',\n  moduleName: CORE$1\n};\nIdentifiers$1.componentHostSyntheticListener = {\n  name: 'ɵɵcomponentHostSyntheticListener',\n  moduleName: CORE$1\n};\nIdentifiers$1.attribute = {\n  name: 'ɵɵattribute',\n  moduleName: CORE$1\n};\nIdentifiers$1.attributeInterpolate1 = {\n  name: 'ɵɵattributeInterpolate1',\n  moduleName: CORE$1\n};\nIdentifiers$1.attributeInterpolate2 = {\n  name: 'ɵɵattributeInterpolate2',\n  moduleName: CORE$1\n};\nIdentifiers$1.attributeInterpolate3 = {\n  name: 'ɵɵattributeInterpolate3',\n  moduleName: CORE$1\n};\nIdentifiers$1.attributeInterpolate4 = {\n  name: 'ɵɵattributeInterpolate4',\n  moduleName: CORE$1\n};\nIdentifiers$1.attributeInterpolate5 = {\n  name: 'ɵɵattributeInterpolate5',\n  moduleName: CORE$1\n};\nIdentifiers$1.attributeInterpolate6 = {\n  name: 'ɵɵattributeInterpolate6',\n  moduleName: CORE$1\n};\nIdentifiers$1.attributeInterpolate7 = {\n  name: 'ɵɵattributeInterpolate7',\n  moduleName: CORE$1\n};\nIdentifiers$1.attributeInterpolate8 = {\n  name: 'ɵɵattributeInterpolate8',\n  moduleName: CORE$1\n};\nIdentifiers$1.attributeInterpolateV = {\n  name: 'ɵɵattributeInterpolateV',\n  moduleName: CORE$1\n};\nIdentifiers$1.classProp = {\n  name: 'ɵɵclassProp',\n  moduleName: CORE$1\n};\nIdentifiers$1.elementContainerStart = {\n  name: 'ɵɵelementContainerStart',\n  moduleName: CORE$1\n};\nIdentifiers$1.elementContainerEnd = {\n  name: 'ɵɵelementContainerEnd',\n  moduleName: CORE$1\n};\nIdentifiers$1.elementContainer = {\n  name: 'ɵɵelementContainer',\n  moduleName: CORE$1\n};\nIdentifiers$1.styleMap = {\n  name: 'ɵɵstyleMap',\n  moduleName: CORE$1\n};\nIdentifiers$1.styleMapInterpolate1 = {\n  name: 'ɵɵstyleMapInterpolate1',\n  moduleName: CORE$1\n};\nIdentifiers$1.styleMapInterpolate2 = {\n  name: 'ɵɵstyleMapInterpolate2',\n  moduleName: CORE$1\n};\nIdentifiers$1.styleMapInterpolate3 = {\n  name: 'ɵɵstyleMapInterpolate3',\n  moduleName: CORE$1\n};\nIdentifiers$1.styleMapInterpolate4 = {\n  name: 'ɵɵstyleMapInterpolate4',\n  moduleName: CORE$1\n};\nIdentifiers$1.styleMapInterpolate5 = {\n  name: 'ɵɵstyleMapInterpolate5',\n  moduleName: CORE$1\n};\nIdentifiers$1.styleMapInterpolate6 = {\n  name: 'ɵɵstyleMapInterpolate6',\n  moduleName: CORE$1\n};\nIdentifiers$1.styleMapInterpolate7 = {\n  name: 'ɵɵstyleMapInterpolate7',\n  moduleName: CORE$1\n};\nIdentifiers$1.styleMapInterpolate8 = {\n  name: 'ɵɵstyleMapInterpolate8',\n  moduleName: CORE$1\n};\nIdentifiers$1.styleMapInterpolateV = {\n  name: 'ɵɵstyleMapInterpolateV',\n  moduleName: CORE$1\n};\nIdentifiers$1.classMap = {\n  name: 'ɵɵclassMap',\n  moduleName: CORE$1\n};\nIdentifiers$1.classMapInterpolate1 = {\n  name: 'ɵɵclassMapInterpolate1',\n  moduleName: CORE$1\n};\nIdentifiers$1.classMapInterpolate2 = {\n  name: 'ɵɵclassMapInterpolate2',\n  moduleName: CORE$1\n};\nIdentifiers$1.classMapInterpolate3 = {\n  name: 'ɵɵclassMapInterpolate3',\n  moduleName: CORE$1\n};\nIdentifiers$1.classMapInterpolate4 = {\n  name: 'ɵɵclassMapInterpolate4',\n  moduleName: CORE$1\n};\nIdentifiers$1.classMapInterpolate5 = {\n  name: 'ɵɵclassMapInterpolate5',\n  moduleName: CORE$1\n};\nIdentifiers$1.classMapInterpolate6 = {\n  name: 'ɵɵclassMapInterpolate6',\n  moduleName: CORE$1\n};\nIdentifiers$1.classMapInterpolate7 = {\n  name: 'ɵɵclassMapInterpolate7',\n  moduleName: CORE$1\n};\nIdentifiers$1.classMapInterpolate8 = {\n  name: 'ɵɵclassMapInterpolate8',\n  moduleName: CORE$1\n};\nIdentifiers$1.classMapInterpolateV = {\n  name: 'ɵɵclassMapInterpolateV',\n  moduleName: CORE$1\n};\nIdentifiers$1.styleProp = {\n  name: 'ɵɵstyleProp',\n  moduleName: CORE$1\n};\nIdentifiers$1.stylePropInterpolate1 = {\n  name: 'ɵɵstylePropInterpolate1',\n  moduleName: CORE$1\n};\nIdentifiers$1.stylePropInterpolate2 = {\n  name: 'ɵɵstylePropInterpolate2',\n  moduleName: CORE$1\n};\nIdentifiers$1.stylePropInterpolate3 = {\n  name: 'ɵɵstylePropInterpolate3',\n  moduleName: CORE$1\n};\nIdentifiers$1.stylePropInterpolate4 = {\n  name: 'ɵɵstylePropInterpolate4',\n  moduleName: CORE$1\n};\nIdentifiers$1.stylePropInterpolate5 = {\n  name: 'ɵɵstylePropInterpolate5',\n  moduleName: CORE$1\n};\nIdentifiers$1.stylePropInterpolate6 = {\n  name: 'ɵɵstylePropInterpolate6',\n  moduleName: CORE$1\n};\nIdentifiers$1.stylePropInterpolate7 = {\n  name: 'ɵɵstylePropInterpolate7',\n  moduleName: CORE$1\n};\nIdentifiers$1.stylePropInterpolate8 = {\n  name: 'ɵɵstylePropInterpolate8',\n  moduleName: CORE$1\n};\nIdentifiers$1.stylePropInterpolateV = {\n  name: 'ɵɵstylePropInterpolateV',\n  moduleName: CORE$1\n};\nIdentifiers$1.nextContext = {\n  name: 'ɵɵnextContext',\n  moduleName: CORE$1\n};\nIdentifiers$1.templateCreate = {\n  name: 'ɵɵtemplate',\n  moduleName: CORE$1\n};\nIdentifiers$1.text = {\n  name: 'ɵɵtext',\n  moduleName: CORE$1\n};\nIdentifiers$1.enableBindings = {\n  name: 'ɵɵenableBindings',\n  moduleName: CORE$1\n};\nIdentifiers$1.disableBindings = {\n  name: 'ɵɵdisableBindings',\n  moduleName: CORE$1\n};\nIdentifiers$1.getCurrentView = {\n  name: 'ɵɵgetCurrentView',\n  moduleName: CORE$1\n};\nIdentifiers$1.textInterpolate = {\n  name: 'ɵɵtextInterpolate',\n  moduleName: CORE$1\n};\nIdentifiers$1.textInterpolate1 = {\n  name: 'ɵɵtextInterpolate1',\n  moduleName: CORE$1\n};\nIdentifiers$1.textInterpolate2 = {\n  name: 'ɵɵtextInterpolate2',\n  moduleName: CORE$1\n};\nIdentifiers$1.textInterpolate3 = {\n  name: 'ɵɵtextInterpolate3',\n  moduleName: CORE$1\n};\nIdentifiers$1.textInterpolate4 = {\n  name: 'ɵɵtextInterpolate4',\n  moduleName: CORE$1\n};\nIdentifiers$1.textInterpolate5 = {\n  name: 'ɵɵtextInterpolate5',\n  moduleName: CORE$1\n};\nIdentifiers$1.textInterpolate6 = {\n  name: 'ɵɵtextInterpolate6',\n  moduleName: CORE$1\n};\nIdentifiers$1.textInterpolate7 = {\n  name: 'ɵɵtextInterpolate7',\n  moduleName: CORE$1\n};\nIdentifiers$1.textInterpolate8 = {\n  name: 'ɵɵtextInterpolate8',\n  moduleName: CORE$1\n};\nIdentifiers$1.textInterpolateV = {\n  name: 'ɵɵtextInterpolateV',\n  moduleName: CORE$1\n};\nIdentifiers$1.restoreView = {\n  name: 'ɵɵrestoreView',\n  moduleName: CORE$1\n};\nIdentifiers$1.pureFunction0 = {\n  name: 'ɵɵpureFunction0',\n  moduleName: CORE$1\n};\nIdentifiers$1.pureFunction1 = {\n  name: 'ɵɵpureFunction1',\n  moduleName: CORE$1\n};\nIdentifiers$1.pureFunction2 = {\n  name: 'ɵɵpureFunction2',\n  moduleName: CORE$1\n};\nIdentifiers$1.pureFunction3 = {\n  name: 'ɵɵpureFunction3',\n  moduleName: CORE$1\n};\nIdentifiers$1.pureFunction4 = {\n  name: 'ɵɵpureFunction4',\n  moduleName: CORE$1\n};\nIdentifiers$1.pureFunction5 = {\n  name: 'ɵɵpureFunction5',\n  moduleName: CORE$1\n};\nIdentifiers$1.pureFunction6 = {\n  name: 'ɵɵpureFunction6',\n  moduleName: CORE$1\n};\nIdentifiers$1.pureFunction7 = {\n  name: 'ɵɵpureFunction7',\n  moduleName: CORE$1\n};\nIdentifiers$1.pureFunction8 = {\n  name: 'ɵɵpureFunction8',\n  moduleName: CORE$1\n};\nIdentifiers$1.pureFunctionV = {\n  name: 'ɵɵpureFunctionV',\n  moduleName: CORE$1\n};\nIdentifiers$1.pipeBind1 = {\n  name: 'ɵɵpipeBind1',\n  moduleName: CORE$1\n};\nIdentifiers$1.pipeBind2 = {\n  name: 'ɵɵpipeBind2',\n  moduleName: CORE$1\n};\nIdentifiers$1.pipeBind3 = {\n  name: 'ɵɵpipeBind3',\n  moduleName: CORE$1\n};\nIdentifiers$1.pipeBind4 = {\n  name: 'ɵɵpipeBind4',\n  moduleName: CORE$1\n};\nIdentifiers$1.pipeBindV = {\n  name: 'ɵɵpipeBindV',\n  moduleName: CORE$1\n};\nIdentifiers$1.hostProperty = {\n  name: 'ɵɵhostProperty',\n  moduleName: CORE$1\n};\nIdentifiers$1.property = {\n  name: 'ɵɵproperty',\n  moduleName: CORE$1\n};\nIdentifiers$1.propertyInterpolate = {\n  name: 'ɵɵpropertyInterpolate',\n  moduleName: CORE$1\n};\nIdentifiers$1.propertyInterpolate1 = {\n  name: 'ɵɵpropertyInterpolate1',\n  moduleName: CORE$1\n};\nIdentifiers$1.propertyInterpolate2 = {\n  name: 'ɵɵpropertyInterpolate2',\n  moduleName: CORE$1\n};\nIdentifiers$1.propertyInterpolate3 = {\n  name: 'ɵɵpropertyInterpolate3',\n  moduleName: CORE$1\n};\nIdentifiers$1.propertyInterpolate4 = {\n  name: 'ɵɵpropertyInterpolate4',\n  moduleName: CORE$1\n};\nIdentifiers$1.propertyInterpolate5 = {\n  name: 'ɵɵpropertyInterpolate5',\n  moduleName: CORE$1\n};\nIdentifiers$1.propertyInterpolate6 = {\n  name: 'ɵɵpropertyInterpolate6',\n  moduleName: CORE$1\n};\nIdentifiers$1.propertyInterpolate7 = {\n  name: 'ɵɵpropertyInterpolate7',\n  moduleName: CORE$1\n};\nIdentifiers$1.propertyInterpolate8 = {\n  name: 'ɵɵpropertyInterpolate8',\n  moduleName: CORE$1\n};\nIdentifiers$1.propertyInterpolateV = {\n  name: 'ɵɵpropertyInterpolateV',\n  moduleName: CORE$1\n};\nIdentifiers$1.i18n = {\n  name: 'ɵɵi18n',\n  moduleName: CORE$1\n};\nIdentifiers$1.i18nAttributes = {\n  name: 'ɵɵi18nAttributes',\n  moduleName: CORE$1\n};\nIdentifiers$1.i18nExp = {\n  name: 'ɵɵi18nExp',\n  moduleName: CORE$1\n};\nIdentifiers$1.i18nStart = {\n  name: 'ɵɵi18nStart',\n  moduleName: CORE$1\n};\nIdentifiers$1.i18nEnd = {\n  name: 'ɵɵi18nEnd',\n  moduleName: CORE$1\n};\nIdentifiers$1.i18nApply = {\n  name: 'ɵɵi18nApply',\n  moduleName: CORE$1\n};\nIdentifiers$1.i18nPostprocess = {\n  name: 'ɵɵi18nPostprocess',\n  moduleName: CORE$1\n};\nIdentifiers$1.pipe = {\n  name: 'ɵɵpipe',\n  moduleName: CORE$1\n};\nIdentifiers$1.projection = {\n  name: 'ɵɵprojection',\n  moduleName: CORE$1\n};\nIdentifiers$1.projectionDef = {\n  name: 'ɵɵprojectionDef',\n  moduleName: CORE$1\n};\nIdentifiers$1.reference = {\n  name: 'ɵɵreference',\n  moduleName: CORE$1\n};\nIdentifiers$1.inject = {\n  name: 'ɵɵinject',\n  moduleName: CORE$1\n};\nIdentifiers$1.injectAttribute = {\n  name: 'ɵɵinjectAttribute',\n  moduleName: CORE$1\n};\nIdentifiers$1.injectPipeChangeDetectorRef = {\n  name: 'ɵɵinjectPipeChangeDetectorRef',\n  moduleName: CORE$1\n};\nIdentifiers$1.directiveInject = {\n  name: 'ɵɵdirectiveInject',\n  moduleName: CORE$1\n};\nIdentifiers$1.invalidFactory = {\n  name: 'ɵɵinvalidFactory',\n  moduleName: CORE$1\n};\nIdentifiers$1.invalidFactoryDep = {\n  name: 'ɵɵinvalidFactoryDep',\n  moduleName: CORE$1\n};\nIdentifiers$1.templateRefExtractor = {\n  name: 'ɵɵtemplateRefExtractor',\n  moduleName: CORE$1\n};\nIdentifiers$1.resolveWindow = {\n  name: 'ɵɵresolveWindow',\n  moduleName: CORE$1\n};\nIdentifiers$1.resolveDocument = {\n  name: 'ɵɵresolveDocument',\n  moduleName: CORE$1\n};\nIdentifiers$1.resolveBody = {\n  name: 'ɵɵresolveBody',\n  moduleName: CORE$1\n};\nIdentifiers$1.defineComponent = {\n  name: 'ɵɵdefineComponent',\n  moduleName: CORE$1\n};\nIdentifiers$1.setComponentScope = {\n  name: 'ɵɵsetComponentScope',\n  moduleName: CORE$1\n};\nIdentifiers$1.ComponentDefWithMeta = {\n  name: 'ɵɵComponentDefWithMeta',\n  moduleName: CORE$1\n};\nIdentifiers$1.FactoryDef = {\n  name: 'ɵɵFactoryDef',\n  moduleName: CORE$1\n};\nIdentifiers$1.defineDirective = {\n  name: 'ɵɵdefineDirective',\n  moduleName: CORE$1\n};\nIdentifiers$1.DirectiveDefWithMeta = {\n  name: 'ɵɵDirectiveDefWithMeta',\n  moduleName: CORE$1\n};\nIdentifiers$1.InjectorDef = {\n  name: 'ɵɵInjectorDef',\n  moduleName: CORE$1\n};\nIdentifiers$1.defineInjector = {\n  name: 'ɵɵdefineInjector',\n  moduleName: CORE$1\n};\nIdentifiers$1.NgModuleDefWithMeta = {\n  name: 'ɵɵNgModuleDefWithMeta',\n  moduleName: CORE$1\n};\nIdentifiers$1.ModuleWithProviders = {\n  name: 'ModuleWithProviders',\n  moduleName: CORE$1\n};\nIdentifiers$1.defineNgModule = {\n  name: 'ɵɵdefineNgModule',\n  moduleName: CORE$1\n};\nIdentifiers$1.setNgModuleScope = {\n  name: 'ɵɵsetNgModuleScope',\n  moduleName: CORE$1\n};\nIdentifiers$1.PipeDefWithMeta = {\n  name: 'ɵɵPipeDefWithMeta',\n  moduleName: CORE$1\n};\nIdentifiers$1.definePipe = {\n  name: 'ɵɵdefinePipe',\n  moduleName: CORE$1\n};\nIdentifiers$1.queryRefresh = {\n  name: 'ɵɵqueryRefresh',\n  moduleName: CORE$1\n};\nIdentifiers$1.viewQuery = {\n  name: 'ɵɵviewQuery',\n  moduleName: CORE$1\n};\nIdentifiers$1.staticViewQuery = {\n  name: 'ɵɵstaticViewQuery',\n  moduleName: CORE$1\n};\nIdentifiers$1.staticContentQuery = {\n  name: 'ɵɵstaticContentQuery',\n  moduleName: CORE$1\n};\nIdentifiers$1.loadQuery = {\n  name: 'ɵɵloadQuery',\n  moduleName: CORE$1\n};\nIdentifiers$1.contentQuery = {\n  name: 'ɵɵcontentQuery',\n  moduleName: CORE$1\n};\nIdentifiers$1.NgOnChangesFeature = {\n  name: 'ɵɵNgOnChangesFeature',\n  moduleName: CORE$1\n};\nIdentifiers$1.InheritDefinitionFeature = {\n  name: 'ɵɵInheritDefinitionFeature',\n  moduleName: CORE$1\n};\nIdentifiers$1.CopyDefinitionFeature = {\n  name: 'ɵɵCopyDefinitionFeature',\n  moduleName: CORE$1\n};\nIdentifiers$1.ProvidersFeature = {\n  name: 'ɵɵProvidersFeature',\n  moduleName: CORE$1\n};\nIdentifiers$1.listener = {\n  name: 'ɵɵlistener',\n  moduleName: CORE$1\n};\nIdentifiers$1.getFactoryOf = {\n  name: 'ɵɵgetFactoryOf',\n  moduleName: CORE$1\n};\nIdentifiers$1.getInheritedFactory = {\n  name: 'ɵɵgetInheritedFactory',\n  moduleName: CORE$1\n}; // sanitization-related functions\n\nIdentifiers$1.sanitizeHtml = {\n  name: 'ɵɵsanitizeHtml',\n  moduleName: CORE$1\n};\nIdentifiers$1.sanitizeStyle = {\n  name: 'ɵɵsanitizeStyle',\n  moduleName: CORE$1\n};\nIdentifiers$1.sanitizeResourceUrl = {\n  name: 'ɵɵsanitizeResourceUrl',\n  moduleName: CORE$1\n};\nIdentifiers$1.sanitizeScript = {\n  name: 'ɵɵsanitizeScript',\n  moduleName: CORE$1\n};\nIdentifiers$1.sanitizeUrl = {\n  name: 'ɵɵsanitizeUrl',\n  moduleName: CORE$1\n};\nIdentifiers$1.sanitizeUrlOrResourceUrl = {\n  name: 'ɵɵsanitizeUrlOrResourceUrl',\n  moduleName: CORE$1\n};\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Convert an object map with `Expression` values into a `LiteralMapExpr`.\n */\n\nfunction mapToMapExpression(map) {\n  var result = Object.keys(map).map(function (key) {\n    return {\n      key: key,\n      // The assertion here is because really TypeScript doesn't allow us to express that if the\n      // key is present, it will have a value, but this is true in reality.\n      value: map[key],\n      quoted: false\n    };\n  });\n  return literalMap(result);\n}\n/**\n * Convert metadata into an `Expression` in the given `OutputContext`.\n *\n * This operation will handle arrays, references to symbols, or literal `null` or `undefined`.\n */\n\n\nfunction convertMetaToOutput(meta, ctx) {\n  if (Array.isArray(meta)) {\n    return literalArr(meta.map(function (entry) {\n      return convertMetaToOutput(entry, ctx);\n    }));\n  }\n\n  if (meta instanceof StaticSymbol) {\n    return ctx.importExpr(meta);\n  }\n\n  if (meta == null) {\n    return literal(meta);\n  }\n\n  throw new Error(\"Internal error: Unsupported or unknown metadata: \".concat(meta));\n}\n\nfunction typeWithParameters(type, numParams) {\n  var params = null;\n\n  if (numParams > 0) {\n    params = [];\n\n    for (var i = 0; i < numParams; i++) {\n      params.push(DYNAMIC_TYPE);\n    }\n  }\n\n  return expressionType(type, null, params);\n}\n\nvar ANIMATE_SYMBOL_PREFIX = '@';\n\nfunction prepareSyntheticPropertyName(name) {\n  return \"\".concat(ANIMATE_SYMBOL_PREFIX).concat(name);\n}\n\nfunction prepareSyntheticListenerName(name, phase) {\n  return \"\".concat(ANIMATE_SYMBOL_PREFIX).concat(name, \".\").concat(phase);\n}\n\nfunction isSyntheticPropertyOrListener(name) {\n  return name.charAt(0) == ANIMATE_SYMBOL_PREFIX;\n}\n\nfunction getSyntheticPropertyName(name) {\n  // this will strip out listener phase values...\n  // @foo.start => @foo\n  var i = name.indexOf('.');\n  name = i > 0 ? name.substring(0, i) : name;\n\n  if (name.charAt(0) !== ANIMATE_SYMBOL_PREFIX) {\n    name = ANIMATE_SYMBOL_PREFIX + name;\n  }\n\n  return name;\n}\n\nfunction prepareSyntheticListenerFunctionName(name, phase) {\n  return \"animation_\".concat(name, \"_\").concat(phase);\n}\n\nfunction jitOnlyGuardedExpression(expr) {\n  var ngJitMode = new ExternalExpr({\n    name: 'ngJitMode',\n    moduleName: null\n  });\n  var jitFlagNotDefined = new BinaryOperatorExpr(BinaryOperator.Identical, new TypeofExpr(ngJitMode), literal('undefined'));\n  var jitFlagUndefinedOrTrue = new BinaryOperatorExpr(BinaryOperator.Or, jitFlagNotDefined, ngJitMode,\n  /* type */\n  undefined,\n  /* sourceSpan */\n  undefined, true);\n  return new BinaryOperatorExpr(BinaryOperator.And, jitFlagUndefinedOrTrue, expr);\n}\n\nfunction wrapReference(value) {\n  var wrapped = new WrappedNodeExpr(value);\n  return {\n    value: wrapped,\n    type: wrapped\n  };\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar $EOF = 0;\nvar $BSPACE = 8;\nvar $TAB = 9;\nvar $LF = 10;\nvar $VTAB = 11;\nvar $FF = 12;\nvar $CR = 13;\nvar $SPACE = 32;\nvar $BANG = 33;\nvar $DQ = 34;\nvar $HASH = 35;\nvar $$ = 36;\nvar $PERCENT = 37;\nvar $AMPERSAND = 38;\nvar $SQ = 39;\nvar $LPAREN = 40;\nvar $RPAREN = 41;\nvar $STAR = 42;\nvar $PLUS = 43;\nvar $COMMA = 44;\nvar $MINUS = 45;\nvar $PERIOD = 46;\nvar $SLASH = 47;\nvar $COLON = 58;\nvar $SEMICOLON = 59;\nvar $LT = 60;\nvar $EQ = 61;\nvar $GT = 62;\nvar $QUESTION = 63;\nvar $0 = 48;\nvar $7 = 55;\nvar $9 = 57;\nvar $A = 65;\nvar $E = 69;\nvar $F = 70;\nvar $X = 88;\nvar $Z = 90;\nvar $LBRACKET = 91;\nvar $BACKSLASH = 92;\nvar $RBRACKET = 93;\nvar $CARET = 94;\nvar $_ = 95;\nvar $a = 97;\nvar $b = 98;\nvar $e = 101;\nvar $f = 102;\nvar $n = 110;\nvar $r = 114;\nvar $t = 116;\nvar $u = 117;\nvar $v = 118;\nvar $x = 120;\nvar $z = 122;\nvar $LBRACE = 123;\nvar $BAR = 124;\nvar $RBRACE = 125;\nvar $NBSP = 160;\nvar $PIPE = 124;\nvar $TILDA = 126;\nvar $AT = 64;\nvar $BT = 96;\n\nfunction isWhitespace(code) {\n  return code >= $TAB && code <= $SPACE || code == $NBSP;\n}\n\nfunction isDigit(code) {\n  return $0 <= code && code <= $9;\n}\n\nfunction isAsciiLetter(code) {\n  return code >= $a && code <= $z || code >= $A && code <= $Z;\n}\n\nfunction isAsciiHexDigit(code) {\n  return code >= $a && code <= $f || code >= $A && code <= $F || isDigit(code);\n}\n\nfunction isNewLine(code) {\n  return code === $LF || code === $CR;\n}\n\nfunction isOctalDigit(code) {\n  return $0 <= code && code <= $7;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar ParseLocation = /*#__PURE__*/function () {\n  function ParseLocation(file, offset, line, col) {\n    _classCallCheck(this, ParseLocation);\n\n    this.file = file;\n    this.offset = offset;\n    this.line = line;\n    this.col = col;\n  }\n\n  _createClass(ParseLocation, [{\n    key: \"toString\",\n    value: function toString() {\n      return this.offset != null ? \"\".concat(this.file.url, \"@\").concat(this.line, \":\").concat(this.col) : this.file.url;\n    }\n  }, {\n    key: \"moveBy\",\n    value: function moveBy(delta) {\n      var source = this.file.content;\n      var len = source.length;\n      var offset = this.offset;\n      var line = this.line;\n      var col = this.col;\n\n      while (offset > 0 && delta < 0) {\n        offset--;\n        delta++;\n        var ch = source.charCodeAt(offset);\n\n        if (ch == $LF) {\n          line--;\n          var priorLine = source.substr(0, offset - 1).lastIndexOf(String.fromCharCode($LF));\n          col = priorLine > 0 ? offset - priorLine : offset;\n        } else {\n          col--;\n        }\n      }\n\n      while (offset < len && delta > 0) {\n        var _ch = source.charCodeAt(offset);\n\n        offset++;\n        delta--;\n\n        if (_ch == $LF) {\n          line++;\n          col = 0;\n        } else {\n          col++;\n        }\n      }\n\n      return new ParseLocation(this.file, offset, line, col);\n    } // Return the source around the location\n    // Up to `maxChars` or `maxLines` on each side of the location\n\n  }, {\n    key: \"getContext\",\n    value: function getContext(maxChars, maxLines) {\n      var content = this.file.content;\n      var startOffset = this.offset;\n\n      if (startOffset != null) {\n        if (startOffset > content.length - 1) {\n          startOffset = content.length - 1;\n        }\n\n        var endOffset = startOffset;\n        var ctxChars = 0;\n        var ctxLines = 0;\n\n        while (ctxChars < maxChars && startOffset > 0) {\n          startOffset--;\n          ctxChars++;\n\n          if (content[startOffset] == '\\n') {\n            if (++ctxLines == maxLines) {\n              break;\n            }\n          }\n        }\n\n        ctxChars = 0;\n        ctxLines = 0;\n\n        while (ctxChars < maxChars && endOffset < content.length - 1) {\n          endOffset++;\n          ctxChars++;\n\n          if (content[endOffset] == '\\n') {\n            if (++ctxLines == maxLines) {\n              break;\n            }\n          }\n        }\n\n        return {\n          before: content.substring(startOffset, this.offset),\n          after: content.substring(this.offset, endOffset + 1)\n        };\n      }\n\n      return null;\n    }\n  }]);\n\n  return ParseLocation;\n}();\n\nvar ParseSourceFile = function ParseSourceFile(content, url) {\n  _classCallCheck(this, ParseSourceFile);\n\n  this.content = content;\n  this.url = url;\n};\n\nvar ParseSourceSpan = /*#__PURE__*/function () {\n  function ParseSourceSpan(start, end) {\n    var details = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    _classCallCheck(this, ParseSourceSpan);\n\n    this.start = start;\n    this.end = end;\n    this.details = details;\n  }\n\n  _createClass(ParseSourceSpan, [{\n    key: \"toString\",\n    value: function toString() {\n      return this.start.file.content.substring(this.start.offset, this.end.offset);\n    }\n  }]);\n\n  return ParseSourceSpan;\n}();\n\nvar ParseErrorLevel;\n\n(function (ParseErrorLevel) {\n  ParseErrorLevel[ParseErrorLevel[\"WARNING\"] = 0] = \"WARNING\";\n  ParseErrorLevel[ParseErrorLevel[\"ERROR\"] = 1] = \"ERROR\";\n})(ParseErrorLevel || (ParseErrorLevel = {}));\n\nvar ParseError = /*#__PURE__*/function () {\n  function ParseError(span, msg) {\n    var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ParseErrorLevel.ERROR;\n\n    _classCallCheck(this, ParseError);\n\n    this.span = span;\n    this.msg = msg;\n    this.level = level;\n  }\n\n  _createClass(ParseError, [{\n    key: \"contextualMessage\",\n    value: function contextualMessage() {\n      var ctx = this.span.start.getContext(100, 3);\n      return ctx ? \"\".concat(this.msg, \" (\\\"\").concat(ctx.before, \"[\").concat(ParseErrorLevel[this.level], \" ->]\").concat(ctx.after, \"\\\")\") : this.msg;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var details = this.span.details ? \", \".concat(this.span.details) : '';\n      return \"\".concat(this.contextualMessage(), \": \").concat(this.span.start).concat(details);\n    }\n  }]);\n\n  return ParseError;\n}();\n\nfunction typeSourceSpan(kind, type) {\n  var moduleUrl = identifierModuleUrl(type);\n  var sourceFileName = moduleUrl != null ? \"in \".concat(kind, \" \").concat(identifierName(type), \" in \").concat(moduleUrl) : \"in \".concat(kind, \" \").concat(identifierName(type));\n  var sourceFile = new ParseSourceFile('', sourceFileName);\n  return new ParseSourceSpan(new ParseLocation(sourceFile, -1, -1, -1), new ParseLocation(sourceFile, -1, -1, -1));\n}\n/**\n * Generates Source Span object for a given R3 Type for JIT mode.\n *\n * @param kind Component or Directive.\n * @param typeName name of the Component or Directive.\n * @param sourceUrl reference to Component or Directive source.\n * @returns instance of ParseSourceSpan that represent a given Component or Directive.\n */\n\n\nfunction r3JitTypeSourceSpan(kind, typeName, sourceUrl) {\n  var sourceFileName = \"in \".concat(kind, \" \").concat(typeName, \" in \").concat(sourceUrl);\n  var sourceFile = new ParseSourceFile('', sourceFileName);\n  return new ParseSourceSpan(new ParseLocation(sourceFile, -1, -1, -1), new ParseLocation(sourceFile, -1, -1, -1));\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar Text = /*#__PURE__*/function () {\n  function Text(value, sourceSpan) {\n    _classCallCheck(this, Text);\n\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n  }\n\n  _createClass(Text, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      return visitor.visitText(this);\n    }\n  }]);\n\n  return Text;\n}();\n\nvar BoundText = /*#__PURE__*/function () {\n  function BoundText(value, sourceSpan, i18n) {\n    _classCallCheck(this, BoundText);\n\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n    this.i18n = i18n;\n  }\n\n  _createClass(BoundText, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      return visitor.visitBoundText(this);\n    }\n  }]);\n\n  return BoundText;\n}();\n\nvar TextAttribute = /*#__PURE__*/function () {\n  function TextAttribute(name, value, sourceSpan, valueSpan, i18n) {\n    _classCallCheck(this, TextAttribute);\n\n    this.name = name;\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n    this.valueSpan = valueSpan;\n    this.i18n = i18n;\n  }\n\n  _createClass(TextAttribute, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      return visitor.visitTextAttribute(this);\n    }\n  }]);\n\n  return TextAttribute;\n}();\n\nvar BoundAttribute = /*#__PURE__*/function () {\n  function BoundAttribute(name, type, securityContext, value, unit, sourceSpan, valueSpan, i18n) {\n    _classCallCheck(this, BoundAttribute);\n\n    this.name = name;\n    this.type = type;\n    this.securityContext = securityContext;\n    this.value = value;\n    this.unit = unit;\n    this.sourceSpan = sourceSpan;\n    this.valueSpan = valueSpan;\n    this.i18n = i18n;\n  }\n\n  _createClass(BoundAttribute, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      return visitor.visitBoundAttribute(this);\n    }\n  }], [{\n    key: \"fromBoundElementProperty\",\n    value: function fromBoundElementProperty(prop, i18n) {\n      return new BoundAttribute(prop.name, prop.type, prop.securityContext, prop.value, prop.unit, prop.sourceSpan, prop.valueSpan, i18n);\n    }\n  }]);\n\n  return BoundAttribute;\n}();\n\nvar BoundEvent = /*#__PURE__*/function () {\n  function BoundEvent(name, type, handler, target, phase, sourceSpan, handlerSpan) {\n    _classCallCheck(this, BoundEvent);\n\n    this.name = name;\n    this.type = type;\n    this.handler = handler;\n    this.target = target;\n    this.phase = phase;\n    this.sourceSpan = sourceSpan;\n    this.handlerSpan = handlerSpan;\n  }\n\n  _createClass(BoundEvent, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      return visitor.visitBoundEvent(this);\n    }\n  }], [{\n    key: \"fromParsedEvent\",\n    value: function fromParsedEvent(event) {\n      var target = event.type === 0\n      /* Regular */\n      ? event.targetOrPhase : null;\n      var phase = event.type === 1\n      /* Animation */\n      ? event.targetOrPhase : null;\n      return new BoundEvent(event.name, event.type, event.handler, target, phase, event.sourceSpan, event.handlerSpan);\n    }\n  }]);\n\n  return BoundEvent;\n}();\n\nvar Element = /*#__PURE__*/function () {\n  function Element(name, attributes, inputs, outputs, children, references, sourceSpan, startSourceSpan, endSourceSpan, i18n) {\n    _classCallCheck(this, Element);\n\n    this.name = name;\n    this.attributes = attributes;\n    this.inputs = inputs;\n    this.outputs = outputs;\n    this.children = children;\n    this.references = references;\n    this.sourceSpan = sourceSpan;\n    this.startSourceSpan = startSourceSpan;\n    this.endSourceSpan = endSourceSpan;\n    this.i18n = i18n; // If the element is empty then the source span should include any closing tag\n\n    if (children.length === 0 && startSourceSpan && endSourceSpan) {\n      this.sourceSpan = new ParseSourceSpan(sourceSpan.start, endSourceSpan.end);\n    }\n  }\n\n  _createClass(Element, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      return visitor.visitElement(this);\n    }\n  }]);\n\n  return Element;\n}();\n\nvar Template = /*#__PURE__*/function () {\n  function Template(tagName, attributes, inputs, outputs, templateAttrs, children, references, variables, sourceSpan, startSourceSpan, endSourceSpan, i18n) {\n    _classCallCheck(this, Template);\n\n    this.tagName = tagName;\n    this.attributes = attributes;\n    this.inputs = inputs;\n    this.outputs = outputs;\n    this.templateAttrs = templateAttrs;\n    this.children = children;\n    this.references = references;\n    this.variables = variables;\n    this.sourceSpan = sourceSpan;\n    this.startSourceSpan = startSourceSpan;\n    this.endSourceSpan = endSourceSpan;\n    this.i18n = i18n;\n  }\n\n  _createClass(Template, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      return visitor.visitTemplate(this);\n    }\n  }]);\n\n  return Template;\n}();\n\nvar Content = /*#__PURE__*/function () {\n  function Content(selector, attributes, sourceSpan, i18n) {\n    _classCallCheck(this, Content);\n\n    this.selector = selector;\n    this.attributes = attributes;\n    this.sourceSpan = sourceSpan;\n    this.i18n = i18n;\n  }\n\n  _createClass(Content, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      return visitor.visitContent(this);\n    }\n  }]);\n\n  return Content;\n}();\n\nvar Variable = /*#__PURE__*/function () {\n  function Variable(name, value, sourceSpan, valueSpan) {\n    _classCallCheck(this, Variable);\n\n    this.name = name;\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n    this.valueSpan = valueSpan;\n  }\n\n  _createClass(Variable, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      return visitor.visitVariable(this);\n    }\n  }]);\n\n  return Variable;\n}();\n\nvar Reference = /*#__PURE__*/function () {\n  function Reference(name, value, sourceSpan, valueSpan) {\n    _classCallCheck(this, Reference);\n\n    this.name = name;\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n    this.valueSpan = valueSpan;\n  }\n\n  _createClass(Reference, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      return visitor.visitReference(this);\n    }\n  }]);\n\n  return Reference;\n}();\n\nvar Icu = /*#__PURE__*/function () {\n  function Icu(vars, placeholders, sourceSpan, i18n) {\n    _classCallCheck(this, Icu);\n\n    this.vars = vars;\n    this.placeholders = placeholders;\n    this.sourceSpan = sourceSpan;\n    this.i18n = i18n;\n  }\n\n  _createClass(Icu, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      return visitor.visitIcu(this);\n    }\n  }]);\n\n  return Icu;\n}();\n\nvar NullVisitor = /*#__PURE__*/function () {\n  function NullVisitor() {\n    _classCallCheck(this, NullVisitor);\n  }\n\n  _createClass(NullVisitor, [{\n    key: \"visitElement\",\n    value: function visitElement(element) {}\n  }, {\n    key: \"visitTemplate\",\n    value: function visitTemplate(template) {}\n  }, {\n    key: \"visitContent\",\n    value: function visitContent(content) {}\n  }, {\n    key: \"visitVariable\",\n    value: function visitVariable(variable) {}\n  }, {\n    key: \"visitReference\",\n    value: function visitReference(reference) {}\n  }, {\n    key: \"visitTextAttribute\",\n    value: function visitTextAttribute(attribute) {}\n  }, {\n    key: \"visitBoundAttribute\",\n    value: function visitBoundAttribute(attribute) {}\n  }, {\n    key: \"visitBoundEvent\",\n    value: function visitBoundEvent(attribute) {}\n  }, {\n    key: \"visitText\",\n    value: function visitText(text) {}\n  }, {\n    key: \"visitBoundText\",\n    value: function visitBoundText(text) {}\n  }, {\n    key: \"visitIcu\",\n    value: function visitIcu(icu) {}\n  }]);\n\n  return NullVisitor;\n}();\n\nvar RecursiveVisitor = /*#__PURE__*/function () {\n  function RecursiveVisitor() {\n    _classCallCheck(this, RecursiveVisitor);\n  }\n\n  _createClass(RecursiveVisitor, [{\n    key: \"visitElement\",\n    value: function visitElement(element) {\n      visitAll(this, element.attributes);\n      visitAll(this, element.children);\n      visitAll(this, element.references);\n    }\n  }, {\n    key: \"visitTemplate\",\n    value: function visitTemplate(template) {\n      visitAll(this, template.attributes);\n      visitAll(this, template.children);\n      visitAll(this, template.references);\n      visitAll(this, template.variables);\n    }\n  }, {\n    key: \"visitContent\",\n    value: function visitContent(content) {}\n  }, {\n    key: \"visitVariable\",\n    value: function visitVariable(variable) {}\n  }, {\n    key: \"visitReference\",\n    value: function visitReference(reference) {}\n  }, {\n    key: \"visitTextAttribute\",\n    value: function visitTextAttribute(attribute) {}\n  }, {\n    key: \"visitBoundAttribute\",\n    value: function visitBoundAttribute(attribute) {}\n  }, {\n    key: \"visitBoundEvent\",\n    value: function visitBoundEvent(attribute) {}\n  }, {\n    key: \"visitText\",\n    value: function visitText(text) {}\n  }, {\n    key: \"visitBoundText\",\n    value: function visitBoundText(text) {}\n  }, {\n    key: \"visitIcu\",\n    value: function visitIcu(icu) {}\n  }]);\n\n  return RecursiveVisitor;\n}();\n\nvar TransformVisitor = /*#__PURE__*/function () {\n  function TransformVisitor() {\n    _classCallCheck(this, TransformVisitor);\n  }\n\n  _createClass(TransformVisitor, [{\n    key: \"visitElement\",\n    value: function visitElement(element) {\n      var newAttributes = transformAll(this, element.attributes);\n      var newInputs = transformAll(this, element.inputs);\n      var newOutputs = transformAll(this, element.outputs);\n      var newChildren = transformAll(this, element.children);\n      var newReferences = transformAll(this, element.references);\n\n      if (newAttributes != element.attributes || newInputs != element.inputs || newOutputs != element.outputs || newChildren != element.children || newReferences != element.references) {\n        return new Element(element.name, newAttributes, newInputs, newOutputs, newChildren, newReferences, element.sourceSpan, element.startSourceSpan, element.endSourceSpan);\n      }\n\n      return element;\n    }\n  }, {\n    key: \"visitTemplate\",\n    value: function visitTemplate(template) {\n      var newAttributes = transformAll(this, template.attributes);\n      var newInputs = transformAll(this, template.inputs);\n      var newOutputs = transformAll(this, template.outputs);\n      var newTemplateAttrs = transformAll(this, template.templateAttrs);\n      var newChildren = transformAll(this, template.children);\n      var newReferences = transformAll(this, template.references);\n      var newVariables = transformAll(this, template.variables);\n\n      if (newAttributes != template.attributes || newInputs != template.inputs || newOutputs != template.outputs || newTemplateAttrs != template.templateAttrs || newChildren != template.children || newReferences != template.references || newVariables != template.variables) {\n        return new Template(template.tagName, newAttributes, newInputs, newOutputs, newTemplateAttrs, newChildren, newReferences, newVariables, template.sourceSpan, template.startSourceSpan, template.endSourceSpan);\n      }\n\n      return template;\n    }\n  }, {\n    key: \"visitContent\",\n    value: function visitContent(content) {\n      return content;\n    }\n  }, {\n    key: \"visitVariable\",\n    value: function visitVariable(variable) {\n      return variable;\n    }\n  }, {\n    key: \"visitReference\",\n    value: function visitReference(reference) {\n      return reference;\n    }\n  }, {\n    key: \"visitTextAttribute\",\n    value: function visitTextAttribute(attribute) {\n      return attribute;\n    }\n  }, {\n    key: \"visitBoundAttribute\",\n    value: function visitBoundAttribute(attribute) {\n      return attribute;\n    }\n  }, {\n    key: \"visitBoundEvent\",\n    value: function visitBoundEvent(attribute) {\n      return attribute;\n    }\n  }, {\n    key: \"visitText\",\n    value: function visitText(text) {\n      return text;\n    }\n  }, {\n    key: \"visitBoundText\",\n    value: function visitBoundText(text) {\n      return text;\n    }\n  }, {\n    key: \"visitIcu\",\n    value: function visitIcu(icu) {\n      return icu;\n    }\n  }]);\n\n  return TransformVisitor;\n}();\n\nfunction visitAll(visitor, nodes) {\n  var result = [];\n\n  if (visitor.visit) {\n    var _iterator2 = _createForOfIteratorHelper(nodes),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var node = _step2.value;\n        var newNode = visitor.visit(node) || node.visit(visitor);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  } else {\n    var _iterator3 = _createForOfIteratorHelper(nodes),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var _node = _step3.value;\n\n        var _newNode = _node.visit(visitor);\n\n        if (_newNode) {\n          result.push(_newNode);\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n  }\n\n  return result;\n}\n\nfunction transformAll(visitor, nodes) {\n  var result = [];\n  var changed = false;\n\n  var _iterator4 = _createForOfIteratorHelper(nodes),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var node = _step4.value;\n      var newNode = node.visit(visitor);\n\n      if (newNode) {\n        result.push(newNode);\n      }\n\n      changed = changed || newNode != node;\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  return changed ? result : nodes;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar Message =\n/**\n * @param nodes message AST\n * @param placeholders maps placeholder names to static content\n * @param placeholderToMessage maps placeholder names to messages (used for nested ICU messages)\n * @param meaning\n * @param description\n * @param customId\n */\nfunction Message(nodes, placeholders, placeholderToMessage, meaning, description, customId) {\n  _classCallCheck(this, Message);\n\n  this.nodes = nodes;\n  this.placeholders = placeholders;\n  this.placeholderToMessage = placeholderToMessage;\n  this.meaning = meaning;\n  this.description = description;\n  this.customId = customId;\n  this.id = this.customId;\n  /** The ids to use if there are no custom id and if `i18nLegacyMessageIdFormat` is not empty */\n\n  this.legacyIds = [];\n\n  if (nodes.length) {\n    this.sources = [{\n      filePath: nodes[0].sourceSpan.start.file.url,\n      startLine: nodes[0].sourceSpan.start.line + 1,\n      startCol: nodes[0].sourceSpan.start.col + 1,\n      endLine: nodes[nodes.length - 1].sourceSpan.end.line + 1,\n      endCol: nodes[0].sourceSpan.start.col + 1\n    }];\n  } else {\n    this.sources = [];\n  }\n};\n\nvar Text$1 = /*#__PURE__*/function () {\n  function Text$1(value, sourceSpan) {\n    _classCallCheck(this, Text$1);\n\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n  }\n\n  _createClass(Text$1, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      return visitor.visitText(this, context);\n    }\n  }]);\n\n  return Text$1;\n}(); // TODO(vicb): do we really need this node (vs an array) ?\n\n\nvar Container = /*#__PURE__*/function () {\n  function Container(children, sourceSpan) {\n    _classCallCheck(this, Container);\n\n    this.children = children;\n    this.sourceSpan = sourceSpan;\n  }\n\n  _createClass(Container, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      return visitor.visitContainer(this, context);\n    }\n  }]);\n\n  return Container;\n}();\n\nvar Icu$1 = /*#__PURE__*/function () {\n  function Icu$1(expression, type, cases, sourceSpan) {\n    _classCallCheck(this, Icu$1);\n\n    this.expression = expression;\n    this.type = type;\n    this.cases = cases;\n    this.sourceSpan = sourceSpan;\n  }\n\n  _createClass(Icu$1, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      return visitor.visitIcu(this, context);\n    }\n  }]);\n\n  return Icu$1;\n}();\n\nvar TagPlaceholder = /*#__PURE__*/function () {\n  function TagPlaceholder(tag, attrs, startName, closeName, children, isVoid, sourceSpan) {\n    _classCallCheck(this, TagPlaceholder);\n\n    this.tag = tag;\n    this.attrs = attrs;\n    this.startName = startName;\n    this.closeName = closeName;\n    this.children = children;\n    this.isVoid = isVoid;\n    this.sourceSpan = sourceSpan;\n  }\n\n  _createClass(TagPlaceholder, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      return visitor.visitTagPlaceholder(this, context);\n    }\n  }]);\n\n  return TagPlaceholder;\n}();\n\nvar Placeholder = /*#__PURE__*/function () {\n  function Placeholder(value, name, sourceSpan) {\n    _classCallCheck(this, Placeholder);\n\n    this.value = value;\n    this.name = name;\n    this.sourceSpan = sourceSpan;\n  }\n\n  _createClass(Placeholder, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      return visitor.visitPlaceholder(this, context);\n    }\n  }]);\n\n  return Placeholder;\n}();\n\nvar IcuPlaceholder = /*#__PURE__*/function () {\n  function IcuPlaceholder(value, name, sourceSpan) {\n    _classCallCheck(this, IcuPlaceholder);\n\n    this.value = value;\n    this.name = name;\n    this.sourceSpan = sourceSpan;\n  }\n\n  _createClass(IcuPlaceholder, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      return visitor.visitIcuPlaceholder(this, context);\n    }\n  }]);\n\n  return IcuPlaceholder;\n}(); // Clone the AST\n\n\nvar CloneVisitor = /*#__PURE__*/function () {\n  function CloneVisitor() {\n    _classCallCheck(this, CloneVisitor);\n  }\n\n  _createClass(CloneVisitor, [{\n    key: \"visitText\",\n    value: function visitText(text, context) {\n      return new Text$1(text.value, text.sourceSpan);\n    }\n  }, {\n    key: \"visitContainer\",\n    value: function visitContainer(container, context) {\n      var _this61 = this;\n\n      var children = container.children.map(function (n) {\n        return n.visit(_this61, context);\n      });\n      return new Container(children, container.sourceSpan);\n    }\n  }, {\n    key: \"visitIcu\",\n    value: function visitIcu(icu, context) {\n      var _this62 = this;\n\n      var cases = {};\n      Object.keys(icu.cases).forEach(function (key) {\n        return cases[key] = icu.cases[key].visit(_this62, context);\n      });\n      var msg = new Icu$1(icu.expression, icu.type, cases, icu.sourceSpan);\n      msg.expressionPlaceholder = icu.expressionPlaceholder;\n      return msg;\n    }\n  }, {\n    key: \"visitTagPlaceholder\",\n    value: function visitTagPlaceholder(ph, context) {\n      var _this63 = this;\n\n      var children = ph.children.map(function (n) {\n        return n.visit(_this63, context);\n      });\n      return new TagPlaceholder(ph.tag, ph.attrs, ph.startName, ph.closeName, children, ph.isVoid, ph.sourceSpan);\n    }\n  }, {\n    key: \"visitPlaceholder\",\n    value: function visitPlaceholder(ph, context) {\n      return new Placeholder(ph.value, ph.name, ph.sourceSpan);\n    }\n  }, {\n    key: \"visitIcuPlaceholder\",\n    value: function visitIcuPlaceholder(ph, context) {\n      return new IcuPlaceholder(ph.value, ph.name, ph.sourceSpan);\n    }\n  }]);\n\n  return CloneVisitor;\n}(); // Visit all the nodes recursively\n\n\nvar RecurseVisitor = /*#__PURE__*/function () {\n  function RecurseVisitor() {\n    _classCallCheck(this, RecurseVisitor);\n  }\n\n  _createClass(RecurseVisitor, [{\n    key: \"visitText\",\n    value: function visitText(text, context) {}\n  }, {\n    key: \"visitContainer\",\n    value: function visitContainer(container, context) {\n      var _this64 = this;\n\n      container.children.forEach(function (child) {\n        return child.visit(_this64);\n      });\n    }\n  }, {\n    key: \"visitIcu\",\n    value: function visitIcu(icu, context) {\n      var _this65 = this;\n\n      Object.keys(icu.cases).forEach(function (k) {\n        icu.cases[k].visit(_this65);\n      });\n    }\n  }, {\n    key: \"visitTagPlaceholder\",\n    value: function visitTagPlaceholder(ph, context) {\n      var _this66 = this;\n\n      ph.children.forEach(function (child) {\n        return child.visit(_this66);\n      });\n    }\n  }, {\n    key: \"visitPlaceholder\",\n    value: function visitPlaceholder(ph, context) {}\n  }, {\n    key: \"visitIcuPlaceholder\",\n    value: function visitIcuPlaceholder(ph, context) {}\n  }]);\n\n  return RecurseVisitor;\n}();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Return the message id or compute it using the XLIFF1 digest.\n */\n\n\nfunction _digest2(message) {\n  return message.id || computeDigest(message);\n}\n/**\n * Compute the message id using the XLIFF1 digest.\n */\n\n\nfunction computeDigest(message) {\n  return sha1(serializeNodes(message.nodes).join('') + \"[\".concat(message.meaning, \"]\"));\n}\n/**\n * Return the message id or compute it using the XLIFF2/XMB/$localize digest.\n */\n\n\nfunction decimalDigest(message) {\n  return message.id || computeDecimalDigest(message);\n}\n/**\n * Compute the message id using the XLIFF2/XMB/$localize digest.\n */\n\n\nfunction computeDecimalDigest(message) {\n  var visitor = new _SerializerIgnoreIcuExpVisitor();\n  var parts = message.nodes.map(function (a) {\n    return a.visit(visitor, null);\n  });\n  return computeMsgId(parts.join(''), message.meaning);\n}\n/**\n * Serialize the i18n ast to something xml-like in order to generate an UID.\n *\n * The visitor is also used in the i18n parser tests\n *\n * @internal\n */\n\n\nvar _SerializerVisitor = /*#__PURE__*/function () {\n  function _SerializerVisitor() {\n    _classCallCheck(this, _SerializerVisitor);\n  }\n\n  _createClass(_SerializerVisitor, [{\n    key: \"visitText\",\n    value: function visitText(text, context) {\n      return text.value;\n    }\n  }, {\n    key: \"visitContainer\",\n    value: function visitContainer(container, context) {\n      var _this67 = this;\n\n      return \"[\".concat(container.children.map(function (child) {\n        return child.visit(_this67);\n      }).join(', '), \"]\");\n    }\n  }, {\n    key: \"visitIcu\",\n    value: function visitIcu(icu, context) {\n      var _this68 = this;\n\n      var strCases = Object.keys(icu.cases).map(function (k) {\n        return \"\".concat(k, \" {\").concat(icu.cases[k].visit(_this68), \"}\");\n      });\n      return \"{\".concat(icu.expression, \", \").concat(icu.type, \", \").concat(strCases.join(', '), \"}\");\n    }\n  }, {\n    key: \"visitTagPlaceholder\",\n    value: function visitTagPlaceholder(ph, context) {\n      var _this69 = this;\n\n      return ph.isVoid ? \"<ph tag name=\\\"\".concat(ph.startName, \"\\\"/>\") : \"<ph tag name=\\\"\".concat(ph.startName, \"\\\">\").concat(ph.children.map(function (child) {\n        return child.visit(_this69);\n      }).join(', '), \"</ph name=\\\"\").concat(ph.closeName, \"\\\">\");\n    }\n  }, {\n    key: \"visitPlaceholder\",\n    value: function visitPlaceholder(ph, context) {\n      return ph.value ? \"<ph name=\\\"\".concat(ph.name, \"\\\">\").concat(ph.value, \"</ph>\") : \"<ph name=\\\"\".concat(ph.name, \"\\\"/>\");\n    }\n  }, {\n    key: \"visitIcuPlaceholder\",\n    value: function visitIcuPlaceholder(ph, context) {\n      return \"<ph icu name=\\\"\".concat(ph.name, \"\\\">\").concat(ph.value.visit(this), \"</ph>\");\n    }\n  }]);\n\n  return _SerializerVisitor;\n}();\n\nvar serializerVisitor = new _SerializerVisitor();\n\nfunction serializeNodes(nodes) {\n  return nodes.map(function (a) {\n    return a.visit(serializerVisitor, null);\n  });\n}\n/**\n * Serialize the i18n ast to something xml-like in order to generate an UID.\n *\n * Ignore the ICU expressions so that message IDs stays identical if only the expression changes.\n *\n * @internal\n */\n\n\nvar _SerializerIgnoreIcuExpVisitor = /*#__PURE__*/function (_SerializerVisitor2) {\n  _inherits(_SerializerIgnoreIcuExpVisitor, _SerializerVisitor2);\n\n  var _super45 = _createSuper(_SerializerIgnoreIcuExpVisitor);\n\n  function _SerializerIgnoreIcuExpVisitor() {\n    _classCallCheck(this, _SerializerIgnoreIcuExpVisitor);\n\n    return _super45.apply(this, arguments);\n  }\n\n  _createClass(_SerializerIgnoreIcuExpVisitor, [{\n    key: \"visitIcu\",\n    value: function visitIcu(icu, context) {\n      var _this70 = this;\n\n      var strCases = Object.keys(icu.cases).map(function (k) {\n        return \"\".concat(k, \" {\").concat(icu.cases[k].visit(_this70), \"}\");\n      }); // Do not take the expression into account\n\n      return \"{\".concat(icu.type, \", \").concat(strCases.join(', '), \"}\");\n    }\n  }]);\n\n  return _SerializerIgnoreIcuExpVisitor;\n}(_SerializerVisitor);\n/**\n * Compute the SHA1 of the given string\n *\n * see http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf\n *\n * WARNING: this function has not been designed not tested with security in mind.\n *          DO NOT USE IT IN A SECURITY SENSITIVE CONTEXT.\n */\n\n\nfunction sha1(str) {\n  var utf8 = utf8Encode(str);\n  var words32 = stringToWords32(utf8, Endian.Big);\n  var len = utf8.length * 8;\n  var w = newArray(80);\n  var a = 0x67452301,\n      b = 0xefcdab89,\n      c = 0x98badcfe,\n      d = 0x10325476,\n      e = 0xc3d2e1f0;\n  words32[len >> 5] |= 0x80 << 24 - len % 32;\n  words32[(len + 64 >> 9 << 4) + 15] = len;\n\n  for (var i = 0; i < words32.length; i += 16) {\n    var h0 = a,\n        h1 = b,\n        h2 = c,\n        h3 = d,\n        h4 = e;\n\n    for (var j = 0; j < 80; j++) {\n      if (j < 16) {\n        w[j] = words32[i + j];\n      } else {\n        w[j] = rol32(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);\n      }\n\n      var fkVal = fk(j, b, c, d);\n      var f = fkVal[0];\n      var k = fkVal[1];\n      var temp = [rol32(a, 5), f, e, k, w[j]].reduce(add32);\n      e = d;\n      d = c;\n      c = rol32(b, 30);\n      b = a;\n      a = temp;\n    }\n\n    a = add32(a, h0);\n    b = add32(b, h1);\n    c = add32(c, h2);\n    d = add32(d, h3);\n    e = add32(e, h4);\n  }\n\n  return byteStringToHexString(words32ToByteString([a, b, c, d, e]));\n}\n\nfunction fk(index, b, c, d) {\n  if (index < 20) {\n    return [b & c | ~b & d, 0x5a827999];\n  }\n\n  if (index < 40) {\n    return [b ^ c ^ d, 0x6ed9eba1];\n  }\n\n  if (index < 60) {\n    return [b & c | b & d | c & d, 0x8f1bbcdc];\n  }\n\n  return [b ^ c ^ d, 0xca62c1d6];\n}\n/**\n * Compute the fingerprint of the given string\n *\n * The output is 64 bit number encoded as a decimal string\n *\n * based on:\n * https://github.com/google/closure-compiler/blob/master/src/com/google/javascript/jscomp/GoogleJsMessageIdGenerator.java\n */\n\n\nfunction fingerprint(str) {\n  var utf8 = utf8Encode(str);\n  var hi = hash32(utf8, 0);\n  var lo = hash32(utf8, 102072);\n\n  if (hi == 0 && (lo == 0 || lo == 1)) {\n    hi = hi ^ 0x130f9bef;\n    lo = lo ^ -0x6b5f56d8;\n  }\n\n  return [hi, lo];\n}\n\nfunction computeMsgId(msg) {\n  var meaning = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var msgFingerprint = fingerprint(msg);\n\n  if (meaning) {\n    var meaningFingerprint = fingerprint(meaning);\n    msgFingerprint = add64(rol64(msgFingerprint, 1), meaningFingerprint);\n  }\n\n  var hi = msgFingerprint[0];\n  var lo = msgFingerprint[1];\n  return byteStringToDecString(words32ToByteString([hi & 0x7fffffff, lo]));\n}\n\nfunction hash32(str, c) {\n  var a = 0x9e3779b9,\n      b = 0x9e3779b9;\n  var i;\n  var len = str.length;\n\n  for (i = 0; i + 12 <= len; i += 12) {\n    a = add32(a, wordAt(str, i, Endian.Little));\n    b = add32(b, wordAt(str, i + 4, Endian.Little));\n    c = add32(c, wordAt(str, i + 8, Endian.Little));\n    var res = mix(a, b, c);\n    a = res[0], b = res[1], c = res[2];\n  }\n\n  a = add32(a, wordAt(str, i, Endian.Little));\n  b = add32(b, wordAt(str, i + 4, Endian.Little)); // the first byte of c is reserved for the length\n\n  c = add32(c, len);\n  c = add32(c, wordAt(str, i + 8, Endian.Little) << 8);\n  return mix(a, b, c)[2];\n} // clang-format off\n\n\nfunction mix(a, b, c) {\n  a = sub32(a, b);\n  a = sub32(a, c);\n  a ^= c >>> 13;\n  b = sub32(b, c);\n  b = sub32(b, a);\n  b ^= a << 8;\n  c = sub32(c, a);\n  c = sub32(c, b);\n  c ^= b >>> 13;\n  a = sub32(a, b);\n  a = sub32(a, c);\n  a ^= c >>> 12;\n  b = sub32(b, c);\n  b = sub32(b, a);\n  b ^= a << 16;\n  c = sub32(c, a);\n  c = sub32(c, b);\n  c ^= b >>> 5;\n  a = sub32(a, b);\n  a = sub32(a, c);\n  a ^= c >>> 3;\n  b = sub32(b, c);\n  b = sub32(b, a);\n  b ^= a << 10;\n  c = sub32(c, a);\n  c = sub32(c, b);\n  c ^= b >>> 15;\n  return [a, b, c];\n} // clang-format on\n// Utils\n\n\nvar Endian;\n\n(function (Endian) {\n  Endian[Endian[\"Little\"] = 0] = \"Little\";\n  Endian[Endian[\"Big\"] = 1] = \"Big\";\n})(Endian || (Endian = {}));\n\nfunction add32(a, b) {\n  return add32to64(a, b)[1];\n}\n\nfunction add32to64(a, b) {\n  var low = (a & 0xffff) + (b & 0xffff);\n  var high = (a >>> 16) + (b >>> 16) + (low >>> 16);\n  return [high >>> 16, high << 16 | low & 0xffff];\n}\n\nfunction add64(a, b) {\n  var ah = a[0],\n      al = a[1];\n  var bh = b[0],\n      bl = b[1];\n  var result = add32to64(al, bl);\n  var carry = result[0];\n  var l = result[1];\n  var h = add32(add32(ah, bh), carry);\n  return [h, l];\n}\n\nfunction sub32(a, b) {\n  var low = (a & 0xffff) - (b & 0xffff);\n  var high = (a >> 16) - (b >> 16) + (low >> 16);\n  return high << 16 | low & 0xffff;\n} // Rotate a 32b number left `count` position\n\n\nfunction rol32(a, count) {\n  return a << count | a >>> 32 - count;\n} // Rotate a 64b number left `count` position\n\n\nfunction rol64(num, count) {\n  var hi = num[0],\n      lo = num[1];\n  var h = hi << count | lo >>> 32 - count;\n  var l = lo << count | hi >>> 32 - count;\n  return [h, l];\n}\n\nfunction stringToWords32(str, endian) {\n  var size = str.length + 3 >>> 2;\n  var words32 = [];\n\n  for (var i = 0; i < size; i++) {\n    words32[i] = wordAt(str, i * 4, endian);\n  }\n\n  return words32;\n}\n\nfunction byteAt(str, index) {\n  return index >= str.length ? 0 : str.charCodeAt(index) & 0xff;\n}\n\nfunction wordAt(str, index, endian) {\n  var word = 0;\n\n  if (endian === Endian.Big) {\n    for (var i = 0; i < 4; i++) {\n      word += byteAt(str, index + i) << 24 - 8 * i;\n    }\n  } else {\n    for (var _i5 = 0; _i5 < 4; _i5++) {\n      word += byteAt(str, index + _i5) << 8 * _i5;\n    }\n  }\n\n  return word;\n}\n\nfunction words32ToByteString(words32) {\n  return words32.reduce(function (str, word) {\n    return str + word32ToByteString(word);\n  }, '');\n}\n\nfunction word32ToByteString(word) {\n  var str = '';\n\n  for (var i = 0; i < 4; i++) {\n    str += String.fromCharCode(word >>> 8 * (3 - i) & 0xff);\n  }\n\n  return str;\n}\n\nfunction byteStringToHexString(str) {\n  var hex = '';\n\n  for (var i = 0; i < str.length; i++) {\n    var b = byteAt(str, i);\n    hex += (b >>> 4).toString(16) + (b & 0x0f).toString(16);\n  }\n\n  return hex.toLowerCase();\n} // based on http://www.danvk.org/hex2dec.html (JS can not handle more than 56b)\n\n\nfunction byteStringToDecString(str) {\n  var decimal = '';\n  var toThePower = '1';\n\n  for (var i = str.length - 1; i >= 0; i--) {\n    decimal = addBigInt(decimal, numberTimesBigInt(byteAt(str, i), toThePower));\n    toThePower = numberTimesBigInt(256, toThePower);\n  }\n\n  return decimal.split('').reverse().join('');\n} // x and y decimal, lowest significant digit first\n\n\nfunction addBigInt(x, y) {\n  var sum = '';\n  var len = Math.max(x.length, y.length);\n\n  for (var i = 0, carry = 0; i < len || carry; i++) {\n    var tmpSum = carry + +(x[i] || 0) + +(y[i] || 0);\n\n    if (tmpSum >= 10) {\n      carry = 1;\n      sum += tmpSum - 10;\n    } else {\n      carry = 0;\n      sum += tmpSum;\n    }\n  }\n\n  return sum;\n}\n\nfunction numberTimesBigInt(num, b) {\n  var product = '';\n  var bToThePower = b;\n\n  for (; num !== 0; num = num >>> 1) {\n    if (num & 1) product = addBigInt(product, bToThePower);\n    bToThePower = addBigInt(bToThePower, bToThePower);\n  }\n\n  return product;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar Serializer = /*#__PURE__*/function () {\n  function Serializer() {\n    _classCallCheck(this, Serializer);\n  }\n\n  _createClass(Serializer, [{\n    key: \"createNameMapper\",\n    // Creates a name mapper, see `PlaceholderMapper`\n    // Returning `null` means that no name mapping is used.\n    value: function createNameMapper(message) {\n      return null;\n    }\n  }]);\n\n  return Serializer;\n}();\n/**\n * A simple mapper that take a function to transform an internal name to a public name\n */\n\n\nvar SimplePlaceholderMapper = /*#__PURE__*/function (_RecurseVisitor) {\n  _inherits(SimplePlaceholderMapper, _RecurseVisitor);\n\n  var _super46 = _createSuper(SimplePlaceholderMapper);\n\n  // create a mapping from the message\n  function SimplePlaceholderMapper(message, mapName) {\n    var _this71;\n\n    _classCallCheck(this, SimplePlaceholderMapper);\n\n    _this71 = _super46.call(this);\n    _this71.mapName = mapName;\n    _this71.internalToPublic = {};\n    _this71.publicToNextId = {};\n    _this71.publicToInternal = {};\n    message.nodes.forEach(function (node) {\n      return node.visit(_assertThisInitialized(_this71));\n    });\n    return _this71;\n  }\n\n  _createClass(SimplePlaceholderMapper, [{\n    key: \"toPublicName\",\n    value: function toPublicName(internalName) {\n      return this.internalToPublic.hasOwnProperty(internalName) ? this.internalToPublic[internalName] : null;\n    }\n  }, {\n    key: \"toInternalName\",\n    value: function toInternalName(publicName) {\n      return this.publicToInternal.hasOwnProperty(publicName) ? this.publicToInternal[publicName] : null;\n    }\n  }, {\n    key: \"visitText\",\n    value: function visitText(text, context) {\n      return null;\n    }\n  }, {\n    key: \"visitTagPlaceholder\",\n    value: function visitTagPlaceholder(ph, context) {\n      this.visitPlaceholderName(ph.startName);\n\n      _get(_getPrototypeOf(SimplePlaceholderMapper.prototype), \"visitTagPlaceholder\", this).call(this, ph, context);\n\n      this.visitPlaceholderName(ph.closeName);\n    }\n  }, {\n    key: \"visitPlaceholder\",\n    value: function visitPlaceholder(ph, context) {\n      this.visitPlaceholderName(ph.name);\n    }\n  }, {\n    key: \"visitIcuPlaceholder\",\n    value: function visitIcuPlaceholder(ph, context) {\n      this.visitPlaceholderName(ph.name);\n    } // XMB placeholders could only contains A-Z, 0-9 and _\n\n  }, {\n    key: \"visitPlaceholderName\",\n    value: function visitPlaceholderName(internalName) {\n      if (!internalName || this.internalToPublic.hasOwnProperty(internalName)) {\n        return;\n      }\n\n      var publicName = this.mapName(internalName);\n\n      if (this.publicToInternal.hasOwnProperty(publicName)) {\n        // Create a new XMB when it has already been used\n        var nextId = this.publicToNextId[publicName];\n        this.publicToNextId[publicName] = nextId + 1;\n        publicName = \"\".concat(publicName, \"_\").concat(nextId);\n      } else {\n        this.publicToNextId[publicName] = 1;\n      }\n\n      this.internalToPublic[internalName] = publicName;\n      this.publicToInternal[publicName] = internalName;\n    }\n  }]);\n\n  return SimplePlaceholderMapper;\n}(RecurseVisitor);\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar _Visitor = /*#__PURE__*/function () {\n  function _Visitor() {\n    _classCallCheck(this, _Visitor);\n  }\n\n  _createClass(_Visitor, [{\n    key: \"visitTag\",\n    value: function visitTag(tag) {\n      var _this72 = this;\n\n      var strAttrs = this._serializeAttributes(tag.attrs);\n\n      if (tag.children.length == 0) {\n        return \"<\".concat(tag.name).concat(strAttrs, \"/>\");\n      }\n\n      var strChildren = tag.children.map(function (node) {\n        return node.visit(_this72);\n      });\n      return \"<\".concat(tag.name).concat(strAttrs, \">\").concat(strChildren.join(''), \"</\").concat(tag.name, \">\");\n    }\n  }, {\n    key: \"visitText\",\n    value: function visitText(text) {\n      return text.value;\n    }\n  }, {\n    key: \"visitDeclaration\",\n    value: function visitDeclaration(decl) {\n      return \"<?xml\".concat(this._serializeAttributes(decl.attrs), \" ?>\");\n    }\n  }, {\n    key: \"_serializeAttributes\",\n    value: function _serializeAttributes(attrs) {\n      var strAttrs = Object.keys(attrs).map(function (name) {\n        return \"\".concat(name, \"=\\\"\").concat(attrs[name], \"\\\"\");\n      }).join(' ');\n      return strAttrs.length > 0 ? ' ' + strAttrs : '';\n    }\n  }, {\n    key: \"visitDoctype\",\n    value: function visitDoctype(doctype) {\n      return \"<!DOCTYPE \".concat(doctype.rootTag, \" [\\n\").concat(doctype.dtd, \"\\n]>\");\n    }\n  }]);\n\n  return _Visitor;\n}();\n\nvar _visitor = new _Visitor();\n\nfunction serialize(nodes) {\n  return nodes.map(function (node) {\n    return node.visit(_visitor);\n  }).join('');\n}\n\nvar Declaration = /*#__PURE__*/function () {\n  function Declaration(unescapedAttrs) {\n    var _this73 = this;\n\n    _classCallCheck(this, Declaration);\n\n    this.attrs = {};\n    Object.keys(unescapedAttrs).forEach(function (k) {\n      _this73.attrs[k] = escapeXml(unescapedAttrs[k]);\n    });\n  }\n\n  _createClass(Declaration, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      return visitor.visitDeclaration(this);\n    }\n  }]);\n\n  return Declaration;\n}();\n\nvar Doctype = /*#__PURE__*/function () {\n  function Doctype(rootTag, dtd) {\n    _classCallCheck(this, Doctype);\n\n    this.rootTag = rootTag;\n    this.dtd = dtd;\n  }\n\n  _createClass(Doctype, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      return visitor.visitDoctype(this);\n    }\n  }]);\n\n  return Doctype;\n}();\n\nvar Tag = /*#__PURE__*/function () {\n  function Tag(name) {\n    var _this74 = this;\n\n    var unescapedAttrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n    _classCallCheck(this, Tag);\n\n    this.name = name;\n    this.children = children;\n    this.attrs = {};\n    Object.keys(unescapedAttrs).forEach(function (k) {\n      _this74.attrs[k] = escapeXml(unescapedAttrs[k]);\n    });\n  }\n\n  _createClass(Tag, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      return visitor.visitTag(this);\n    }\n  }]);\n\n  return Tag;\n}();\n\nvar Text$2 = /*#__PURE__*/function () {\n  function Text$2(unescapedValue) {\n    _classCallCheck(this, Text$2);\n\n    this.value = escapeXml(unescapedValue);\n  }\n\n  _createClass(Text$2, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      return visitor.visitText(this);\n    }\n  }]);\n\n  return Text$2;\n}();\n\nvar CR = /*#__PURE__*/function (_Text$) {\n  _inherits(CR, _Text$);\n\n  var _super47 = _createSuper(CR);\n\n  function CR() {\n    var ws = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n    _classCallCheck(this, CR);\n\n    return _super47.call(this, \"\\n\".concat(new Array(ws + 1).join(' ')));\n  }\n\n  return CR;\n}(Text$2);\n\nvar _ESCAPED_CHARS = [[/&/g, '&amp;'], [/\"/g, '&quot;'], [/'/g, '&apos;'], [/</g, '&lt;'], [/>/g, '&gt;']]; // Escape `_ESCAPED_CHARS` characters in the given text with encoded entities\n\nfunction escapeXml(text) {\n  return _ESCAPED_CHARS.reduce(function (text, entry) {\n    return text.replace(entry[0], entry[1]);\n  }, text);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar _MESSAGES_TAG = 'messagebundle';\nvar _MESSAGE_TAG = 'msg';\nvar _PLACEHOLDER_TAG = 'ph';\nvar _EXAMPLE_TAG = 'ex';\nvar _SOURCE_TAG = 'source';\nvar _DOCTYPE = \"<!ELEMENT messagebundle (msg)*>\\n<!ATTLIST messagebundle class CDATA #IMPLIED>\\n\\n<!ELEMENT msg (#PCDATA|ph|source)*>\\n<!ATTLIST msg id CDATA #IMPLIED>\\n<!ATTLIST msg seq CDATA #IMPLIED>\\n<!ATTLIST msg name CDATA #IMPLIED>\\n<!ATTLIST msg desc CDATA #IMPLIED>\\n<!ATTLIST msg meaning CDATA #IMPLIED>\\n<!ATTLIST msg obsolete (obsolete) #IMPLIED>\\n<!ATTLIST msg xml:space (default|preserve) \\\"default\\\">\\n<!ATTLIST msg is_hidden CDATA #IMPLIED>\\n\\n<!ELEMENT source (#PCDATA)>\\n\\n<!ELEMENT ph (#PCDATA|ex)*>\\n<!ATTLIST ph name CDATA #REQUIRED>\\n\\n<!ELEMENT ex (#PCDATA)>\";\n\nvar Xmb = /*#__PURE__*/function (_Serializer) {\n  _inherits(Xmb, _Serializer);\n\n  var _super48 = _createSuper(Xmb);\n\n  function Xmb() {\n    _classCallCheck(this, Xmb);\n\n    return _super48.apply(this, arguments);\n  }\n\n  _createClass(Xmb, [{\n    key: \"write\",\n    value: function write(messages, locale) {\n      var exampleVisitor = new ExampleVisitor();\n      var visitor = new _Visitor$1();\n      var rootNode = new Tag(_MESSAGES_TAG);\n      messages.forEach(function (message) {\n        var attrs = {\n          id: message.id\n        };\n\n        if (message.description) {\n          attrs['desc'] = message.description;\n        }\n\n        if (message.meaning) {\n          attrs['meaning'] = message.meaning;\n        }\n\n        var sourceTags = [];\n        message.sources.forEach(function (source) {\n          sourceTags.push(new Tag(_SOURCE_TAG, {}, [new Text$2(\"\".concat(source.filePath, \":\").concat(source.startLine).concat(source.endLine !== source.startLine ? ',' + source.endLine : ''))]));\n        });\n        rootNode.children.push(new CR(2), new Tag(_MESSAGE_TAG, attrs, [].concat(sourceTags, _toConsumableArray(visitor.serialize(message.nodes)))));\n      });\n      rootNode.children.push(new CR());\n      return serialize([new Declaration({\n        version: '1.0',\n        encoding: 'UTF-8'\n      }), new CR(), new Doctype(_MESSAGES_TAG, _DOCTYPE), new CR(), exampleVisitor.addDefaultExamples(rootNode), new CR()]);\n    }\n  }, {\n    key: \"load\",\n    value: function load(content, url) {\n      throw new Error('Unsupported');\n    }\n  }, {\n    key: \"digest\",\n    value: function digest(message) {\n      return digest$1(message);\n    }\n  }, {\n    key: \"createNameMapper\",\n    value: function createNameMapper(message) {\n      return new SimplePlaceholderMapper(message, toPublicName);\n    }\n  }]);\n\n  return Xmb;\n}(Serializer);\n\nvar _Visitor$1 = /*#__PURE__*/function () {\n  function _Visitor$1() {\n    _classCallCheck(this, _Visitor$1);\n  }\n\n  _createClass(_Visitor$1, [{\n    key: \"visitText\",\n    value: function visitText(text, context) {\n      return [new Text$2(text.value)];\n    }\n  }, {\n    key: \"visitContainer\",\n    value: function visitContainer(container, context) {\n      var _this75 = this;\n\n      var nodes = [];\n      container.children.forEach(function (node) {\n        return nodes.push.apply(nodes, _toConsumableArray(node.visit(_this75)));\n      });\n      return nodes;\n    }\n  }, {\n    key: \"visitIcu\",\n    value: function visitIcu(icu, context) {\n      var _this76 = this;\n\n      var nodes = [new Text$2(\"{\".concat(icu.expressionPlaceholder, \", \").concat(icu.type, \", \"))];\n      Object.keys(icu.cases).forEach(function (c) {\n        nodes.push.apply(nodes, [new Text$2(\"\".concat(c, \" {\"))].concat(_toConsumableArray(icu.cases[c].visit(_this76)), [new Text$2(\"} \")]));\n      });\n      nodes.push(new Text$2(\"}\"));\n      return nodes;\n    }\n  }, {\n    key: \"visitTagPlaceholder\",\n    value: function visitTagPlaceholder(ph, context) {\n      var startTagAsText = new Text$2(\"<\".concat(ph.tag, \">\"));\n      var startEx = new Tag(_EXAMPLE_TAG, {}, [startTagAsText]); // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n\n      var startTagPh = new Tag(_PLACEHOLDER_TAG, {\n        name: ph.startName\n      }, [startEx, startTagAsText]);\n\n      if (ph.isVoid) {\n        // void tags have no children nor closing tags\n        return [startTagPh];\n      }\n\n      var closeTagAsText = new Text$2(\"</\".concat(ph.tag, \">\"));\n      var closeEx = new Tag(_EXAMPLE_TAG, {}, [closeTagAsText]); // TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n\n      var closeTagPh = new Tag(_PLACEHOLDER_TAG, {\n        name: ph.closeName\n      }, [closeEx, closeTagAsText]);\n      return [startTagPh].concat(_toConsumableArray(this.serialize(ph.children)), [closeTagPh]);\n    }\n  }, {\n    key: \"visitPlaceholder\",\n    value: function visitPlaceholder(ph, context) {\n      var interpolationAsText = new Text$2(\"{{\".concat(ph.value, \"}}\")); // Example tag needs to be not-empty for TC.\n\n      var exTag = new Tag(_EXAMPLE_TAG, {}, [interpolationAsText]);\n      return [// TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n      new Tag(_PLACEHOLDER_TAG, {\n        name: ph.name\n      }, [exTag, interpolationAsText])];\n    }\n  }, {\n    key: \"visitIcuPlaceholder\",\n    value: function visitIcuPlaceholder(ph, context) {\n      var icuExpression = ph.value.expression;\n      var icuType = ph.value.type;\n      var icuCases = Object.keys(ph.value.cases).map(function (value) {\n        return value + ' {...}';\n      }).join(' ');\n      var icuAsText = new Text$2(\"{\".concat(icuExpression, \", \").concat(icuType, \", \").concat(icuCases, \"}\"));\n      var exTag = new Tag(_EXAMPLE_TAG, {}, [icuAsText]);\n      return [// TC requires PH to have a non empty EX, and uses the text node to show the \"original\" value.\n      new Tag(_PLACEHOLDER_TAG, {\n        name: ph.name\n      }, [exTag, icuAsText])];\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize(nodes) {\n      var _ref10,\n          _this77 = this;\n\n      return (_ref10 = []).concat.apply(_ref10, _toConsumableArray(nodes.map(function (node) {\n        return node.visit(_this77);\n      })));\n    }\n  }]);\n\n  return _Visitor$1;\n}();\n\nfunction digest$1(message) {\n  return decimalDigest(message);\n} // TC requires at least one non-empty example on placeholders\n\n\nvar ExampleVisitor = /*#__PURE__*/function () {\n  function ExampleVisitor() {\n    _classCallCheck(this, ExampleVisitor);\n  }\n\n  _createClass(ExampleVisitor, [{\n    key: \"addDefaultExamples\",\n    value: function addDefaultExamples(node) {\n      node.visit(this);\n      return node;\n    }\n  }, {\n    key: \"visitTag\",\n    value: function visitTag(tag) {\n      var _this78 = this;\n\n      if (tag.name === _PLACEHOLDER_TAG) {\n        if (!tag.children || tag.children.length == 0) {\n          var exText = new Text$2(tag.attrs['name'] || '...');\n          tag.children = [new Tag(_EXAMPLE_TAG, {}, [exText])];\n        }\n      } else if (tag.children) {\n        tag.children.forEach(function (node) {\n          return node.visit(_this78);\n        });\n      }\n    }\n  }, {\n    key: \"visitText\",\n    value: function visitText(text) {}\n  }, {\n    key: \"visitDeclaration\",\n    value: function visitDeclaration(decl) {}\n  }, {\n    key: \"visitDoctype\",\n    value: function visitDoctype(doctype) {}\n  }]);\n\n  return ExampleVisitor;\n}(); // XMB/XTB placeholders can only contain A-Z, 0-9 and _\n\n\nfunction toPublicName(internalName) {\n  return internalName.toUpperCase().replace(/[^A-Z0-9_]/g, '_');\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/* Closure variables holding messages must be named `MSG_[A-Z0-9]+` */\n\n\nvar CLOSURE_TRANSLATION_PREFIX = 'MSG_';\n/* Prefix for non-`goog.getMsg` i18n-related vars */\n\nvar TRANSLATION_PREFIX = 'I18N_';\n/** Name of the i18n attributes **/\n\nvar I18N_ATTR = 'i18n';\nvar I18N_ATTR_PREFIX = 'i18n-';\n/** Prefix of var expressions used in ICUs */\n\nvar I18N_ICU_VAR_PREFIX = 'VAR_';\n/** Prefix of ICU expressions for post processing */\n\nvar I18N_ICU_MAPPING_PREFIX = 'I18N_EXP_';\n/** Placeholder wrapper for i18n expressions **/\n\nvar I18N_PLACEHOLDER_SYMBOL = '�';\n\nfunction isI18nAttribute(name) {\n  return name === I18N_ATTR || name.startsWith(I18N_ATTR_PREFIX);\n}\n\nfunction isI18nRootNode(meta) {\n  return meta instanceof Message;\n}\n\nfunction isSingleI18nIcu(meta) {\n  return isI18nRootNode(meta) && meta.nodes.length === 1 && meta.nodes[0] instanceof Icu$1;\n}\n\nfunction hasI18nMeta(node) {\n  return !!node.i18n;\n}\n\nfunction hasI18nAttrs(element) {\n  return element.attrs.some(function (attr) {\n    return isI18nAttribute(attr.name);\n  });\n}\n\nfunction icuFromI18nMessage(message) {\n  return message.nodes[0];\n}\n\nfunction wrapI18nPlaceholder(content) {\n  var contextId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var blockId = contextId > 0 ? \":\".concat(contextId) : '';\n  return \"\".concat(I18N_PLACEHOLDER_SYMBOL).concat(content).concat(blockId).concat(I18N_PLACEHOLDER_SYMBOL);\n}\n\nfunction assembleI18nBoundString(strings) {\n  var bindingStartIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var contextId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  if (!strings.length) return '';\n  var acc = '';\n  var lastIdx = strings.length - 1;\n\n  for (var i = 0; i < lastIdx; i++) {\n    acc += \"\".concat(strings[i]).concat(wrapI18nPlaceholder(bindingStartIndex + i, contextId));\n  }\n\n  acc += strings[lastIdx];\n  return acc;\n}\n\nfunction getSeqNumberGenerator() {\n  var startsAt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n  var current = startsAt;\n  return function () {\n    return current++;\n  };\n}\n\nfunction placeholdersToParams(placeholders) {\n  var params = {};\n  placeholders.forEach(function (values, key) {\n    params[key] = literal(values.length > 1 ? \"[\".concat(values.join('|'), \"]\") : values[0]);\n  });\n  return params;\n}\n\nfunction updatePlaceholderMap(map, name) {\n  var current = map.get(name) || [];\n\n  for (var _len2 = arguments.length, values = new Array(_len2 > 2 ? _len2 - 2 : 0), _key3 = 2; _key3 < _len2; _key3++) {\n    values[_key3 - 2] = arguments[_key3];\n  }\n\n  current.push.apply(current, values);\n  map.set(name, current);\n}\n\nfunction assembleBoundTextPlaceholders(meta) {\n  var bindingStartIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var contextId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var startIdx = bindingStartIndex;\n  var placeholders = new Map();\n  var node = meta instanceof Message ? meta.nodes.find(function (node) {\n    return node instanceof Container;\n  }) : meta;\n\n  if (node) {\n    node.children.filter(function (child) {\n      return child instanceof Placeholder;\n    }).forEach(function (child, idx) {\n      var content = wrapI18nPlaceholder(startIdx + idx, contextId);\n      updatePlaceholderMap(placeholders, child.name, content);\n    });\n  }\n\n  return placeholders;\n}\n/**\n * Format the placeholder names in a map of placeholders to expressions.\n *\n * The placeholder names are converted from \"internal\" format (e.g. `START_TAG_DIV_1`) to \"external\"\n * format (e.g. `startTagDiv_1`).\n *\n * @param params A map of placeholder names to expressions.\n * @param useCamelCase whether to camelCase the placeholder name when formatting.\n * @returns A new map of formatted placeholder names to expressions.\n */\n\n\nfunction i18nFormatPlaceholderNames() {\n  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var useCamelCase = arguments.length > 1 ? arguments[1] : undefined;\n  var _params = {};\n\n  if (params && Object.keys(params).length) {\n    Object.keys(params).forEach(function (key) {\n      return _params[formatI18nPlaceholderName(key, useCamelCase)] = params[key];\n    });\n  }\n\n  return _params;\n}\n/**\n * Converts internal placeholder names to public-facing format\n * (for example to use in goog.getMsg call).\n * Example: `START_TAG_DIV_1` is converted to `startTagDiv_1`.\n *\n * @param name The placeholder name that should be formatted\n * @returns Formatted placeholder name\n */\n\n\nfunction formatI18nPlaceholderName(name) {\n  var useCamelCase = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var publicName = toPublicName(name);\n\n  if (!useCamelCase) {\n    return publicName;\n  }\n\n  var chunks = publicName.split('_');\n\n  if (chunks.length === 1) {\n    // if no \"_\" found - just lowercase the value\n    return name.toLowerCase();\n  }\n\n  var postfix; // eject last element if it's a number\n\n  if (/^\\d+$/.test(chunks[chunks.length - 1])) {\n    postfix = chunks.pop();\n  }\n\n  var raw = chunks.shift().toLowerCase();\n\n  if (chunks.length) {\n    raw += chunks.map(function (c) {\n      return c.charAt(0).toUpperCase() + c.slice(1).toLowerCase();\n    }).join('');\n  }\n\n  return postfix ? \"\".concat(raw, \"_\").concat(postfix) : raw;\n}\n/**\n * Generates a prefix for translation const name.\n *\n * @param extra Additional local prefix that should be injected into translation var name\n * @returns Complete translation const prefix\n */\n\n\nfunction getTranslationConstPrefix(extra) {\n  return \"\".concat(CLOSURE_TRANSLATION_PREFIX).concat(extra).toUpperCase();\n}\n/**\n * Generate AST to declare a variable. E.g. `var I18N_1;`.\n * @param variable the name of the variable to declare.\n */\n\n\nfunction declareI18nVariable(variable) {\n  return new DeclareVarStmt(variable.name, undefined, INFERRED_TYPE, null, variable.sourceSpan);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Checks whether an object key contains potentially unsafe chars, thus the key should be wrapped in\n * quotes. Note: we do not wrap all keys into quotes, as it may have impact on minification and may\n * bot work in some cases when object keys are mangled by minifier.\n *\n * TODO(FW-1136): this is a temporary solution, we need to come up with a better way of working with\n * inputs that contain potentially unsafe chars.\n */\n\n\nvar UNSAFE_OBJECT_KEY_NAME_REGEXP = /[-.]/;\n/** Name of the temporary to use during data binding */\n\nvar TEMPORARY_NAME = '_t';\n/** Name of the context parameter passed into a template function */\n\nvar CONTEXT_NAME = 'ctx';\n/** Name of the RenderFlag passed into a template function */\n\nvar RENDER_FLAGS = 'rf';\n/** The prefix reference variables */\n\nvar REFERENCE_PREFIX = '_r';\n/** The name of the implicit context reference */\n\nvar IMPLICIT_REFERENCE = '$implicit';\n/** Non bindable attribute name **/\n\nvar NON_BINDABLE_ATTR = 'ngNonBindable';\n/**\n * Creates an allocator for a temporary variable.\n *\n * A variable declaration is added to the statements the first time the allocator is invoked.\n */\n\nfunction temporaryAllocator(statements, name) {\n  var temp = null;\n  return function () {\n    if (!temp) {\n      statements.push(new DeclareVarStmt(TEMPORARY_NAME, undefined, DYNAMIC_TYPE));\n      temp = variable(name);\n    }\n\n    return temp;\n  };\n}\n\nfunction unsupported(feature) {\n  if (this) {\n    throw new Error(\"Builder \".concat(this.constructor.name, \" doesn't support \").concat(feature, \" yet\"));\n  }\n\n  throw new Error(\"Feature \".concat(feature, \" is not supported yet\"));\n}\n\nfunction invalid$1(arg) {\n  throw new Error(\"Invalid state: Visitor \".concat(this.constructor.name, \" doesn't handle \").concat(arg.constructor.name));\n}\n\nfunction asLiteral(value) {\n  if (Array.isArray(value)) {\n    return literalArr(value.map(asLiteral));\n  }\n\n  return literal(value, INFERRED_TYPE);\n}\n\nfunction conditionallyCreateMapObjectLiteral(keys, keepDeclared) {\n  if (Object.getOwnPropertyNames(keys).length > 0) {\n    return mapToExpression(keys, keepDeclared);\n  }\n\n  return null;\n}\n\nfunction mapToExpression(map, keepDeclared) {\n  return literalMap(Object.getOwnPropertyNames(map).map(function (key) {\n    // canonical syntax: `dirProp: publicProp`\n    // if there is no `:`, use dirProp = elProp\n    var value = map[key];\n    var declaredName;\n    var publicName;\n    var minifiedName;\n\n    if (Array.isArray(value)) {\n      var _value = _slicedToArray(value, 2);\n\n      publicName = _value[0];\n      declaredName = _value[1];\n    } else {\n      var _splitAtColon = splitAtColon(key, [key, value]);\n\n      var _splitAtColon2 = _slicedToArray(_splitAtColon, 2);\n\n      declaredName = _splitAtColon2[0];\n      publicName = _splitAtColon2[1];\n    }\n\n    minifiedName = declaredName;\n    return {\n      key: minifiedName,\n      // put quotes around keys that contain potentially unsafe characters\n      quoted: UNSAFE_OBJECT_KEY_NAME_REGEXP.test(minifiedName),\n      value: keepDeclared && publicName !== declaredName ? literalArr([asLiteral(publicName), asLiteral(declaredName)]) : asLiteral(publicName)\n    };\n  }));\n}\n/**\n *  Remove trailing null nodes as they are implied.\n */\n\n\nfunction trimTrailingNulls(parameters) {\n  while (isNull(parameters[parameters.length - 1])) {\n    parameters.pop();\n  }\n\n  return parameters;\n}\n\nfunction getQueryPredicate(query, constantPool) {\n  if (Array.isArray(query.predicate)) {\n    var predicate = [];\n    query.predicate.forEach(function (selector) {\n      // Each item in predicates array may contain strings with comma-separated refs\n      // (for ex. 'ref, ref1, ..., refN'), thus we extract individual refs and store them\n      // as separate array entities\n      var selectors = selector.split(',').map(function (token) {\n        return literal(token.trim());\n      });\n      predicate.push.apply(predicate, _toConsumableArray(selectors));\n    });\n    return constantPool.getConstLiteral(literalArr(predicate), true);\n  } else {\n    return query.predicate;\n  }\n}\n\nfunction noop() {}\n\nvar DefinitionMap = /*#__PURE__*/function () {\n  function DefinitionMap() {\n    _classCallCheck(this, DefinitionMap);\n\n    this.values = [];\n  }\n\n  _createClass(DefinitionMap, [{\n    key: \"set\",\n    value: function set(key, value) {\n      if (value) {\n        this.values.push({\n          key: key,\n          value: value,\n          quoted: false\n        });\n      }\n    }\n  }, {\n    key: \"toLiteralMap\",\n    value: function toLiteralMap() {\n      return literalMap(this.values);\n    }\n  }]);\n\n  return DefinitionMap;\n}();\n/**\n * Extract a map of properties to values for a given element or template node, which can be used\n * by the directive matching machinery.\n *\n * @param elOrTpl the element or template in question\n * @return an object set up for directive matching. For attributes on the element/template, this\n * object maps a property name to its (static) value. For any bindings, this map simply maps the\n * property name to an empty string.\n */\n\n\nfunction getAttrsForDirectiveMatching(elOrTpl) {\n  var attributesMap = {};\n\n  if (elOrTpl instanceof Template && elOrTpl.tagName !== 'ng-template') {\n    elOrTpl.templateAttrs.forEach(function (a) {\n      return attributesMap[a.name] = '';\n    });\n  } else {\n    elOrTpl.attributes.forEach(function (a) {\n      if (!isI18nAttribute(a.name)) {\n        attributesMap[a.name] = a.value;\n      }\n    });\n    elOrTpl.inputs.forEach(function (i) {\n      attributesMap[i.name] = '';\n    });\n    elOrTpl.outputs.forEach(function (o) {\n      attributesMap[o.name] = '';\n    });\n  }\n\n  return attributesMap;\n}\n/** Returns a call expression to a chained instruction, e.g. `property(params[0])(params[1])`. */\n\n\nfunction chainedInstruction(reference, calls, span) {\n  var expression = importExpr(reference, null, span);\n\n  if (calls.length > 0) {\n    for (var i = 0; i < calls.length; i++) {\n      expression = expression.callFn(calls[i], span);\n    }\n  } else {\n    // Add a blank invocation, in case the `calls` array is empty.\n    expression = expression.callFn([], span);\n  }\n\n  return expression;\n}\n/**\n * Gets the number of arguments expected to be passed to a generated instruction in the case of\n * interpolation instructions.\n * @param interpolation An interpolation ast\n */\n\n\nfunction getInterpolationArgsLength(interpolation) {\n  var expressions = interpolation.expressions,\n      strings = interpolation.strings;\n\n  if (expressions.length === 1 && strings.length === 2 && strings[0] === '' && strings[1] === '') {\n    // If the interpolation has one interpolated value, but the prefix and suffix are both empty\n    // strings, we only pass one argument, to a special instruction like `propertyInterpolate` or\n    // `textInterpolate`.\n    return 1;\n  } else {\n    return expressions.length + strings.length;\n  }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar R3FactoryDelegateType;\n\n(function (R3FactoryDelegateType) {\n  R3FactoryDelegateType[R3FactoryDelegateType[\"Class\"] = 0] = \"Class\";\n  R3FactoryDelegateType[R3FactoryDelegateType[\"Function\"] = 1] = \"Function\";\n  R3FactoryDelegateType[R3FactoryDelegateType[\"Factory\"] = 2] = \"Factory\";\n})(R3FactoryDelegateType || (R3FactoryDelegateType = {}));\n\nvar R3FactoryTarget;\n\n(function (R3FactoryTarget) {\n  R3FactoryTarget[R3FactoryTarget[\"Directive\"] = 0] = \"Directive\";\n  R3FactoryTarget[R3FactoryTarget[\"Component\"] = 1] = \"Component\";\n  R3FactoryTarget[R3FactoryTarget[\"Injectable\"] = 2] = \"Injectable\";\n  R3FactoryTarget[R3FactoryTarget[\"Pipe\"] = 3] = \"Pipe\";\n  R3FactoryTarget[R3FactoryTarget[\"NgModule\"] = 4] = \"NgModule\";\n})(R3FactoryTarget || (R3FactoryTarget = {}));\n/**\n * Resolved type of a dependency.\n *\n * Occasionally, dependencies will have special significance which is known statically. In that\n * case the `R3ResolvedDependencyType` informs the factory generator that a particular dependency\n * should be generated specially (usually by calling a special injection function instead of the\n * standard one).\n */\n\n\nvar R3ResolvedDependencyType;\n\n(function (R3ResolvedDependencyType) {\n  /**\n   * A normal token dependency.\n   */\n  R3ResolvedDependencyType[R3ResolvedDependencyType[\"Token\"] = 0] = \"Token\";\n  /**\n   * The dependency is for an attribute.\n   *\n   * The token expression is a string representing the attribute name.\n   */\n\n  R3ResolvedDependencyType[R3ResolvedDependencyType[\"Attribute\"] = 1] = \"Attribute\";\n  /**\n   * Injecting the `ChangeDetectorRef` token. Needs special handling when injected into a pipe.\n   */\n\n  R3ResolvedDependencyType[R3ResolvedDependencyType[\"ChangeDetectorRef\"] = 2] = \"ChangeDetectorRef\";\n  /**\n   * An invalid dependency (no token could be determined). An error should be thrown at runtime.\n   */\n\n  R3ResolvedDependencyType[R3ResolvedDependencyType[\"Invalid\"] = 3] = \"Invalid\";\n})(R3ResolvedDependencyType || (R3ResolvedDependencyType = {}));\n/**\n * Construct a factory function expression for the given `R3FactoryMetadata`.\n */\n\n\nfunction compileFactoryFunction(meta) {\n  var t = variable('t');\n  var statements = [];\n  var ctorDepsType = NONE_TYPE; // The type to instantiate via constructor invocation. If there is no delegated factory, meaning\n  // this type is always created by constructor invocation, then this is the type-to-create\n  // parameter provided by the user (t) if specified, or the current type if not. If there is a\n  // delegated factory (which is used to create the current type) then this is only the type-to-\n  // create parameter (t).\n\n  var typeForCtor = !isDelegatedMetadata(meta) ? new BinaryOperatorExpr(BinaryOperator.Or, t, meta.internalType) : t;\n  var ctorExpr = null;\n\n  if (meta.deps !== null) {\n    // There is a constructor (either explicitly or implicitly defined).\n    if (meta.deps !== 'invalid') {\n      ctorExpr = new InstantiateExpr(typeForCtor, injectDependencies(meta.deps, meta.injectFn, meta.target === R3FactoryTarget.Pipe));\n      ctorDepsType = createCtorDepsType(meta.deps);\n    }\n  } else {\n    var baseFactory = variable(\"\\u0275\".concat(meta.name, \"_BaseFactory\"));\n    var getInheritedFactory = importExpr(Identifiers$1.getInheritedFactory);\n    var baseFactoryStmt = baseFactory.set(getInheritedFactory.callFn([meta.internalType])).toDeclStmt(INFERRED_TYPE, [StmtModifier.Exported, StmtModifier.Final]);\n    statements.push(baseFactoryStmt); // There is no constructor, use the base class' factory to construct typeForCtor.\n\n    ctorExpr = baseFactory.callFn([typeForCtor]);\n  }\n\n  var ctorExprFinal = ctorExpr;\n  var body = [];\n  var retExpr = null;\n\n  function makeConditionalFactory(nonCtorExpr) {\n    var r = variable('r');\n    body.push(r.set(NULL_EXPR).toDeclStmt());\n    var ctorStmt = null;\n\n    if (ctorExprFinal !== null) {\n      ctorStmt = r.set(ctorExprFinal).toStmt();\n    } else {\n      ctorStmt = importExpr(Identifiers$1.invalidFactory).callFn([]).toStmt();\n    }\n\n    body.push(ifStmt(t, [ctorStmt], [r.set(nonCtorExpr).toStmt()]));\n    return r;\n  }\n\n  if (isDelegatedMetadata(meta) && meta.delegateType === R3FactoryDelegateType.Factory) {\n    var delegateFactory = variable(\"\\u0275\".concat(meta.name, \"_BaseFactory\"));\n    var getFactoryOf = importExpr(Identifiers$1.getFactoryOf);\n\n    if (meta.delegate.isEquivalent(meta.internalType)) {\n      throw new Error(\"Illegal state: compiling factory that delegates to itself\");\n    }\n\n    var delegateFactoryStmt = delegateFactory.set(getFactoryOf.callFn([meta.delegate])).toDeclStmt(INFERRED_TYPE, [StmtModifier.Exported, StmtModifier.Final]);\n    statements.push(delegateFactoryStmt);\n    retExpr = makeConditionalFactory(delegateFactory.callFn([]));\n  } else if (isDelegatedMetadata(meta)) {\n    // This type is created with a delegated factory. If a type parameter is not specified, call\n    // the factory instead.\n    var delegateArgs = injectDependencies(meta.delegateDeps, meta.injectFn, meta.target === R3FactoryTarget.Pipe); // Either call `new delegate(...)` or `delegate(...)` depending on meta.delegateType.\n\n    var factoryExpr = new (meta.delegateType === R3FactoryDelegateType.Class ? InstantiateExpr : InvokeFunctionExpr)(meta.delegate, delegateArgs);\n    retExpr = makeConditionalFactory(factoryExpr);\n  } else if (isExpressionFactoryMetadata(meta)) {\n    // TODO(alxhub): decide whether to lower the value here or in the caller\n    retExpr = makeConditionalFactory(meta.expression);\n  } else {\n    retExpr = ctorExpr;\n  }\n\n  if (retExpr !== null) {\n    body.push(new ReturnStatement(retExpr));\n  } else {\n    body.push(importExpr(Identifiers$1.invalidFactory).callFn([]).toStmt());\n  }\n\n  return {\n    factory: fn([new FnParam('t', DYNAMIC_TYPE)], body, INFERRED_TYPE, undefined, \"\".concat(meta.name, \"_Factory\")),\n    statements: statements,\n    type: expressionType(importExpr(Identifiers$1.FactoryDef, [typeWithParameters(meta.type.type, meta.typeArgumentCount), ctorDepsType]))\n  };\n}\n\nfunction injectDependencies(deps, injectFn, isPipe) {\n  return deps.map(function (dep, index) {\n    return compileInjectDependency(dep, injectFn, isPipe, index);\n  });\n}\n\nfunction compileInjectDependency(dep, injectFn, isPipe, index) {\n  // Interpret the dependency according to its resolved type.\n  switch (dep.resolved) {\n    case R3ResolvedDependencyType.Token:\n    case R3ResolvedDependencyType.ChangeDetectorRef:\n      // Build up the injection flags according to the metadata.\n      var flags = 0\n      /* Default */\n      | (dep.self ? 2\n      /* Self */\n      : 0) | (dep.skipSelf ? 4\n      /* SkipSelf */\n      : 0) | (dep.host ? 1\n      /* Host */\n      : 0) | (dep.optional ? 8\n      /* Optional */\n      : 0); // If this dependency is optional or otherwise has non-default flags, then additional\n      // parameters describing how to inject the dependency must be passed to the inject function\n      // that's being used.\n\n      var flagsParam = flags !== 0\n      /* Default */\n      || dep.optional ? literal(flags) : null; // We have a separate instruction for injecting ChangeDetectorRef into a pipe.\n\n      if (isPipe && dep.resolved === R3ResolvedDependencyType.ChangeDetectorRef) {\n        return importExpr(Identifiers$1.injectPipeChangeDetectorRef).callFn(flagsParam ? [flagsParam] : []);\n      } // Build up the arguments to the injectFn call.\n\n\n      var injectArgs = [dep.token];\n\n      if (flagsParam) {\n        injectArgs.push(flagsParam);\n      }\n\n      return importExpr(injectFn).callFn(injectArgs);\n\n    case R3ResolvedDependencyType.Attribute:\n      // In the case of attributes, the attribute name in question is given as the token.\n      return importExpr(Identifiers$1.injectAttribute).callFn([dep.token]);\n\n    case R3ResolvedDependencyType.Invalid:\n      return importExpr(Identifiers$1.invalidFactoryDep).callFn([literal(index)]);\n\n    default:\n      return unsupported(\"Unknown R3ResolvedDependencyType: \".concat(R3ResolvedDependencyType[dep.resolved]));\n  }\n}\n\nfunction createCtorDepsType(deps) {\n  var hasTypes = false;\n  var attributeTypes = deps.map(function (dep) {\n    var type = createCtorDepType(dep);\n\n    if (type !== null) {\n      hasTypes = true;\n      return type;\n    } else {\n      return literal(null);\n    }\n  });\n\n  if (hasTypes) {\n    return expressionType(literalArr(attributeTypes));\n  } else {\n    return NONE_TYPE;\n  }\n}\n\nfunction createCtorDepType(dep) {\n  var entries = [];\n\n  if (dep.resolved === R3ResolvedDependencyType.Attribute) {\n    if (dep.attribute !== null) {\n      entries.push({\n        key: 'attribute',\n        value: dep.attribute,\n        quoted: false\n      });\n    }\n  }\n\n  if (dep.optional) {\n    entries.push({\n      key: 'optional',\n      value: literal(true),\n      quoted: false\n    });\n  }\n\n  if (dep.host) {\n    entries.push({\n      key: 'host',\n      value: literal(true),\n      quoted: false\n    });\n  }\n\n  if (dep.self) {\n    entries.push({\n      key: 'self',\n      value: literal(true),\n      quoted: false\n    });\n  }\n\n  if (dep.skipSelf) {\n    entries.push({\n      key: 'skipSelf',\n      value: literal(true),\n      quoted: false\n    });\n  }\n\n  return entries.length > 0 ? literalMap(entries) : null;\n}\n/**\n * A helper function useful for extracting `R3DependencyMetadata` from a Render2\n * `CompileTypeMetadata` instance.\n */\n\n\nfunction dependenciesFromGlobalMetadata(type, outputCtx, reflector) {\n  // Use the `CompileReflector` to look up references to some well-known Angular types. These will\n  // be compared with the token to statically determine whether the token has significance to\n  // Angular, and set the correct `R3ResolvedDependencyType` as a result.\n  var injectorRef = reflector.resolveExternalReference(Identifiers.Injector); // Iterate through the type's DI dependencies and produce `R3DependencyMetadata` for each of them.\n\n  var deps = [];\n\n  var _iterator5 = _createForOfIteratorHelper(type.diDeps),\n      _step5;\n\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var dependency = _step5.value;\n\n      if (dependency.token) {\n        var tokenRef = tokenReference(dependency.token);\n        var resolved = dependency.isAttribute ? R3ResolvedDependencyType.Attribute : R3ResolvedDependencyType.Token; // In the case of most dependencies, the token will be a reference to a type. Sometimes,\n        // however, it can be a string, in the case of older Angular code or @Attribute injection.\n\n        var token = tokenRef instanceof StaticSymbol ? outputCtx.importExpr(tokenRef) : literal(tokenRef); // Construct the dependency.\n\n        deps.push({\n          token: token,\n          attribute: null,\n          resolved: resolved,\n          host: !!dependency.isHost,\n          optional: !!dependency.isOptional,\n          self: !!dependency.isSelf,\n          skipSelf: !!dependency.isSkipSelf\n        });\n      } else {\n        unsupported('dependency without a token');\n      }\n    }\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n\n  return deps;\n}\n\nfunction isDelegatedMetadata(meta) {\n  return meta.delegateType !== undefined;\n}\n\nfunction isExpressionFactoryMetadata(meta) {\n  return meta.expression !== undefined;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction _compileInjectable(meta) {\n  var result = null;\n  var factoryMeta = {\n    name: meta.name,\n    type: meta.type,\n    internalType: meta.internalType,\n    typeArgumentCount: meta.typeArgumentCount,\n    deps: [],\n    injectFn: Identifiers.inject,\n    target: R3FactoryTarget.Injectable\n  };\n\n  if (meta.useClass !== undefined) {\n    // meta.useClass has two modes of operation. Either deps are specified, in which case `new` is\n    // used to instantiate the class with dependencies injected, or deps are not specified and\n    // the factory of the class is used to instantiate it.\n    //\n    // A special case exists for useClass: Type where Type is the injectable type itself and no\n    // deps are specified, in which case 'useClass' is effectively ignored.\n    var useClassOnSelf = meta.useClass.isEquivalent(meta.internalType);\n    var deps = undefined;\n\n    if (meta.userDeps !== undefined) {\n      deps = meta.userDeps;\n    }\n\n    if (deps !== undefined) {\n      // factory: () => new meta.useClass(...deps)\n      result = compileFactoryFunction(Object.assign(Object.assign({}, factoryMeta), {\n        delegate: meta.useClass,\n        delegateDeps: deps,\n        delegateType: R3FactoryDelegateType.Class\n      }));\n    } else if (useClassOnSelf) {\n      result = compileFactoryFunction(factoryMeta);\n    } else {\n      result = delegateToFactory(meta.type.value, meta.useClass);\n    }\n  } else if (meta.useFactory !== undefined) {\n    if (meta.userDeps !== undefined) {\n      result = compileFactoryFunction(Object.assign(Object.assign({}, factoryMeta), {\n        delegate: meta.useFactory,\n        delegateDeps: meta.userDeps || [],\n        delegateType: R3FactoryDelegateType.Function\n      }));\n    } else {\n      result = {\n        statements: [],\n        factory: fn([], [new ReturnStatement(meta.useFactory.callFn([]))])\n      };\n    }\n  } else if (meta.useValue !== undefined) {\n    // Note: it's safe to use `meta.useValue` instead of the `USE_VALUE in meta` check used for\n    // client code because meta.useValue is an Expression which will be defined even if the actual\n    // value is undefined.\n    result = compileFactoryFunction(Object.assign(Object.assign({}, factoryMeta), {\n      expression: meta.useValue\n    }));\n  } else if (meta.useExisting !== undefined) {\n    // useExisting is an `inject` call on the existing token.\n    result = compileFactoryFunction(Object.assign(Object.assign({}, factoryMeta), {\n      expression: importExpr(Identifiers.inject).callFn([meta.useExisting])\n    }));\n  } else {\n    result = delegateToFactory(meta.type.value, meta.internalType);\n  }\n\n  var token = meta.internalType;\n  var injectableProps = {\n    token: token,\n    factory: result.factory\n  }; // Only generate providedIn property if it has a non-null value\n\n  if (meta.providedIn.value !== null) {\n    injectableProps.providedIn = meta.providedIn;\n  }\n\n  var expression = importExpr(Identifiers.ɵɵdefineInjectable).callFn([mapToMapExpression(injectableProps)]);\n  var type = new ExpressionType(importExpr(Identifiers.InjectableDef, [typeWithParameters(meta.type.type, meta.typeArgumentCount)]));\n  return {\n    expression: expression,\n    type: type,\n    statements: result.statements\n  };\n}\n\nfunction delegateToFactory(type, internalType) {\n  return {\n    statements: [],\n    // If types are the same, we can generate `factory: type.ɵfac`\n    // If types are different, we have to generate a wrapper function to ensure\n    // the internal type has been resolved (`factory: function(t) { return type.ɵfac(t); }`)\n    factory: type.node === internalType.node ? internalType.prop('ɵfac') : fn([new FnParam('t', DYNAMIC_TYPE)], [new ReturnStatement(internalType.callMethod('ɵfac', [variable('t')]))])\n  };\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction assertArrayOfStrings(identifier, value) {\n  if (value == null) {\n    return;\n  }\n\n  if (!Array.isArray(value)) {\n    throw new Error(\"Expected '\".concat(identifier, \"' to be an array of strings.\"));\n  }\n\n  for (var i = 0; i < value.length; i += 1) {\n    if (typeof value[i] !== 'string') {\n      throw new Error(\"Expected '\".concat(identifier, \"' to be an array of strings.\"));\n    }\n  }\n}\n\nvar UNUSABLE_INTERPOLATION_REGEXPS = [/^\\s*$/, /[<>]/, /^[{}]$/, /&(#|[a-z])/i, /^\\/\\//];\n\nfunction assertInterpolationSymbols(identifier, value) {\n  if (value != null && !(Array.isArray(value) && value.length == 2)) {\n    throw new Error(\"Expected '\".concat(identifier, \"' to be an array, [start, end].\"));\n  } else if (value != null) {\n    var start = value[0];\n    var end = value[1]; // Check for unusable interpolation symbols\n\n    UNUSABLE_INTERPOLATION_REGEXPS.forEach(function (regexp) {\n      if (regexp.test(start) || regexp.test(end)) {\n        throw new Error(\"['\".concat(start, \"', '\").concat(end, \"'] contains unusable interpolation symbol.\"));\n      }\n    });\n  }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar InterpolationConfig = /*#__PURE__*/function () {\n  function InterpolationConfig(start, end) {\n    _classCallCheck(this, InterpolationConfig);\n\n    this.start = start;\n    this.end = end;\n  }\n\n  _createClass(InterpolationConfig, null, [{\n    key: \"fromArray\",\n    value: function fromArray(markers) {\n      if (!markers) {\n        return DEFAULT_INTERPOLATION_CONFIG;\n      }\n\n      assertInterpolationSymbols('interpolation', markers);\n      return new InterpolationConfig(markers[0], markers[1]);\n    }\n  }]);\n\n  return InterpolationConfig;\n}();\n\nvar DEFAULT_INTERPOLATION_CONFIG = new InterpolationConfig('{{', '}}');\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit\n\nvar VERSION = 3;\nvar JS_B64_PREFIX = '# sourceMappingURL=data:application/json;base64,';\n\nvar SourceMapGenerator = /*#__PURE__*/function () {\n  function SourceMapGenerator() {\n    var file = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n    _classCallCheck(this, SourceMapGenerator);\n\n    this.file = file;\n    this.sourcesContent = new Map();\n    this.lines = [];\n    this.lastCol0 = 0;\n    this.hasMappings = false;\n  } // The content is `null` when the content is expected to be loaded using the URL\n\n\n  _createClass(SourceMapGenerator, [{\n    key: \"addSource\",\n    value: function addSource(url) {\n      var content = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      if (!this.sourcesContent.has(url)) {\n        this.sourcesContent.set(url, content);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"addLine\",\n    value: function addLine() {\n      this.lines.push([]);\n      this.lastCol0 = 0;\n      return this;\n    }\n  }, {\n    key: \"addMapping\",\n    value: function addMapping(col0, sourceUrl, sourceLine0, sourceCol0) {\n      if (!this.currentLine) {\n        throw new Error(\"A line must be added before mappings can be added\");\n      }\n\n      if (sourceUrl != null && !this.sourcesContent.has(sourceUrl)) {\n        throw new Error(\"Unknown source file \\\"\".concat(sourceUrl, \"\\\"\"));\n      }\n\n      if (col0 == null) {\n        throw new Error(\"The column in the generated code must be provided\");\n      }\n\n      if (col0 < this.lastCol0) {\n        throw new Error(\"Mapping should be added in output order\");\n      }\n\n      if (sourceUrl && (sourceLine0 == null || sourceCol0 == null)) {\n        throw new Error(\"The source location must be provided when a source url is provided\");\n      }\n\n      this.hasMappings = true;\n      this.lastCol0 = col0;\n      this.currentLine.push({\n        col0: col0,\n        sourceUrl: sourceUrl,\n        sourceLine0: sourceLine0,\n        sourceCol0: sourceCol0\n      });\n      return this;\n    }\n    /**\n     * @internal strip this from published d.ts files due to\n     * https://github.com/microsoft/TypeScript/issues/36216\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var _this79 = this;\n\n      if (!this.hasMappings) {\n        return null;\n      }\n\n      var sourcesIndex = new Map();\n      var sources = [];\n      var sourcesContent = [];\n      Array.from(this.sourcesContent.keys()).forEach(function (url, i) {\n        sourcesIndex.set(url, i);\n        sources.push(url);\n        sourcesContent.push(_this79.sourcesContent.get(url) || null);\n      });\n      var mappings = '';\n      var lastCol0 = 0;\n      var lastSourceIndex = 0;\n      var lastSourceLine0 = 0;\n      var lastSourceCol0 = 0;\n      this.lines.forEach(function (segments) {\n        lastCol0 = 0;\n        mappings += segments.map(function (segment) {\n          // zero-based starting column of the line in the generated code\n          var segAsStr = toBase64VLQ(segment.col0 - lastCol0);\n          lastCol0 = segment.col0;\n\n          if (segment.sourceUrl != null) {\n            // zero-based index into the “sources” list\n            segAsStr += toBase64VLQ(sourcesIndex.get(segment.sourceUrl) - lastSourceIndex);\n            lastSourceIndex = sourcesIndex.get(segment.sourceUrl); // the zero-based starting line in the original source\n\n            segAsStr += toBase64VLQ(segment.sourceLine0 - lastSourceLine0);\n            lastSourceLine0 = segment.sourceLine0; // the zero-based starting column in the original source\n\n            segAsStr += toBase64VLQ(segment.sourceCol0 - lastSourceCol0);\n            lastSourceCol0 = segment.sourceCol0;\n          }\n\n          return segAsStr;\n        }).join(',');\n        mappings += ';';\n      });\n      mappings = mappings.slice(0, -1);\n      return {\n        'file': this.file || '',\n        'version': VERSION,\n        'sourceRoot': '',\n        'sources': sources,\n        'sourcesContent': sourcesContent,\n        'mappings': mappings\n      };\n    }\n  }, {\n    key: \"toJsComment\",\n    value: function toJsComment() {\n      return this.hasMappings ? '//' + JS_B64_PREFIX + toBase64String(JSON.stringify(this, null, 0)) : '';\n    }\n  }, {\n    key: \"currentLine\",\n    get: function get() {\n      return this.lines.slice(-1)[0];\n    }\n  }]);\n\n  return SourceMapGenerator;\n}();\n\nfunction toBase64String(value) {\n  var b64 = '';\n  value = utf8Encode(value);\n\n  for (var i = 0; i < value.length;) {\n    var i1 = value.charCodeAt(i++);\n    var i2 = value.charCodeAt(i++);\n    var i3 = value.charCodeAt(i++);\n    b64 += toBase64Digit(i1 >> 2);\n    b64 += toBase64Digit((i1 & 3) << 4 | (isNaN(i2) ? 0 : i2 >> 4));\n    b64 += isNaN(i2) ? '=' : toBase64Digit((i2 & 15) << 2 | i3 >> 6);\n    b64 += isNaN(i2) || isNaN(i3) ? '=' : toBase64Digit(i3 & 63);\n  }\n\n  return b64;\n}\n\nfunction toBase64VLQ(value) {\n  value = value < 0 ? (-value << 1) + 1 : value << 1;\n  var out = '';\n\n  do {\n    var digit = value & 31;\n    value = value >> 5;\n\n    if (value > 0) {\n      digit = digit | 32;\n    }\n\n    out += toBase64Digit(digit);\n  } while (value > 0);\n\n  return out;\n}\n\nvar B64_DIGITS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\nfunction toBase64Digit(value) {\n  if (value < 0 || value >= 64) {\n    throw new Error(\"Can only encode value in the range [0, 63]\");\n  }\n\n  return B64_DIGITS[value];\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar _SINGLE_QUOTE_ESCAPE_STRING_RE = /'|\\\\|\\n|\\r|\\$/g;\nvar _LEGAL_IDENTIFIER_RE = /^[$A-Z_][0-9A-Z_$]*$/i;\nvar _INDENT_WITH = '  ';\nvar CATCH_ERROR_VAR$1 = variable('error', null, null);\nvar CATCH_STACK_VAR$1 = variable('stack', null, null);\n\nvar _EmittedLine = function _EmittedLine(indent) {\n  _classCallCheck(this, _EmittedLine);\n\n  this.indent = indent;\n  this.partsLength = 0;\n  this.parts = [];\n  this.srcSpans = [];\n};\n\nvar EmitterVisitorContext = /*#__PURE__*/function () {\n  function EmitterVisitorContext(_indent) {\n    _classCallCheck(this, EmitterVisitorContext);\n\n    this._indent = _indent;\n    this._classes = [];\n    this._preambleLineCount = 0;\n    this._lines = [new _EmittedLine(_indent)];\n  }\n\n  _createClass(EmitterVisitorContext, [{\n    key: \"println\",\n    value: function println(from) {\n      var lastPart = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n      this.print(from || null, lastPart, true);\n    }\n  }, {\n    key: \"lineIsEmpty\",\n    value: function lineIsEmpty() {\n      return this._currentLine.parts.length === 0;\n    }\n  }, {\n    key: \"lineLength\",\n    value: function lineLength() {\n      return this._currentLine.indent * _INDENT_WITH.length + this._currentLine.partsLength;\n    }\n  }, {\n    key: \"print\",\n    value: function print(from, part) {\n      var newLine = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      if (part.length > 0) {\n        this._currentLine.parts.push(part);\n\n        this._currentLine.partsLength += part.length;\n\n        this._currentLine.srcSpans.push(from && from.sourceSpan || null);\n      }\n\n      if (newLine) {\n        this._lines.push(new _EmittedLine(this._indent));\n      }\n    }\n  }, {\n    key: \"removeEmptyLastLine\",\n    value: function removeEmptyLastLine() {\n      if (this.lineIsEmpty()) {\n        this._lines.pop();\n      }\n    }\n  }, {\n    key: \"incIndent\",\n    value: function incIndent() {\n      this._indent++;\n\n      if (this.lineIsEmpty()) {\n        this._currentLine.indent = this._indent;\n      }\n    }\n  }, {\n    key: \"decIndent\",\n    value: function decIndent() {\n      this._indent--;\n\n      if (this.lineIsEmpty()) {\n        this._currentLine.indent = this._indent;\n      }\n    }\n  }, {\n    key: \"pushClass\",\n    value: function pushClass(clazz) {\n      this._classes.push(clazz);\n    }\n  }, {\n    key: \"popClass\",\n    value: function popClass() {\n      return this._classes.pop();\n    }\n  }, {\n    key: \"toSource\",\n    value: function toSource() {\n      return this.sourceLines.map(function (l) {\n        return l.parts.length > 0 ? _createIndent(l.indent) + l.parts.join('') : '';\n      }).join('\\n');\n    }\n  }, {\n    key: \"toSourceMapGenerator\",\n    value: function toSourceMapGenerator(genFilePath) {\n      var startsAtLine = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var map = new SourceMapGenerator(genFilePath);\n      var firstOffsetMapped = false;\n\n      var mapFirstOffsetIfNeeded = function mapFirstOffsetIfNeeded() {\n        if (!firstOffsetMapped) {\n          // Add a single space so that tools won't try to load the file from disk.\n          // Note: We are using virtual urls like `ng:///`, so we have to\n          // provide a content here.\n          map.addSource(genFilePath, ' ').addMapping(0, genFilePath, 0, 0);\n          firstOffsetMapped = true;\n        }\n      };\n\n      for (var i = 0; i < startsAtLine; i++) {\n        map.addLine();\n        mapFirstOffsetIfNeeded();\n      }\n\n      this.sourceLines.forEach(function (line, lineIdx) {\n        map.addLine();\n        var spans = line.srcSpans;\n        var parts = line.parts;\n        var col0 = line.indent * _INDENT_WITH.length;\n        var spanIdx = 0; // skip leading parts without source spans\n\n        while (spanIdx < spans.length && !spans[spanIdx]) {\n          col0 += parts[spanIdx].length;\n          spanIdx++;\n        }\n\n        if (spanIdx < spans.length && lineIdx === 0 && col0 === 0) {\n          firstOffsetMapped = true;\n        } else {\n          mapFirstOffsetIfNeeded();\n        }\n\n        while (spanIdx < spans.length) {\n          var span = spans[spanIdx];\n          var source = span.start.file;\n          var sourceLine = span.start.line;\n          var sourceCol = span.start.col;\n          map.addSource(source.url, source.content).addMapping(col0, source.url, sourceLine, sourceCol);\n          col0 += parts[spanIdx].length;\n          spanIdx++; // assign parts without span or the same span to the previous segment\n\n          while (spanIdx < spans.length && (span === spans[spanIdx] || !spans[spanIdx])) {\n            col0 += parts[spanIdx].length;\n            spanIdx++;\n          }\n        }\n      });\n      return map;\n    }\n  }, {\n    key: \"setPreambleLineCount\",\n    value: function setPreambleLineCount(count) {\n      return this._preambleLineCount = count;\n    }\n  }, {\n    key: \"spanOf\",\n    value: function spanOf(line, column) {\n      var emittedLine = this._lines[line - this._preambleLineCount];\n\n      if (emittedLine) {\n        var columnsLeft = column - _createIndent(emittedLine.indent).length;\n\n        for (var partIndex = 0; partIndex < emittedLine.parts.length; partIndex++) {\n          var part = emittedLine.parts[partIndex];\n\n          if (part.length > columnsLeft) {\n            return emittedLine.srcSpans[partIndex];\n          }\n\n          columnsLeft -= part.length;\n        }\n      }\n\n      return null;\n    }\n    /**\n     * @internal strip this from published d.ts files due to\n     * https://github.com/microsoft/TypeScript/issues/36216\n     */\n\n  }, {\n    key: \"_currentLine\",\n\n    /**\n     * @internal strip this from published d.ts files due to\n     * https://github.com/microsoft/TypeScript/issues/36216\n     */\n    get: function get() {\n      return this._lines[this._lines.length - 1];\n    }\n  }, {\n    key: \"currentClass\",\n    get: function get() {\n      return this._classes.length > 0 ? this._classes[this._classes.length - 1] : null;\n    }\n  }, {\n    key: \"sourceLines\",\n    get: function get() {\n      if (this._lines.length && this._lines[this._lines.length - 1].parts.length === 0) {\n        return this._lines.slice(0, -1);\n      }\n\n      return this._lines;\n    }\n  }], [{\n    key: \"createRoot\",\n    value: function createRoot() {\n      return new EmitterVisitorContext(0);\n    }\n  }]);\n\n  return EmitterVisitorContext;\n}();\n\nvar AbstractEmitterVisitor = /*#__PURE__*/function () {\n  function AbstractEmitterVisitor(_escapeDollarInStrings) {\n    _classCallCheck(this, AbstractEmitterVisitor);\n\n    this._escapeDollarInStrings = _escapeDollarInStrings;\n  }\n\n  _createClass(AbstractEmitterVisitor, [{\n    key: \"visitExpressionStmt\",\n    value: function visitExpressionStmt(stmt, ctx) {\n      stmt.expr.visitExpression(this, ctx);\n      ctx.println(stmt, ';');\n      return null;\n    }\n  }, {\n    key: \"visitReturnStmt\",\n    value: function visitReturnStmt(stmt, ctx) {\n      ctx.print(stmt, \"return \");\n      stmt.value.visitExpression(this, ctx);\n      ctx.println(stmt, ';');\n      return null;\n    }\n  }, {\n    key: \"visitIfStmt\",\n    value: function visitIfStmt(stmt, ctx) {\n      ctx.print(stmt, \"if (\");\n      stmt.condition.visitExpression(this, ctx);\n      ctx.print(stmt, \") {\");\n      var hasElseCase = stmt.falseCase != null && stmt.falseCase.length > 0;\n\n      if (stmt.trueCase.length <= 1 && !hasElseCase) {\n        ctx.print(stmt, \" \");\n        this.visitAllStatements(stmt.trueCase, ctx);\n        ctx.removeEmptyLastLine();\n        ctx.print(stmt, \" \");\n      } else {\n        ctx.println();\n        ctx.incIndent();\n        this.visitAllStatements(stmt.trueCase, ctx);\n        ctx.decIndent();\n\n        if (hasElseCase) {\n          ctx.println(stmt, \"} else {\");\n          ctx.incIndent();\n          this.visitAllStatements(stmt.falseCase, ctx);\n          ctx.decIndent();\n        }\n      }\n\n      ctx.println(stmt, \"}\");\n      return null;\n    }\n  }, {\n    key: \"visitThrowStmt\",\n    value: function visitThrowStmt(stmt, ctx) {\n      ctx.print(stmt, \"throw \");\n      stmt.error.visitExpression(this, ctx);\n      ctx.println(stmt, \";\");\n      return null;\n    }\n  }, {\n    key: \"visitCommentStmt\",\n    value: function visitCommentStmt(stmt, ctx) {\n      if (stmt.multiline) {\n        ctx.println(stmt, \"/* \".concat(stmt.comment, \" */\"));\n      } else {\n        stmt.comment.split('\\n').forEach(function (line) {\n          ctx.println(stmt, \"// \".concat(line));\n        });\n      }\n\n      return null;\n    }\n  }, {\n    key: \"visitJSDocCommentStmt\",\n    value: function visitJSDocCommentStmt(stmt, ctx) {\n      ctx.println(stmt, \"/*\".concat(stmt.toString(), \"*/\"));\n      return null;\n    }\n  }, {\n    key: \"visitWriteVarExpr\",\n    value: function visitWriteVarExpr(expr, ctx) {\n      var lineWasEmpty = ctx.lineIsEmpty();\n\n      if (!lineWasEmpty) {\n        ctx.print(expr, '(');\n      }\n\n      ctx.print(expr, \"\".concat(expr.name, \" = \"));\n      expr.value.visitExpression(this, ctx);\n\n      if (!lineWasEmpty) {\n        ctx.print(expr, ')');\n      }\n\n      return null;\n    }\n  }, {\n    key: \"visitWriteKeyExpr\",\n    value: function visitWriteKeyExpr(expr, ctx) {\n      var lineWasEmpty = ctx.lineIsEmpty();\n\n      if (!lineWasEmpty) {\n        ctx.print(expr, '(');\n      }\n\n      expr.receiver.visitExpression(this, ctx);\n      ctx.print(expr, \"[\");\n      expr.index.visitExpression(this, ctx);\n      ctx.print(expr, \"] = \");\n      expr.value.visitExpression(this, ctx);\n\n      if (!lineWasEmpty) {\n        ctx.print(expr, ')');\n      }\n\n      return null;\n    }\n  }, {\n    key: \"visitWritePropExpr\",\n    value: function visitWritePropExpr(expr, ctx) {\n      var lineWasEmpty = ctx.lineIsEmpty();\n\n      if (!lineWasEmpty) {\n        ctx.print(expr, '(');\n      }\n\n      expr.receiver.visitExpression(this, ctx);\n      ctx.print(expr, \".\".concat(expr.name, \" = \"));\n      expr.value.visitExpression(this, ctx);\n\n      if (!lineWasEmpty) {\n        ctx.print(expr, ')');\n      }\n\n      return null;\n    }\n  }, {\n    key: \"visitInvokeMethodExpr\",\n    value: function visitInvokeMethodExpr(expr, ctx) {\n      expr.receiver.visitExpression(this, ctx);\n      var name = expr.name;\n\n      if (expr.builtin != null) {\n        name = this.getBuiltinMethodName(expr.builtin);\n\n        if (name == null) {\n          // some builtins just mean to skip the call.\n          return null;\n        }\n      }\n\n      ctx.print(expr, \".\".concat(name, \"(\"));\n      this.visitAllExpressions(expr.args, ctx, \",\");\n      ctx.print(expr, \")\");\n      return null;\n    }\n  }, {\n    key: \"visitInvokeFunctionExpr\",\n    value: function visitInvokeFunctionExpr(expr, ctx) {\n      expr.fn.visitExpression(this, ctx);\n      ctx.print(expr, \"(\");\n      this.visitAllExpressions(expr.args, ctx, ',');\n      ctx.print(expr, \")\");\n      return null;\n    }\n  }, {\n    key: \"visitWrappedNodeExpr\",\n    value: function visitWrappedNodeExpr(ast, ctx) {\n      throw new Error('Abstract emitter cannot visit WrappedNodeExpr.');\n    }\n  }, {\n    key: \"visitTypeofExpr\",\n    value: function visitTypeofExpr(expr, ctx) {\n      ctx.print(expr, 'typeof ');\n      expr.expr.visitExpression(this, ctx);\n    }\n  }, {\n    key: \"visitReadVarExpr\",\n    value: function visitReadVarExpr(ast, ctx) {\n      var varName = ast.name;\n\n      if (ast.builtin != null) {\n        switch (ast.builtin) {\n          case BuiltinVar.Super:\n            varName = 'super';\n            break;\n\n          case BuiltinVar.This:\n            varName = 'this';\n            break;\n\n          case BuiltinVar.CatchError:\n            varName = CATCH_ERROR_VAR$1.name;\n            break;\n\n          case BuiltinVar.CatchStack:\n            varName = CATCH_STACK_VAR$1.name;\n            break;\n\n          default:\n            throw new Error(\"Unknown builtin variable \".concat(ast.builtin));\n        }\n      }\n\n      ctx.print(ast, varName);\n      return null;\n    }\n  }, {\n    key: \"visitInstantiateExpr\",\n    value: function visitInstantiateExpr(ast, ctx) {\n      ctx.print(ast, \"new \");\n      ast.classExpr.visitExpression(this, ctx);\n      ctx.print(ast, \"(\");\n      this.visitAllExpressions(ast.args, ctx, ',');\n      ctx.print(ast, \")\");\n      return null;\n    }\n  }, {\n    key: \"visitLiteralExpr\",\n    value: function visitLiteralExpr(ast, ctx) {\n      var value = ast.value;\n\n      if (typeof value === 'string') {\n        ctx.print(ast, escapeIdentifier(value, this._escapeDollarInStrings));\n      } else {\n        ctx.print(ast, \"\".concat(value));\n      }\n\n      return null;\n    }\n  }, {\n    key: \"visitLocalizedString\",\n    value: function visitLocalizedString(ast, ctx) {\n      var head = ast.serializeI18nHead();\n      ctx.print(ast, '$localize `' + head.raw);\n\n      for (var i = 1; i < ast.messageParts.length; i++) {\n        ctx.print(ast, '${');\n        ast.expressions[i - 1].visitExpression(this, ctx);\n        ctx.print(ast, \"}\".concat(ast.serializeI18nTemplatePart(i).raw));\n      }\n\n      ctx.print(ast, '`');\n      return null;\n    }\n  }, {\n    key: \"visitConditionalExpr\",\n    value: function visitConditionalExpr(ast, ctx) {\n      ctx.print(ast, \"(\");\n      ast.condition.visitExpression(this, ctx);\n      ctx.print(ast, '? ');\n      ast.trueCase.visitExpression(this, ctx);\n      ctx.print(ast, ': ');\n      ast.falseCase.visitExpression(this, ctx);\n      ctx.print(ast, \")\");\n      return null;\n    }\n  }, {\n    key: \"visitNotExpr\",\n    value: function visitNotExpr(ast, ctx) {\n      ctx.print(ast, '!');\n      ast.condition.visitExpression(this, ctx);\n      return null;\n    }\n  }, {\n    key: \"visitAssertNotNullExpr\",\n    value: function visitAssertNotNullExpr(ast, ctx) {\n      ast.condition.visitExpression(this, ctx);\n      return null;\n    }\n  }, {\n    key: \"visitBinaryOperatorExpr\",\n    value: function visitBinaryOperatorExpr(ast, ctx) {\n      var opStr;\n\n      switch (ast.operator) {\n        case BinaryOperator.Equals:\n          opStr = '==';\n          break;\n\n        case BinaryOperator.Identical:\n          opStr = '===';\n          break;\n\n        case BinaryOperator.NotEquals:\n          opStr = '!=';\n          break;\n\n        case BinaryOperator.NotIdentical:\n          opStr = '!==';\n          break;\n\n        case BinaryOperator.And:\n          opStr = '&&';\n          break;\n\n        case BinaryOperator.BitwiseAnd:\n          opStr = '&';\n          break;\n\n        case BinaryOperator.Or:\n          opStr = '||';\n          break;\n\n        case BinaryOperator.Plus:\n          opStr = '+';\n          break;\n\n        case BinaryOperator.Minus:\n          opStr = '-';\n          break;\n\n        case BinaryOperator.Divide:\n          opStr = '/';\n          break;\n\n        case BinaryOperator.Multiply:\n          opStr = '*';\n          break;\n\n        case BinaryOperator.Modulo:\n          opStr = '%';\n          break;\n\n        case BinaryOperator.Lower:\n          opStr = '<';\n          break;\n\n        case BinaryOperator.LowerEquals:\n          opStr = '<=';\n          break;\n\n        case BinaryOperator.Bigger:\n          opStr = '>';\n          break;\n\n        case BinaryOperator.BiggerEquals:\n          opStr = '>=';\n          break;\n\n        default:\n          throw new Error(\"Unknown operator \".concat(ast.operator));\n      }\n\n      if (ast.parens) ctx.print(ast, \"(\");\n      ast.lhs.visitExpression(this, ctx);\n      ctx.print(ast, \" \".concat(opStr, \" \"));\n      ast.rhs.visitExpression(this, ctx);\n      if (ast.parens) ctx.print(ast, \")\");\n      return null;\n    }\n  }, {\n    key: \"visitReadPropExpr\",\n    value: function visitReadPropExpr(ast, ctx) {\n      ast.receiver.visitExpression(this, ctx);\n      ctx.print(ast, \".\");\n      ctx.print(ast, ast.name);\n      return null;\n    }\n  }, {\n    key: \"visitReadKeyExpr\",\n    value: function visitReadKeyExpr(ast, ctx) {\n      ast.receiver.visitExpression(this, ctx);\n      ctx.print(ast, \"[\");\n      ast.index.visitExpression(this, ctx);\n      ctx.print(ast, \"]\");\n      return null;\n    }\n  }, {\n    key: \"visitLiteralArrayExpr\",\n    value: function visitLiteralArrayExpr(ast, ctx) {\n      ctx.print(ast, \"[\");\n      this.visitAllExpressions(ast.entries, ctx, ',');\n      ctx.print(ast, \"]\");\n      return null;\n    }\n  }, {\n    key: \"visitLiteralMapExpr\",\n    value: function visitLiteralMapExpr(ast, ctx) {\n      var _this80 = this;\n\n      ctx.print(ast, \"{\");\n      this.visitAllObjects(function (entry) {\n        ctx.print(ast, \"\".concat(escapeIdentifier(entry.key, _this80._escapeDollarInStrings, entry.quoted), \":\"));\n        entry.value.visitExpression(_this80, ctx);\n      }, ast.entries, ctx, ',');\n      ctx.print(ast, \"}\");\n      return null;\n    }\n  }, {\n    key: \"visitCommaExpr\",\n    value: function visitCommaExpr(ast, ctx) {\n      ctx.print(ast, '(');\n      this.visitAllExpressions(ast.parts, ctx, ',');\n      ctx.print(ast, ')');\n      return null;\n    }\n  }, {\n    key: \"visitAllExpressions\",\n    value: function visitAllExpressions(expressions, ctx, separator) {\n      var _this81 = this;\n\n      this.visitAllObjects(function (expr) {\n        return expr.visitExpression(_this81, ctx);\n      }, expressions, ctx, separator);\n    }\n  }, {\n    key: \"visitAllObjects\",\n    value: function visitAllObjects(handler, expressions, ctx, separator) {\n      var incrementedIndent = false;\n\n      for (var i = 0; i < expressions.length; i++) {\n        if (i > 0) {\n          if (ctx.lineLength() > 80) {\n            ctx.print(null, separator, true);\n\n            if (!incrementedIndent) {\n              // continuation are marked with double indent.\n              ctx.incIndent();\n              ctx.incIndent();\n              incrementedIndent = true;\n            }\n          } else {\n            ctx.print(null, separator, false);\n          }\n        }\n\n        handler(expressions[i]);\n      }\n\n      if (incrementedIndent) {\n        // continuation are marked with double indent.\n        ctx.decIndent();\n        ctx.decIndent();\n      }\n    }\n  }, {\n    key: \"visitAllStatements\",\n    value: function visitAllStatements(statements, ctx) {\n      var _this82 = this;\n\n      statements.forEach(function (stmt) {\n        return stmt.visitStatement(_this82, ctx);\n      });\n    }\n  }]);\n\n  return AbstractEmitterVisitor;\n}();\n\nfunction escapeIdentifier(input, escapeDollar) {\n  var alwaysQuote = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n  if (input == null) {\n    return null;\n  }\n\n  var body = input.replace(_SINGLE_QUOTE_ESCAPE_STRING_RE, function () {\n    if ((arguments.length <= 0 ? undefined : arguments[0]) == '$') {\n      return escapeDollar ? '\\\\$' : '$';\n    } else if ((arguments.length <= 0 ? undefined : arguments[0]) == '\\n') {\n      return '\\\\n';\n    } else if ((arguments.length <= 0 ? undefined : arguments[0]) == '\\r') {\n      return '\\\\r';\n    } else {\n      return \"\\\\\".concat(arguments.length <= 0 ? undefined : arguments[0]);\n    }\n  });\n  var requiresQuotes = alwaysQuote || !_LEGAL_IDENTIFIER_RE.test(body);\n  return requiresQuotes ? \"'\".concat(body, \"'\") : body;\n}\n\nfunction _createIndent(count) {\n  var res = '';\n\n  for (var i = 0; i < count; i++) {\n    res += _INDENT_WITH;\n  }\n\n  return res;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar AbstractJsEmitterVisitor = /*#__PURE__*/function (_AbstractEmitterVisit) {\n  _inherits(AbstractJsEmitterVisitor, _AbstractEmitterVisit);\n\n  var _super49 = _createSuper(AbstractJsEmitterVisitor);\n\n  function AbstractJsEmitterVisitor() {\n    _classCallCheck(this, AbstractJsEmitterVisitor);\n\n    return _super49.call(this, false);\n  }\n\n  _createClass(AbstractJsEmitterVisitor, [{\n    key: \"visitDeclareClassStmt\",\n    value: function visitDeclareClassStmt(stmt, ctx) {\n      var _this83 = this;\n\n      ctx.pushClass(stmt);\n\n      this._visitClassConstructor(stmt, ctx);\n\n      if (stmt.parent != null) {\n        ctx.print(stmt, \"\".concat(stmt.name, \".prototype = Object.create(\"));\n        stmt.parent.visitExpression(this, ctx);\n        ctx.println(stmt, \".prototype);\");\n      }\n\n      stmt.getters.forEach(function (getter) {\n        return _this83._visitClassGetter(stmt, getter, ctx);\n      });\n      stmt.methods.forEach(function (method) {\n        return _this83._visitClassMethod(stmt, method, ctx);\n      });\n      ctx.popClass();\n      return null;\n    }\n  }, {\n    key: \"_visitClassConstructor\",\n    value: function _visitClassConstructor(stmt, ctx) {\n      ctx.print(stmt, \"function \".concat(stmt.name, \"(\"));\n\n      if (stmt.constructorMethod != null) {\n        this._visitParams(stmt.constructorMethod.params, ctx);\n      }\n\n      ctx.println(stmt, \") {\");\n      ctx.incIndent();\n\n      if (stmt.constructorMethod != null) {\n        if (stmt.constructorMethod.body.length > 0) {\n          ctx.println(stmt, \"var self = this;\");\n          this.visitAllStatements(stmt.constructorMethod.body, ctx);\n        }\n      }\n\n      ctx.decIndent();\n      ctx.println(stmt, \"}\");\n    }\n  }, {\n    key: \"_visitClassGetter\",\n    value: function _visitClassGetter(stmt, getter, ctx) {\n      ctx.println(stmt, \"Object.defineProperty(\".concat(stmt.name, \".prototype, '\").concat(getter.name, \"', { get: function() {\"));\n      ctx.incIndent();\n\n      if (getter.body.length > 0) {\n        ctx.println(stmt, \"var self = this;\");\n        this.visitAllStatements(getter.body, ctx);\n      }\n\n      ctx.decIndent();\n      ctx.println(stmt, \"}});\");\n    }\n  }, {\n    key: \"_visitClassMethod\",\n    value: function _visitClassMethod(stmt, method, ctx) {\n      ctx.print(stmt, \"\".concat(stmt.name, \".prototype.\").concat(method.name, \" = function(\"));\n\n      this._visitParams(method.params, ctx);\n\n      ctx.println(stmt, \") {\");\n      ctx.incIndent();\n\n      if (method.body.length > 0) {\n        ctx.println(stmt, \"var self = this;\");\n        this.visitAllStatements(method.body, ctx);\n      }\n\n      ctx.decIndent();\n      ctx.println(stmt, \"};\");\n    }\n  }, {\n    key: \"visitWrappedNodeExpr\",\n    value: function visitWrappedNodeExpr(ast, ctx) {\n      throw new Error('Cannot emit a WrappedNodeExpr in Javascript.');\n    }\n  }, {\n    key: \"visitReadVarExpr\",\n    value: function visitReadVarExpr(ast, ctx) {\n      if (ast.builtin === BuiltinVar.This) {\n        ctx.print(ast, 'self');\n      } else if (ast.builtin === BuiltinVar.Super) {\n        throw new Error(\"'super' needs to be handled at a parent ast node, not at the variable level!\");\n      } else {\n        _get(_getPrototypeOf(AbstractJsEmitterVisitor.prototype), \"visitReadVarExpr\", this).call(this, ast, ctx);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"visitDeclareVarStmt\",\n    value: function visitDeclareVarStmt(stmt, ctx) {\n      ctx.print(stmt, \"var \".concat(stmt.name));\n\n      if (stmt.value) {\n        ctx.print(stmt, ' = ');\n        stmt.value.visitExpression(this, ctx);\n      }\n\n      ctx.println(stmt, \";\");\n      return null;\n    }\n  }, {\n    key: \"visitCastExpr\",\n    value: function visitCastExpr(ast, ctx) {\n      ast.value.visitExpression(this, ctx);\n      return null;\n    }\n  }, {\n    key: \"visitInvokeFunctionExpr\",\n    value: function visitInvokeFunctionExpr(expr, ctx) {\n      var fnExpr = expr.fn;\n\n      if (fnExpr instanceof ReadVarExpr && fnExpr.builtin === BuiltinVar.Super) {\n        ctx.currentClass.parent.visitExpression(this, ctx);\n        ctx.print(expr, \".call(this\");\n\n        if (expr.args.length > 0) {\n          ctx.print(expr, \", \");\n          this.visitAllExpressions(expr.args, ctx, ',');\n        }\n\n        ctx.print(expr, \")\");\n      } else {\n        _get(_getPrototypeOf(AbstractJsEmitterVisitor.prototype), \"visitInvokeFunctionExpr\", this).call(this, expr, ctx);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"visitFunctionExpr\",\n    value: function visitFunctionExpr(ast, ctx) {\n      ctx.print(ast, \"function\".concat(ast.name ? ' ' + ast.name : '', \"(\"));\n\n      this._visitParams(ast.params, ctx);\n\n      ctx.println(ast, \") {\");\n      ctx.incIndent();\n      this.visitAllStatements(ast.statements, ctx);\n      ctx.decIndent();\n      ctx.print(ast, \"}\");\n      return null;\n    }\n  }, {\n    key: \"visitDeclareFunctionStmt\",\n    value: function visitDeclareFunctionStmt(stmt, ctx) {\n      ctx.print(stmt, \"function \".concat(stmt.name, \"(\"));\n\n      this._visitParams(stmt.params, ctx);\n\n      ctx.println(stmt, \") {\");\n      ctx.incIndent();\n      this.visitAllStatements(stmt.statements, ctx);\n      ctx.decIndent();\n      ctx.println(stmt, \"}\");\n      return null;\n    }\n  }, {\n    key: \"visitTryCatchStmt\",\n    value: function visitTryCatchStmt(stmt, ctx) {\n      ctx.println(stmt, \"try {\");\n      ctx.incIndent();\n      this.visitAllStatements(stmt.bodyStmts, ctx);\n      ctx.decIndent();\n      ctx.println(stmt, \"} catch (\".concat(CATCH_ERROR_VAR$1.name, \") {\"));\n      ctx.incIndent();\n      var catchStmts = [CATCH_STACK_VAR$1.set(CATCH_ERROR_VAR$1.prop('stack')).toDeclStmt(null, [StmtModifier.Final])].concat(stmt.catchStmts);\n      this.visitAllStatements(catchStmts, ctx);\n      ctx.decIndent();\n      ctx.println(stmt, \"}\");\n      return null;\n    }\n  }, {\n    key: \"visitLocalizedString\",\n    value: function visitLocalizedString(ast, ctx) {\n      var _this84 = this;\n\n      // The following convoluted piece of code is effectively the downlevelled equivalent of\n      // ```\n      // $localize `...`\n      // ```\n      // which is effectively like:\n      // ```\n      // $localize(__makeTemplateObject(cooked, raw), expression1, expression2, ...);\n      // ```\n      //\n      // The `$localize` function expects a \"template object\", which is an array of \"cooked\" strings\n      // plus a `raw` property that contains an array of \"raw\" strings.\n      //\n      // In some environments a helper function called `__makeTemplateObject(cooked, raw)` might be\n      // available, in which case we use that. Otherwise we must create our own helper function\n      // inline.\n      //\n      // In the inline function, if `Object.defineProperty` is available we use that to attach the\n      // `raw` array.\n      ctx.print(ast, '$localize((this&&this.__makeTemplateObject||function(e,t){return Object.defineProperty?Object.defineProperty(e,\"raw\",{value:t}):e.raw=t,e})(');\n      var parts = [ast.serializeI18nHead()];\n\n      for (var i = 1; i < ast.messageParts.length; i++) {\n        parts.push(ast.serializeI18nTemplatePart(i));\n      }\n\n      ctx.print(ast, \"[\".concat(parts.map(function (part) {\n        return escapeIdentifier(part.cooked, false);\n      }).join(', '), \"], \"));\n      ctx.print(ast, \"[\".concat(parts.map(function (part) {\n        return escapeIdentifier(part.raw, false);\n      }).join(', '), \"])\"));\n      ast.expressions.forEach(function (expression) {\n        ctx.print(ast, ', ');\n        expression.visitExpression(_this84, ctx);\n      });\n      ctx.print(ast, ')');\n      return null;\n    }\n  }, {\n    key: \"_visitParams\",\n    value: function _visitParams(params, ctx) {\n      this.visitAllObjects(function (param) {\n        return ctx.print(null, param.name);\n      }, params, ctx, ',');\n    }\n  }, {\n    key: \"getBuiltinMethodName\",\n    value: function getBuiltinMethodName(method) {\n      var name;\n\n      switch (method) {\n        case BuiltinMethod.ConcatArray:\n          name = 'concat';\n          break;\n\n        case BuiltinMethod.SubscribeObservable:\n          name = 'subscribe';\n          break;\n\n        case BuiltinMethod.Bind:\n          name = 'bind';\n          break;\n\n        default:\n          throw new Error(\"Unknown builtin method: \".concat(method));\n      }\n\n      return name;\n    }\n  }]);\n\n  return AbstractJsEmitterVisitor;\n}(AbstractEmitterVisitor);\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * A helper class to manage the evaluation of JIT generated code.\n */\n\n\nvar JitEvaluator = /*#__PURE__*/function () {\n  function JitEvaluator() {\n    _classCallCheck(this, JitEvaluator);\n  }\n\n  _createClass(JitEvaluator, [{\n    key: \"evaluateStatements\",\n\n    /**\n     *\n     * @param sourceUrl The URL of the generated code.\n     * @param statements An array of Angular statement AST nodes to be evaluated.\n     * @param reflector A helper used when converting the statements to executable code.\n     * @param createSourceMaps If true then create a source-map for the generated code and include it\n     * inline as a source-map comment.\n     * @returns A map of all the variables in the generated code.\n     */\n    value: function evaluateStatements(sourceUrl, statements, reflector, createSourceMaps) {\n      var converter = new JitEmitterVisitor(reflector);\n      var ctx = EmitterVisitorContext.createRoot(); // Ensure generated code is in strict mode\n\n      if (statements.length > 0 && !isUseStrictStatement(statements[0])) {\n        statements = [literal('use strict').toStmt()].concat(_toConsumableArray(statements));\n      }\n\n      converter.visitAllStatements(statements, ctx);\n      converter.createReturnStmt(ctx);\n      return this.evaluateCode(sourceUrl, ctx, converter.getArgs(), createSourceMaps);\n    }\n    /**\n     * Evaluate a piece of JIT generated code.\n     * @param sourceUrl The URL of this generated code.\n     * @param ctx A context object that contains an AST of the code to be evaluated.\n     * @param vars A map containing the names and values of variables that the evaluated code might\n     * reference.\n     * @param createSourceMap If true then create a source-map for the generated code and include it\n     * inline as a source-map comment.\n     * @returns The result of evaluating the code.\n     */\n\n  }, {\n    key: \"evaluateCode\",\n    value: function evaluateCode(sourceUrl, ctx, vars, createSourceMap) {\n      var fnBody = \"\\\"use strict\\\";\".concat(ctx.toSource(), \"\\n//# sourceURL=\").concat(sourceUrl);\n      var fnArgNames = [];\n      var fnArgValues = [];\n\n      for (var argName in vars) {\n        fnArgValues.push(vars[argName]);\n        fnArgNames.push(argName);\n      }\n\n      if (createSourceMap) {\n        // using `new Function(...)` generates a header, 1 line of no arguments, 2 lines otherwise\n        // E.g. ```\n        // function anonymous(a,b,c\n        // /**/) { ... }```\n        // We don't want to hard code this fact, so we auto detect it via an empty function first.\n        var emptyFn = _construct(Function, _toConsumableArray(fnArgNames.concat('return null;'))).toString();\n\n        var headerLines = emptyFn.slice(0, emptyFn.indexOf('return null;')).split('\\n').length - 1;\n        fnBody += \"\\n\".concat(ctx.toSourceMapGenerator(sourceUrl, headerLines).toJsComment());\n      }\n\n      var fn = _construct(Function, _toConsumableArray(fnArgNames.concat(fnBody)));\n\n      return this.executeFunction(fn, fnArgValues);\n    }\n    /**\n     * Execute a JIT generated function by calling it.\n     *\n     * This method can be overridden in tests to capture the functions that are generated\n     * by this `JitEvaluator` class.\n     *\n     * @param fn A function to execute.\n     * @param args The arguments to pass to the function being executed.\n     * @returns The return value of the executed function.\n     */\n\n  }, {\n    key: \"executeFunction\",\n    value: function executeFunction(fn, args) {\n      return fn.apply(void 0, _toConsumableArray(args));\n    }\n  }]);\n\n  return JitEvaluator;\n}();\n/**\n * An Angular AST visitor that converts AST nodes into executable JavaScript code.\n */\n\n\nvar JitEmitterVisitor = /*#__PURE__*/function (_AbstractJsEmitterVis) {\n  _inherits(JitEmitterVisitor, _AbstractJsEmitterVis);\n\n  var _super50 = _createSuper(JitEmitterVisitor);\n\n  function JitEmitterVisitor(reflector) {\n    var _this85;\n\n    _classCallCheck(this, JitEmitterVisitor);\n\n    _this85 = _super50.call(this);\n    _this85.reflector = reflector;\n    _this85._evalArgNames = [];\n    _this85._evalArgValues = [];\n    _this85._evalExportedVars = [];\n    return _this85;\n  }\n\n  _createClass(JitEmitterVisitor, [{\n    key: \"createReturnStmt\",\n    value: function createReturnStmt(ctx) {\n      var stmt = new ReturnStatement(new LiteralMapExpr(this._evalExportedVars.map(function (resultVar) {\n        return new LiteralMapEntry(resultVar, variable(resultVar), false);\n      })));\n      stmt.visitStatement(this, ctx);\n    }\n  }, {\n    key: \"getArgs\",\n    value: function getArgs() {\n      var result = {};\n\n      for (var i = 0; i < this._evalArgNames.length; i++) {\n        result[this._evalArgNames[i]] = this._evalArgValues[i];\n      }\n\n      return result;\n    }\n  }, {\n    key: \"visitExternalExpr\",\n    value: function visitExternalExpr(ast, ctx) {\n      this._emitReferenceToExternal(ast, this.reflector.resolveExternalReference(ast.value), ctx);\n\n      return null;\n    }\n  }, {\n    key: \"visitWrappedNodeExpr\",\n    value: function visitWrappedNodeExpr(ast, ctx) {\n      this._emitReferenceToExternal(ast, ast.node, ctx);\n\n      return null;\n    }\n  }, {\n    key: \"visitDeclareVarStmt\",\n    value: function visitDeclareVarStmt(stmt, ctx) {\n      if (stmt.hasModifier(StmtModifier.Exported)) {\n        this._evalExportedVars.push(stmt.name);\n      }\n\n      return _get(_getPrototypeOf(JitEmitterVisitor.prototype), \"visitDeclareVarStmt\", this).call(this, stmt, ctx);\n    }\n  }, {\n    key: \"visitDeclareFunctionStmt\",\n    value: function visitDeclareFunctionStmt(stmt, ctx) {\n      if (stmt.hasModifier(StmtModifier.Exported)) {\n        this._evalExportedVars.push(stmt.name);\n      }\n\n      return _get(_getPrototypeOf(JitEmitterVisitor.prototype), \"visitDeclareFunctionStmt\", this).call(this, stmt, ctx);\n    }\n  }, {\n    key: \"visitDeclareClassStmt\",\n    value: function visitDeclareClassStmt(stmt, ctx) {\n      if (stmt.hasModifier(StmtModifier.Exported)) {\n        this._evalExportedVars.push(stmt.name);\n      }\n\n      return _get(_getPrototypeOf(JitEmitterVisitor.prototype), \"visitDeclareClassStmt\", this).call(this, stmt, ctx);\n    }\n  }, {\n    key: \"_emitReferenceToExternal\",\n    value: function _emitReferenceToExternal(ast, value, ctx) {\n      var id = this._evalArgValues.indexOf(value);\n\n      if (id === -1) {\n        id = this._evalArgValues.length;\n\n        this._evalArgValues.push(value);\n\n        var name = identifierName({\n          reference: value\n        }) || 'val';\n\n        this._evalArgNames.push(\"jit_\".concat(name, \"_\").concat(id));\n      }\n\n      ctx.print(ast, this._evalArgNames[id]);\n    }\n  }]);\n\n  return JitEmitterVisitor;\n}(AbstractJsEmitterVisitor);\n\nfunction isUseStrictStatement(statement) {\n  return statement.isEquivalent(literal('use strict').toStmt());\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Implementation of `CompileReflector` which resolves references to @angular/core\n * symbols at runtime, according to a consumer-provided mapping.\n *\n * Only supports `resolveExternalReference`, all other methods throw.\n */\n\n\nvar R3JitReflector = /*#__PURE__*/function () {\n  function R3JitReflector(context) {\n    _classCallCheck(this, R3JitReflector);\n\n    this.context = context;\n  }\n\n  _createClass(R3JitReflector, [{\n    key: \"resolveExternalReference\",\n    value: function resolveExternalReference(ref) {\n      // This reflector only handles @angular/core imports.\n      if (ref.moduleName !== '@angular/core') {\n        throw new Error(\"Cannot resolve external reference to \".concat(ref.moduleName, \", only references to @angular/core are supported.\"));\n      }\n\n      if (!this.context.hasOwnProperty(ref.name)) {\n        throw new Error(\"No value provided for @angular/core symbol '\".concat(ref.name, \"'.\"));\n      }\n\n      return this.context[ref.name];\n    }\n  }, {\n    key: \"parameters\",\n    value: function parameters(typeOrFunc) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"annotations\",\n    value: function annotations(typeOrFunc) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"shallowAnnotations\",\n    value: function shallowAnnotations(typeOrFunc) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"tryAnnotations\",\n    value: function tryAnnotations(typeOrFunc) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"propMetadata\",\n    value: function propMetadata(typeOrFunc) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"hasLifecycleHook\",\n    value: function hasLifecycleHook(type, lcProperty) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"guards\",\n    value: function guards(typeOrFunc) {\n      throw new Error('Not implemented.');\n    }\n  }, {\n    key: \"componentModuleUrl\",\n    value: function componentModuleUrl(type, cmpMetadata) {\n      throw new Error('Not implemented.');\n    }\n  }]);\n\n  return R3JitReflector;\n}();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction mapEntry(key, value) {\n  return {\n    key: key,\n    value: value,\n    quoted: false\n  };\n}\n\nfunction mapLiteral(obj) {\n  var quoted = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return literalMap(Object.keys(obj).map(function (key) {\n    return {\n      key: key,\n      quoted: quoted,\n      value: obj[key]\n    };\n  }));\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Construct an `R3NgModuleDef` for the given `R3NgModuleMetadata`.\n */\n\n\nfunction _compileNgModule(meta) {\n  var internalType = meta.internalType,\n      moduleType = meta.type,\n      bootstrap = meta.bootstrap,\n      declarations = meta.declarations,\n      imports = meta.imports,\n      exports = meta.exports,\n      schemas = meta.schemas,\n      containsForwardDecls = meta.containsForwardDecls,\n      emitInline = meta.emitInline,\n      id = meta.id;\n  var additionalStatements = [];\n  var definitionMap = {\n    type: internalType\n  }; // Only generate the keys in the metadata if the arrays have values.\n\n  if (bootstrap.length) {\n    definitionMap.bootstrap = refsToArray(bootstrap, containsForwardDecls);\n  } // If requested to emit scope information inline, pass the declarations, imports and exports to\n  // the `ɵɵdefineNgModule` call. The JIT compilation uses this.\n\n\n  if (emitInline) {\n    if (declarations.length) {\n      definitionMap.declarations = refsToArray(declarations, containsForwardDecls);\n    }\n\n    if (imports.length) {\n      definitionMap.imports = refsToArray(imports, containsForwardDecls);\n    }\n\n    if (exports.length) {\n      definitionMap.exports = refsToArray(exports, containsForwardDecls);\n    }\n  } // If not emitting inline, the scope information is not passed into `ɵɵdefineNgModule` as it would\n  // prevent tree-shaking of the declarations, imports and exports references.\n  else {\n      var setNgModuleScopeCall = generateSetNgModuleScopeCall(meta);\n\n      if (setNgModuleScopeCall !== null) {\n        additionalStatements.push(setNgModuleScopeCall);\n      }\n    }\n\n  if (schemas && schemas.length) {\n    definitionMap.schemas = literalArr(schemas.map(function (ref) {\n      return ref.value;\n    }));\n  }\n\n  if (id) {\n    definitionMap.id = id;\n  }\n\n  var expression = importExpr(Identifiers$1.defineNgModule).callFn([mapToMapExpression(definitionMap)]);\n  var type = new ExpressionType(importExpr(Identifiers$1.NgModuleDefWithMeta, [new ExpressionType(moduleType.type), tupleTypeOf(declarations), tupleTypeOf(imports), tupleTypeOf(exports)]));\n  return {\n    expression: expression,\n    type: type,\n    additionalStatements: additionalStatements\n  };\n}\n/**\n * Generates a function call to `ɵɵsetNgModuleScope` with all necessary information so that the\n * transitive module scope can be computed during runtime in JIT mode. This call is marked pure\n * such that the references to declarations, imports and exports may be elided causing these\n * symbols to become tree-shakeable.\n */\n\n\nfunction generateSetNgModuleScopeCall(meta) {\n  var moduleType = meta.adjacentType,\n      declarations = meta.declarations,\n      imports = meta.imports,\n      exports = meta.exports,\n      containsForwardDecls = meta.containsForwardDecls;\n  var scopeMap = {};\n\n  if (declarations.length) {\n    scopeMap.declarations = refsToArray(declarations, containsForwardDecls);\n  }\n\n  if (imports.length) {\n    scopeMap.imports = refsToArray(imports, containsForwardDecls);\n  }\n\n  if (exports.length) {\n    scopeMap.exports = refsToArray(exports, containsForwardDecls);\n  }\n\n  if (Object.keys(scopeMap).length === 0) {\n    return null;\n  } // setNgModuleScope(...)\n\n\n  var fnCall = new InvokeFunctionExpr(\n  /* fn */\n  importExpr(Identifiers$1.setNgModuleScope),\n  /* args */\n  [moduleType, mapToMapExpression(scopeMap)]); // (ngJitMode guard) && setNgModuleScope(...)\n\n  var guardedCall = jitOnlyGuardedExpression(fnCall); // function() { (ngJitMode guard) && setNgModuleScope(...); }\n\n  var iife = new FunctionExpr(\n  /* params */\n  [],\n  /* statements */\n  [guardedCall.toStmt()]); // (function() { (ngJitMode guard) && setNgModuleScope(...); })()\n\n  var iifeCall = new InvokeFunctionExpr(\n  /* fn */\n  iife,\n  /* args */\n  []);\n  return iifeCall.toStmt();\n}\n\nfunction _compileInjector(meta) {\n  var result = compileFactoryFunction({\n    name: meta.name,\n    type: meta.type,\n    internalType: meta.internalType,\n    typeArgumentCount: 0,\n    deps: meta.deps,\n    injectFn: Identifiers$1.inject,\n    target: R3FactoryTarget.NgModule\n  });\n  var definitionMap = {\n    factory: result.factory\n  };\n\n  if (meta.providers !== null) {\n    definitionMap.providers = meta.providers;\n  }\n\n  if (meta.imports.length > 0) {\n    definitionMap.imports = literalArr(meta.imports);\n  }\n\n  var expression = importExpr(Identifiers$1.defineInjector).callFn([mapToMapExpression(definitionMap)]);\n  var type = new ExpressionType(importExpr(Identifiers$1.InjectorDef, [new ExpressionType(meta.type.type)]));\n  return {\n    expression: expression,\n    type: type,\n    statements: result.statements\n  };\n} // TODO(alxhub): integrate this with `compileNgModule`. Currently the two are separate operations.\n\n\nfunction compileNgModuleFromRender2(ctx, ngModule, injectableCompiler) {\n  var className = identifierName(ngModule.type);\n  var rawImports = ngModule.rawImports ? [ngModule.rawImports] : [];\n  var rawExports = ngModule.rawExports ? [ngModule.rawExports] : [];\n  var injectorDefArg = mapLiteral({\n    'factory': injectableCompiler.factoryFor({\n      type: ngModule.type,\n      symbol: ngModule.type.reference\n    }, ctx),\n    'providers': convertMetaToOutput(ngModule.rawProviders, ctx),\n    'imports': convertMetaToOutput([].concat(rawImports, rawExports), ctx)\n  });\n  var injectorDef = importExpr(Identifiers$1.defineInjector).callFn([injectorDefArg]);\n  ctx.statements.push(new ClassStmt(\n  /* name */\n  className,\n  /* parent */\n  null,\n  /* fields */\n  [new ClassField(\n  /* name */\n  'ɵinj',\n  /* type */\n  INFERRED_TYPE,\n  /* modifiers */\n  [StmtModifier.Static],\n  /* initializer */\n  injectorDef)],\n  /* getters */\n  [],\n  /* constructorMethod */\n  new ClassMethod(null, [], []),\n  /* methods */\n  []));\n}\n\nfunction accessExportScope(module) {\n  var selectorScope = new ReadPropExpr(module, 'ɵmod');\n  return new ReadPropExpr(selectorScope, 'exported');\n}\n\nfunction tupleTypeOf(exp) {\n  var types = exp.map(function (ref) {\n    return typeofExpr(ref.type);\n  });\n  return exp.length > 0 ? expressionType(literalArr(types)) : NONE_TYPE;\n}\n\nfunction refsToArray(refs, shouldForwardDeclare) {\n  var values = literalArr(refs.map(function (ref) {\n    return ref.value;\n  }));\n  return shouldForwardDeclare ? fn([], [new ReturnStatement(values)]) : values;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction compilePipeFromMetadata(metadata) {\n  var definitionMapValues = []; // e.g. `name: 'myPipe'`\n\n  definitionMapValues.push({\n    key: 'name',\n    value: literal(metadata.pipeName),\n    quoted: false\n  }); // e.g. `type: MyPipe`\n\n  definitionMapValues.push({\n    key: 'type',\n    value: metadata.type.value,\n    quoted: false\n  }); // e.g. `pure: true`\n\n  definitionMapValues.push({\n    key: 'pure',\n    value: literal(metadata.pure),\n    quoted: false\n  });\n  var expression = importExpr(Identifiers$1.definePipe).callFn([literalMap(definitionMapValues)]);\n  var type = new ExpressionType(importExpr(Identifiers$1.PipeDefWithMeta, [typeWithParameters(metadata.type.type, metadata.typeArgumentCount), new ExpressionType(new LiteralExpr(metadata.pipeName))]));\n  return {\n    expression: expression,\n    type: type\n  };\n}\n/**\n * Write a pipe definition to the output context.\n */\n\n\nfunction compilePipeFromRender2(outputCtx, pipe, reflector) {\n  var name = identifierName(pipe.type);\n\n  if (!name) {\n    return error(\"Cannot resolve the name of \".concat(pipe.type));\n  }\n\n  var type = outputCtx.importExpr(pipe.type.reference);\n  var metadata = {\n    name: name,\n    type: wrapReference(type),\n    internalType: type,\n    pipeName: pipe.name,\n    typeArgumentCount: 0,\n    deps: dependenciesFromGlobalMetadata(pipe.type, outputCtx, reflector),\n    pure: pipe.pure\n  };\n  var res = compilePipeFromMetadata(metadata);\n  var factoryRes = compileFactoryFunction(Object.assign(Object.assign({}, metadata), {\n    injectFn: Identifiers$1.directiveInject,\n    target: R3FactoryTarget.Pipe\n  }));\n  var definitionField = outputCtx.constantPool.propertyNameOf(3\n  /* Pipe */\n  );\n  var ngFactoryDefStatement = new ClassStmt(\n  /* name */\n  name,\n  /* parent */\n  null,\n  /* fields */\n  [new ClassField(\n  /* name */\n  'ɵfac',\n  /* type */\n  INFERRED_TYPE,\n  /* modifiers */\n  [StmtModifier.Static],\n  /* initializer */\n  factoryRes.factory)],\n  /* getters */\n  [],\n  /* constructorMethod */\n  new ClassMethod(null, [], []),\n  /* methods */\n  []);\n  var pipeDefStatement = new ClassStmt(\n  /* name */\n  name,\n  /* parent */\n  null,\n  /* fields */\n  [new ClassField(\n  /* name */\n  definitionField,\n  /* type */\n  INFERRED_TYPE,\n  /* modifiers */\n  [StmtModifier.Static],\n  /* initializer */\n  res.expression)],\n  /* getters */\n  [],\n  /* constructorMethod */\n  new ClassMethod(null, [], []),\n  /* methods */\n  []);\n  outputCtx.statements.push(ngFactoryDefStatement, pipeDefStatement);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar ParserError = function ParserError(message, input, errLocation, ctxLocation) {\n  _classCallCheck(this, ParserError);\n\n  this.input = input;\n  this.errLocation = errLocation;\n  this.ctxLocation = ctxLocation;\n  this.message = \"Parser Error: \".concat(message, \" \").concat(errLocation, \" [\").concat(input, \"] in \").concat(ctxLocation);\n};\n\nvar ParseSpan = /*#__PURE__*/function () {\n  function ParseSpan(start, end) {\n    _classCallCheck(this, ParseSpan);\n\n    this.start = start;\n    this.end = end;\n  }\n\n  _createClass(ParseSpan, [{\n    key: \"toAbsolute\",\n    value: function toAbsolute(absoluteOffset) {\n      return new AbsoluteSourceSpan(absoluteOffset + this.start, absoluteOffset + this.end);\n    }\n  }]);\n\n  return ParseSpan;\n}();\n\nvar AST = /*#__PURE__*/function () {\n  function AST(span,\n  /**\n   * Absolute location of the expression AST in a source code file.\n   */\n  sourceSpan) {\n    _classCallCheck(this, AST);\n\n    this.span = span;\n    this.sourceSpan = sourceSpan;\n  }\n\n  _createClass(AST, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return null;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return 'AST';\n    }\n  }]);\n\n  return AST;\n}();\n\nvar ASTWithName = /*#__PURE__*/function (_AST) {\n  _inherits(ASTWithName, _AST);\n\n  var _super51 = _createSuper(ASTWithName);\n\n  function ASTWithName(span, sourceSpan, nameSpan) {\n    var _this86;\n\n    _classCallCheck(this, ASTWithName);\n\n    _this86 = _super51.call(this, span, sourceSpan);\n    _this86.nameSpan = nameSpan;\n    return _this86;\n  }\n\n  return ASTWithName;\n}(AST);\n/**\n * Represents a quoted expression of the form:\n *\n * quote = prefix `:` uninterpretedExpression\n * prefix = identifier\n * uninterpretedExpression = arbitrary string\n *\n * A quoted expression is meant to be pre-processed by an AST transformer that\n * converts it into another AST that no longer contains quoted expressions.\n * It is meant to allow third-party developers to extend Angular template\n * expression language. The `uninterpretedExpression` part of the quote is\n * therefore not interpreted by the Angular's own expression parser.\n */\n\n\nvar Quote = /*#__PURE__*/function (_AST2) {\n  _inherits(Quote, _AST2);\n\n  var _super52 = _createSuper(Quote);\n\n  function Quote(span, sourceSpan, prefix, uninterpretedExpression, location) {\n    var _this87;\n\n    _classCallCheck(this, Quote);\n\n    _this87 = _super52.call(this, span, sourceSpan);\n    _this87.prefix = prefix;\n    _this87.uninterpretedExpression = uninterpretedExpression;\n    _this87.location = location;\n    return _this87;\n  }\n\n  _createClass(Quote, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return visitor.visitQuote(this, context);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return 'Quote';\n    }\n  }]);\n\n  return Quote;\n}(AST);\n\nvar EmptyExpr = /*#__PURE__*/function (_AST3) {\n  _inherits(EmptyExpr, _AST3);\n\n  var _super53 = _createSuper(EmptyExpr);\n\n  function EmptyExpr() {\n    _classCallCheck(this, EmptyExpr);\n\n    return _super53.apply(this, arguments);\n  }\n\n  _createClass(EmptyExpr, [{\n    key: \"visit\",\n    value: function visit(visitor) {// do nothing\n\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    }\n  }]);\n\n  return EmptyExpr;\n}(AST);\n\nvar ImplicitReceiver = /*#__PURE__*/function (_AST4) {\n  _inherits(ImplicitReceiver, _AST4);\n\n  var _super54 = _createSuper(ImplicitReceiver);\n\n  function ImplicitReceiver() {\n    _classCallCheck(this, ImplicitReceiver);\n\n    return _super54.apply(this, arguments);\n  }\n\n  _createClass(ImplicitReceiver, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return visitor.visitImplicitReceiver(this, context);\n    }\n  }]);\n\n  return ImplicitReceiver;\n}(AST);\n/**\n * Multiple expressions separated by a semicolon.\n */\n\n\nvar Chain = /*#__PURE__*/function (_AST5) {\n  _inherits(Chain, _AST5);\n\n  var _super55 = _createSuper(Chain);\n\n  function Chain(span, sourceSpan, expressions) {\n    var _this88;\n\n    _classCallCheck(this, Chain);\n\n    _this88 = _super55.call(this, span, sourceSpan);\n    _this88.expressions = expressions;\n    return _this88;\n  }\n\n  _createClass(Chain, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return visitor.visitChain(this, context);\n    }\n  }]);\n\n  return Chain;\n}(AST);\n\nvar Conditional = /*#__PURE__*/function (_AST6) {\n  _inherits(Conditional, _AST6);\n\n  var _super56 = _createSuper(Conditional);\n\n  function Conditional(span, sourceSpan, condition, trueExp, falseExp) {\n    var _this89;\n\n    _classCallCheck(this, Conditional);\n\n    _this89 = _super56.call(this, span, sourceSpan);\n    _this89.condition = condition;\n    _this89.trueExp = trueExp;\n    _this89.falseExp = falseExp;\n    return _this89;\n  }\n\n  _createClass(Conditional, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return visitor.visitConditional(this, context);\n    }\n  }]);\n\n  return Conditional;\n}(AST);\n\nvar PropertyRead = /*#__PURE__*/function (_ASTWithName) {\n  _inherits(PropertyRead, _ASTWithName);\n\n  var _super57 = _createSuper(PropertyRead);\n\n  function PropertyRead(span, sourceSpan, nameSpan, receiver, name) {\n    var _this90;\n\n    _classCallCheck(this, PropertyRead);\n\n    _this90 = _super57.call(this, span, sourceSpan, nameSpan);\n    _this90.receiver = receiver;\n    _this90.name = name;\n    return _this90;\n  }\n\n  _createClass(PropertyRead, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return visitor.visitPropertyRead(this, context);\n    }\n  }]);\n\n  return PropertyRead;\n}(ASTWithName);\n\nvar PropertyWrite = /*#__PURE__*/function (_ASTWithName2) {\n  _inherits(PropertyWrite, _ASTWithName2);\n\n  var _super58 = _createSuper(PropertyWrite);\n\n  function PropertyWrite(span, sourceSpan, nameSpan, receiver, name, value) {\n    var _this91;\n\n    _classCallCheck(this, PropertyWrite);\n\n    _this91 = _super58.call(this, span, sourceSpan, nameSpan);\n    _this91.receiver = receiver;\n    _this91.name = name;\n    _this91.value = value;\n    return _this91;\n  }\n\n  _createClass(PropertyWrite, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return visitor.visitPropertyWrite(this, context);\n    }\n  }]);\n\n  return PropertyWrite;\n}(ASTWithName);\n\nvar SafePropertyRead = /*#__PURE__*/function (_ASTWithName3) {\n  _inherits(SafePropertyRead, _ASTWithName3);\n\n  var _super59 = _createSuper(SafePropertyRead);\n\n  function SafePropertyRead(span, sourceSpan, nameSpan, receiver, name) {\n    var _this92;\n\n    _classCallCheck(this, SafePropertyRead);\n\n    _this92 = _super59.call(this, span, sourceSpan, nameSpan);\n    _this92.receiver = receiver;\n    _this92.name = name;\n    return _this92;\n  }\n\n  _createClass(SafePropertyRead, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return visitor.visitSafePropertyRead(this, context);\n    }\n  }]);\n\n  return SafePropertyRead;\n}(ASTWithName);\n\nvar KeyedRead = /*#__PURE__*/function (_AST7) {\n  _inherits(KeyedRead, _AST7);\n\n  var _super60 = _createSuper(KeyedRead);\n\n  function KeyedRead(span, sourceSpan, obj, key) {\n    var _this93;\n\n    _classCallCheck(this, KeyedRead);\n\n    _this93 = _super60.call(this, span, sourceSpan);\n    _this93.obj = obj;\n    _this93.key = key;\n    return _this93;\n  }\n\n  _createClass(KeyedRead, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return visitor.visitKeyedRead(this, context);\n    }\n  }]);\n\n  return KeyedRead;\n}(AST);\n\nvar KeyedWrite = /*#__PURE__*/function (_AST8) {\n  _inherits(KeyedWrite, _AST8);\n\n  var _super61 = _createSuper(KeyedWrite);\n\n  function KeyedWrite(span, sourceSpan, obj, key, value) {\n    var _this94;\n\n    _classCallCheck(this, KeyedWrite);\n\n    _this94 = _super61.call(this, span, sourceSpan);\n    _this94.obj = obj;\n    _this94.key = key;\n    _this94.value = value;\n    return _this94;\n  }\n\n  _createClass(KeyedWrite, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return visitor.visitKeyedWrite(this, context);\n    }\n  }]);\n\n  return KeyedWrite;\n}(AST);\n\nvar BindingPipe = /*#__PURE__*/function (_ASTWithName4) {\n  _inherits(BindingPipe, _ASTWithName4);\n\n  var _super62 = _createSuper(BindingPipe);\n\n  function BindingPipe(span, sourceSpan, exp, name, args, nameSpan) {\n    var _this95;\n\n    _classCallCheck(this, BindingPipe);\n\n    _this95 = _super62.call(this, span, sourceSpan, nameSpan);\n    _this95.exp = exp;\n    _this95.name = name;\n    _this95.args = args;\n    return _this95;\n  }\n\n  _createClass(BindingPipe, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return visitor.visitPipe(this, context);\n    }\n  }]);\n\n  return BindingPipe;\n}(ASTWithName);\n\nvar LiteralPrimitive = /*#__PURE__*/function (_AST9) {\n  _inherits(LiteralPrimitive, _AST9);\n\n  var _super63 = _createSuper(LiteralPrimitive);\n\n  function LiteralPrimitive(span, sourceSpan, value) {\n    var _this96;\n\n    _classCallCheck(this, LiteralPrimitive);\n\n    _this96 = _super63.call(this, span, sourceSpan);\n    _this96.value = value;\n    return _this96;\n  }\n\n  _createClass(LiteralPrimitive, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return visitor.visitLiteralPrimitive(this, context);\n    }\n  }]);\n\n  return LiteralPrimitive;\n}(AST);\n\nvar LiteralArray = /*#__PURE__*/function (_AST10) {\n  _inherits(LiteralArray, _AST10);\n\n  var _super64 = _createSuper(LiteralArray);\n\n  function LiteralArray(span, sourceSpan, expressions) {\n    var _this97;\n\n    _classCallCheck(this, LiteralArray);\n\n    _this97 = _super64.call(this, span, sourceSpan);\n    _this97.expressions = expressions;\n    return _this97;\n  }\n\n  _createClass(LiteralArray, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return visitor.visitLiteralArray(this, context);\n    }\n  }]);\n\n  return LiteralArray;\n}(AST);\n\nvar LiteralMap = /*#__PURE__*/function (_AST11) {\n  _inherits(LiteralMap, _AST11);\n\n  var _super65 = _createSuper(LiteralMap);\n\n  function LiteralMap(span, sourceSpan, keys, values) {\n    var _this98;\n\n    _classCallCheck(this, LiteralMap);\n\n    _this98 = _super65.call(this, span, sourceSpan);\n    _this98.keys = keys;\n    _this98.values = values;\n    return _this98;\n  }\n\n  _createClass(LiteralMap, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return visitor.visitLiteralMap(this, context);\n    }\n  }]);\n\n  return LiteralMap;\n}(AST);\n\nvar Interpolation = /*#__PURE__*/function (_AST12) {\n  _inherits(Interpolation, _AST12);\n\n  var _super66 = _createSuper(Interpolation);\n\n  function Interpolation(span, sourceSpan, strings, expressions) {\n    var _this99;\n\n    _classCallCheck(this, Interpolation);\n\n    _this99 = _super66.call(this, span, sourceSpan);\n    _this99.strings = strings;\n    _this99.expressions = expressions;\n    return _this99;\n  }\n\n  _createClass(Interpolation, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return visitor.visitInterpolation(this, context);\n    }\n  }]);\n\n  return Interpolation;\n}(AST);\n\nvar Binary = /*#__PURE__*/function (_AST13) {\n  _inherits(Binary, _AST13);\n\n  var _super67 = _createSuper(Binary);\n\n  function Binary(span, sourceSpan, operation, left, right) {\n    var _this100;\n\n    _classCallCheck(this, Binary);\n\n    _this100 = _super67.call(this, span, sourceSpan);\n    _this100.operation = operation;\n    _this100.left = left;\n    _this100.right = right;\n    return _this100;\n  }\n\n  _createClass(Binary, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return visitor.visitBinary(this, context);\n    }\n  }]);\n\n  return Binary;\n}(AST);\n\nvar PrefixNot = /*#__PURE__*/function (_AST14) {\n  _inherits(PrefixNot, _AST14);\n\n  var _super68 = _createSuper(PrefixNot);\n\n  function PrefixNot(span, sourceSpan, expression) {\n    var _this101;\n\n    _classCallCheck(this, PrefixNot);\n\n    _this101 = _super68.call(this, span, sourceSpan);\n    _this101.expression = expression;\n    return _this101;\n  }\n\n  _createClass(PrefixNot, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return visitor.visitPrefixNot(this, context);\n    }\n  }]);\n\n  return PrefixNot;\n}(AST);\n\nvar NonNullAssert = /*#__PURE__*/function (_AST15) {\n  _inherits(NonNullAssert, _AST15);\n\n  var _super69 = _createSuper(NonNullAssert);\n\n  function NonNullAssert(span, sourceSpan, expression) {\n    var _this102;\n\n    _classCallCheck(this, NonNullAssert);\n\n    _this102 = _super69.call(this, span, sourceSpan);\n    _this102.expression = expression;\n    return _this102;\n  }\n\n  _createClass(NonNullAssert, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return visitor.visitNonNullAssert(this, context);\n    }\n  }]);\n\n  return NonNullAssert;\n}(AST);\n\nvar MethodCall = /*#__PURE__*/function (_ASTWithName5) {\n  _inherits(MethodCall, _ASTWithName5);\n\n  var _super70 = _createSuper(MethodCall);\n\n  function MethodCall(span, sourceSpan, nameSpan, receiver, name, args) {\n    var _this103;\n\n    _classCallCheck(this, MethodCall);\n\n    _this103 = _super70.call(this, span, sourceSpan, nameSpan);\n    _this103.receiver = receiver;\n    _this103.name = name;\n    _this103.args = args;\n    return _this103;\n  }\n\n  _createClass(MethodCall, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return visitor.visitMethodCall(this, context);\n    }\n  }]);\n\n  return MethodCall;\n}(ASTWithName);\n\nvar SafeMethodCall = /*#__PURE__*/function (_ASTWithName6) {\n  _inherits(SafeMethodCall, _ASTWithName6);\n\n  var _super71 = _createSuper(SafeMethodCall);\n\n  function SafeMethodCall(span, sourceSpan, nameSpan, receiver, name, args) {\n    var _this104;\n\n    _classCallCheck(this, SafeMethodCall);\n\n    _this104 = _super71.call(this, span, sourceSpan, nameSpan);\n    _this104.receiver = receiver;\n    _this104.name = name;\n    _this104.args = args;\n    return _this104;\n  }\n\n  _createClass(SafeMethodCall, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return visitor.visitSafeMethodCall(this, context);\n    }\n  }]);\n\n  return SafeMethodCall;\n}(ASTWithName);\n\nvar FunctionCall = /*#__PURE__*/function (_AST16) {\n  _inherits(FunctionCall, _AST16);\n\n  var _super72 = _createSuper(FunctionCall);\n\n  function FunctionCall(span, sourceSpan, target, args) {\n    var _this105;\n\n    _classCallCheck(this, FunctionCall);\n\n    _this105 = _super72.call(this, span, sourceSpan);\n    _this105.target = target;\n    _this105.args = args;\n    return _this105;\n  }\n\n  _createClass(FunctionCall, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return visitor.visitFunctionCall(this, context);\n    }\n  }]);\n\n  return FunctionCall;\n}(AST);\n/**\n * Records the absolute position of a text span in a source file, where `start` and `end` are the\n * starting and ending byte offsets, respectively, of the text span in a source file.\n */\n\n\nvar AbsoluteSourceSpan = function AbsoluteSourceSpan(start, end) {\n  _classCallCheck(this, AbsoluteSourceSpan);\n\n  this.start = start;\n  this.end = end;\n};\n\nvar ASTWithSource = /*#__PURE__*/function (_AST17) {\n  _inherits(ASTWithSource, _AST17);\n\n  var _super73 = _createSuper(ASTWithSource);\n\n  function ASTWithSource(ast, source, location, absoluteOffset, errors) {\n    var _this106;\n\n    _classCallCheck(this, ASTWithSource);\n\n    _this106 = _super73.call(this, new ParseSpan(0, source === null ? 0 : source.length), new AbsoluteSourceSpan(absoluteOffset, source === null ? absoluteOffset : absoluteOffset + source.length));\n    _this106.ast = ast;\n    _this106.source = source;\n    _this106.location = location;\n    _this106.errors = errors;\n    return _this106;\n  }\n\n  _createClass(ASTWithSource, [{\n    key: \"visit\",\n    value: function visit(visitor) {\n      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      if (visitor.visitASTWithSource) {\n        return visitor.visitASTWithSource(this, context);\n      }\n\n      return this.ast.visit(visitor, context);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return \"\".concat(this.source, \" in \").concat(this.location);\n    }\n  }]);\n\n  return ASTWithSource;\n}(AST);\n\nvar VariableBinding =\n/**\n * @param sourceSpan entire span of the binding.\n * @param key name of the LHS along with its span.\n * @param value optional value for the RHS along with its span.\n */\nfunction VariableBinding(sourceSpan, key, value) {\n  _classCallCheck(this, VariableBinding);\n\n  this.sourceSpan = sourceSpan;\n  this.key = key;\n  this.value = value;\n};\n\nvar ExpressionBinding =\n/**\n * @param sourceSpan entire span of the binding.\n * @param key binding name, like ngForOf, ngForTrackBy, ngIf, along with its\n * span. Note that the length of the span may not be the same as\n * `key.source.length`. For example,\n * 1. key.source = ngFor, key.span is for \"ngFor\"\n * 2. key.source = ngForOf, key.span is for \"of\"\n * 3. key.source = ngForTrackBy, key.span is for \"trackBy\"\n * @param value optional expression for the RHS.\n */\nfunction ExpressionBinding(sourceSpan, key, value) {\n  _classCallCheck(this, ExpressionBinding);\n\n  this.sourceSpan = sourceSpan;\n  this.key = key;\n  this.value = value;\n};\n\nvar RecursiveAstVisitor$1 = /*#__PURE__*/function () {\n  function RecursiveAstVisitor$1() {\n    _classCallCheck(this, RecursiveAstVisitor$1);\n  }\n\n  _createClass(RecursiveAstVisitor$1, [{\n    key: \"visit\",\n    value: function visit(ast, context) {\n      // The default implementation just visits every node.\n      // Classes that extend RecursiveAstVisitor should override this function\n      // to selectively visit the specified node.\n      ast.visit(this, context);\n    }\n  }, {\n    key: \"visitBinary\",\n    value: function visitBinary(ast, context) {\n      this.visit(ast.left, context);\n      this.visit(ast.right, context);\n    }\n  }, {\n    key: \"visitChain\",\n    value: function visitChain(ast, context) {\n      this.visitAll(ast.expressions, context);\n    }\n  }, {\n    key: \"visitConditional\",\n    value: function visitConditional(ast, context) {\n      this.visit(ast.condition, context);\n      this.visit(ast.trueExp, context);\n      this.visit(ast.falseExp, context);\n    }\n  }, {\n    key: \"visitPipe\",\n    value: function visitPipe(ast, context) {\n      this.visit(ast.exp, context);\n      this.visitAll(ast.args, context);\n    }\n  }, {\n    key: \"visitFunctionCall\",\n    value: function visitFunctionCall(ast, context) {\n      if (ast.target) {\n        this.visit(ast.target, context);\n      }\n\n      this.visitAll(ast.args, context);\n    }\n  }, {\n    key: \"visitImplicitReceiver\",\n    value: function visitImplicitReceiver(ast, context) {}\n  }, {\n    key: \"visitInterpolation\",\n    value: function visitInterpolation(ast, context) {\n      this.visitAll(ast.expressions, context);\n    }\n  }, {\n    key: \"visitKeyedRead\",\n    value: function visitKeyedRead(ast, context) {\n      this.visit(ast.obj, context);\n      this.visit(ast.key, context);\n    }\n  }, {\n    key: \"visitKeyedWrite\",\n    value: function visitKeyedWrite(ast, context) {\n      this.visit(ast.obj, context);\n      this.visit(ast.key, context);\n      this.visit(ast.value, context);\n    }\n  }, {\n    key: \"visitLiteralArray\",\n    value: function visitLiteralArray(ast, context) {\n      this.visitAll(ast.expressions, context);\n    }\n  }, {\n    key: \"visitLiteralMap\",\n    value: function visitLiteralMap(ast, context) {\n      this.visitAll(ast.values, context);\n    }\n  }, {\n    key: \"visitLiteralPrimitive\",\n    value: function visitLiteralPrimitive(ast, context) {}\n  }, {\n    key: \"visitMethodCall\",\n    value: function visitMethodCall(ast, context) {\n      this.visit(ast.receiver, context);\n      this.visitAll(ast.args, context);\n    }\n  }, {\n    key: \"visitPrefixNot\",\n    value: function visitPrefixNot(ast, context) {\n      this.visit(ast.expression, context);\n    }\n  }, {\n    key: \"visitNonNullAssert\",\n    value: function visitNonNullAssert(ast, context) {\n      this.visit(ast.expression, context);\n    }\n  }, {\n    key: \"visitPropertyRead\",\n    value: function visitPropertyRead(ast, context) {\n      this.visit(ast.receiver, context);\n    }\n  }, {\n    key: \"visitPropertyWrite\",\n    value: function visitPropertyWrite(ast, context) {\n      this.visit(ast.receiver, context);\n      this.visit(ast.value, context);\n    }\n  }, {\n    key: \"visitSafePropertyRead\",\n    value: function visitSafePropertyRead(ast, context) {\n      this.visit(ast.receiver, context);\n    }\n  }, {\n    key: \"visitSafeMethodCall\",\n    value: function visitSafeMethodCall(ast, context) {\n      this.visit(ast.receiver, context);\n      this.visitAll(ast.args, context);\n    }\n  }, {\n    key: \"visitQuote\",\n    value: function visitQuote(ast, context) {} // This is not part of the AstVisitor interface, just a helper method\n\n  }, {\n    key: \"visitAll\",\n    value: function visitAll(asts, context) {\n      var _iterator6 = _createForOfIteratorHelper(asts),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var ast = _step6.value;\n          this.visit(ast, context);\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n    }\n  }]);\n\n  return RecursiveAstVisitor$1;\n}();\n\nvar AstTransformer$1 = /*#__PURE__*/function () {\n  function AstTransformer$1() {\n    _classCallCheck(this, AstTransformer$1);\n  }\n\n  _createClass(AstTransformer$1, [{\n    key: \"visitImplicitReceiver\",\n    value: function visitImplicitReceiver(ast, context) {\n      return ast;\n    }\n  }, {\n    key: \"visitInterpolation\",\n    value: function visitInterpolation(ast, context) {\n      return new Interpolation(ast.span, ast.sourceSpan, ast.strings, this.visitAll(ast.expressions));\n    }\n  }, {\n    key: \"visitLiteralPrimitive\",\n    value: function visitLiteralPrimitive(ast, context) {\n      return new LiteralPrimitive(ast.span, ast.sourceSpan, ast.value);\n    }\n  }, {\n    key: \"visitPropertyRead\",\n    value: function visitPropertyRead(ast, context) {\n      return new PropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name);\n    }\n  }, {\n    key: \"visitPropertyWrite\",\n    value: function visitPropertyWrite(ast, context) {\n      return new PropertyWrite(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name, ast.value.visit(this));\n    }\n  }, {\n    key: \"visitSafePropertyRead\",\n    value: function visitSafePropertyRead(ast, context) {\n      return new SafePropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name);\n    }\n  }, {\n    key: \"visitMethodCall\",\n    value: function visitMethodCall(ast, context) {\n      return new MethodCall(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name, this.visitAll(ast.args));\n    }\n  }, {\n    key: \"visitSafeMethodCall\",\n    value: function visitSafeMethodCall(ast, context) {\n      return new SafeMethodCall(ast.span, ast.sourceSpan, ast.nameSpan, ast.receiver.visit(this), ast.name, this.visitAll(ast.args));\n    }\n  }, {\n    key: \"visitFunctionCall\",\n    value: function visitFunctionCall(ast, context) {\n      return new FunctionCall(ast.span, ast.sourceSpan, ast.target.visit(this), this.visitAll(ast.args));\n    }\n  }, {\n    key: \"visitLiteralArray\",\n    value: function visitLiteralArray(ast, context) {\n      return new LiteralArray(ast.span, ast.sourceSpan, this.visitAll(ast.expressions));\n    }\n  }, {\n    key: \"visitLiteralMap\",\n    value: function visitLiteralMap(ast, context) {\n      return new LiteralMap(ast.span, ast.sourceSpan, ast.keys, this.visitAll(ast.values));\n    }\n  }, {\n    key: \"visitBinary\",\n    value: function visitBinary(ast, context) {\n      return new Binary(ast.span, ast.sourceSpan, ast.operation, ast.left.visit(this), ast.right.visit(this));\n    }\n  }, {\n    key: \"visitPrefixNot\",\n    value: function visitPrefixNot(ast, context) {\n      return new PrefixNot(ast.span, ast.sourceSpan, ast.expression.visit(this));\n    }\n  }, {\n    key: \"visitNonNullAssert\",\n    value: function visitNonNullAssert(ast, context) {\n      return new NonNullAssert(ast.span, ast.sourceSpan, ast.expression.visit(this));\n    }\n  }, {\n    key: \"visitConditional\",\n    value: function visitConditional(ast, context) {\n      return new Conditional(ast.span, ast.sourceSpan, ast.condition.visit(this), ast.trueExp.visit(this), ast.falseExp.visit(this));\n    }\n  }, {\n    key: \"visitPipe\",\n    value: function visitPipe(ast, context) {\n      return new BindingPipe(ast.span, ast.sourceSpan, ast.exp.visit(this), ast.name, this.visitAll(ast.args), ast.nameSpan);\n    }\n  }, {\n    key: \"visitKeyedRead\",\n    value: function visitKeyedRead(ast, context) {\n      return new KeyedRead(ast.span, ast.sourceSpan, ast.obj.visit(this), ast.key.visit(this));\n    }\n  }, {\n    key: \"visitKeyedWrite\",\n    value: function visitKeyedWrite(ast, context) {\n      return new KeyedWrite(ast.span, ast.sourceSpan, ast.obj.visit(this), ast.key.visit(this), ast.value.visit(this));\n    }\n  }, {\n    key: \"visitAll\",\n    value: function visitAll(asts) {\n      var res = [];\n\n      for (var i = 0; i < asts.length; ++i) {\n        res[i] = asts[i].visit(this);\n      }\n\n      return res;\n    }\n  }, {\n    key: \"visitChain\",\n    value: function visitChain(ast, context) {\n      return new Chain(ast.span, ast.sourceSpan, this.visitAll(ast.expressions));\n    }\n  }, {\n    key: \"visitQuote\",\n    value: function visitQuote(ast, context) {\n      return new Quote(ast.span, ast.sourceSpan, ast.prefix, ast.uninterpretedExpression, ast.location);\n    }\n  }]);\n\n  return AstTransformer$1;\n}(); // A transformer that only creates new nodes if the transformer makes a change or\n// a change is made a child node.\n\n\nvar AstMemoryEfficientTransformer = /*#__PURE__*/function () {\n  function AstMemoryEfficientTransformer() {\n    _classCallCheck(this, AstMemoryEfficientTransformer);\n  }\n\n  _createClass(AstMemoryEfficientTransformer, [{\n    key: \"visitImplicitReceiver\",\n    value: function visitImplicitReceiver(ast, context) {\n      return ast;\n    }\n  }, {\n    key: \"visitInterpolation\",\n    value: function visitInterpolation(ast, context) {\n      var expressions = this.visitAll(ast.expressions);\n      if (expressions !== ast.expressions) return new Interpolation(ast.span, ast.sourceSpan, ast.strings, expressions);\n      return ast;\n    }\n  }, {\n    key: \"visitLiteralPrimitive\",\n    value: function visitLiteralPrimitive(ast, context) {\n      return ast;\n    }\n  }, {\n    key: \"visitPropertyRead\",\n    value: function visitPropertyRead(ast, context) {\n      var receiver = ast.receiver.visit(this);\n\n      if (receiver !== ast.receiver) {\n        return new PropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name);\n      }\n\n      return ast;\n    }\n  }, {\n    key: \"visitPropertyWrite\",\n    value: function visitPropertyWrite(ast, context) {\n      var receiver = ast.receiver.visit(this);\n      var value = ast.value.visit(this);\n\n      if (receiver !== ast.receiver || value !== ast.value) {\n        return new PropertyWrite(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name, value);\n      }\n\n      return ast;\n    }\n  }, {\n    key: \"visitSafePropertyRead\",\n    value: function visitSafePropertyRead(ast, context) {\n      var receiver = ast.receiver.visit(this);\n\n      if (receiver !== ast.receiver) {\n        return new SafePropertyRead(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name);\n      }\n\n      return ast;\n    }\n  }, {\n    key: \"visitMethodCall\",\n    value: function visitMethodCall(ast, context) {\n      var receiver = ast.receiver.visit(this);\n      var args = this.visitAll(ast.args);\n\n      if (receiver !== ast.receiver || args !== ast.args) {\n        return new MethodCall(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name, args);\n      }\n\n      return ast;\n    }\n  }, {\n    key: \"visitSafeMethodCall\",\n    value: function visitSafeMethodCall(ast, context) {\n      var receiver = ast.receiver.visit(this);\n      var args = this.visitAll(ast.args);\n\n      if (receiver !== ast.receiver || args !== ast.args) {\n        return new SafeMethodCall(ast.span, ast.sourceSpan, ast.nameSpan, receiver, ast.name, args);\n      }\n\n      return ast;\n    }\n  }, {\n    key: \"visitFunctionCall\",\n    value: function visitFunctionCall(ast, context) {\n      var target = ast.target && ast.target.visit(this);\n      var args = this.visitAll(ast.args);\n\n      if (target !== ast.target || args !== ast.args) {\n        return new FunctionCall(ast.span, ast.sourceSpan, target, args);\n      }\n\n      return ast;\n    }\n  }, {\n    key: \"visitLiteralArray\",\n    value: function visitLiteralArray(ast, context) {\n      var expressions = this.visitAll(ast.expressions);\n\n      if (expressions !== ast.expressions) {\n        return new LiteralArray(ast.span, ast.sourceSpan, expressions);\n      }\n\n      return ast;\n    }\n  }, {\n    key: \"visitLiteralMap\",\n    value: function visitLiteralMap(ast, context) {\n      var values = this.visitAll(ast.values);\n\n      if (values !== ast.values) {\n        return new LiteralMap(ast.span, ast.sourceSpan, ast.keys, values);\n      }\n\n      return ast;\n    }\n  }, {\n    key: \"visitBinary\",\n    value: function visitBinary(ast, context) {\n      var left = ast.left.visit(this);\n      var right = ast.right.visit(this);\n\n      if (left !== ast.left || right !== ast.right) {\n        return new Binary(ast.span, ast.sourceSpan, ast.operation, left, right);\n      }\n\n      return ast;\n    }\n  }, {\n    key: \"visitPrefixNot\",\n    value: function visitPrefixNot(ast, context) {\n      var expression = ast.expression.visit(this);\n\n      if (expression !== ast.expression) {\n        return new PrefixNot(ast.span, ast.sourceSpan, expression);\n      }\n\n      return ast;\n    }\n  }, {\n    key: \"visitNonNullAssert\",\n    value: function visitNonNullAssert(ast, context) {\n      var expression = ast.expression.visit(this);\n\n      if (expression !== ast.expression) {\n        return new NonNullAssert(ast.span, ast.sourceSpan, expression);\n      }\n\n      return ast;\n    }\n  }, {\n    key: \"visitConditional\",\n    value: function visitConditional(ast, context) {\n      var condition = ast.condition.visit(this);\n      var trueExp = ast.trueExp.visit(this);\n      var falseExp = ast.falseExp.visit(this);\n\n      if (condition !== ast.condition || trueExp !== ast.trueExp || falseExp !== ast.falseExp) {\n        return new Conditional(ast.span, ast.sourceSpan, condition, trueExp, falseExp);\n      }\n\n      return ast;\n    }\n  }, {\n    key: \"visitPipe\",\n    value: function visitPipe(ast, context) {\n      var exp = ast.exp.visit(this);\n      var args = this.visitAll(ast.args);\n\n      if (exp !== ast.exp || args !== ast.args) {\n        return new BindingPipe(ast.span, ast.sourceSpan, exp, ast.name, args, ast.nameSpan);\n      }\n\n      return ast;\n    }\n  }, {\n    key: \"visitKeyedRead\",\n    value: function visitKeyedRead(ast, context) {\n      var obj = ast.obj.visit(this);\n      var key = ast.key.visit(this);\n\n      if (obj !== ast.obj || key !== ast.key) {\n        return new KeyedRead(ast.span, ast.sourceSpan, obj, key);\n      }\n\n      return ast;\n    }\n  }, {\n    key: \"visitKeyedWrite\",\n    value: function visitKeyedWrite(ast, context) {\n      var obj = ast.obj.visit(this);\n      var key = ast.key.visit(this);\n      var value = ast.value.visit(this);\n\n      if (obj !== ast.obj || key !== ast.key || value !== ast.value) {\n        return new KeyedWrite(ast.span, ast.sourceSpan, obj, key, value);\n      }\n\n      return ast;\n    }\n  }, {\n    key: \"visitAll\",\n    value: function visitAll(asts) {\n      var res = [];\n      var modified = false;\n\n      for (var i = 0; i < asts.length; ++i) {\n        var original = asts[i];\n        var value = original.visit(this);\n        res[i] = value;\n        modified = modified || value !== original;\n      }\n\n      return modified ? res : asts;\n    }\n  }, {\n    key: \"visitChain\",\n    value: function visitChain(ast, context) {\n      var expressions = this.visitAll(ast.expressions);\n\n      if (expressions !== ast.expressions) {\n        return new Chain(ast.span, ast.sourceSpan, expressions);\n      }\n\n      return ast;\n    }\n  }, {\n    key: \"visitQuote\",\n    value: function visitQuote(ast, context) {\n      return ast;\n    }\n  }]);\n\n  return AstMemoryEfficientTransformer;\n}(); // Bindings\n\n\nvar ParsedProperty = function ParsedProperty(name, expression, type, sourceSpan, valueSpan) {\n  _classCallCheck(this, ParsedProperty);\n\n  this.name = name;\n  this.expression = expression;\n  this.type = type;\n  this.sourceSpan = sourceSpan;\n  this.valueSpan = valueSpan;\n  this.isLiteral = this.type === ParsedPropertyType.LITERAL_ATTR;\n  this.isAnimation = this.type === ParsedPropertyType.ANIMATION;\n};\n\nvar ParsedPropertyType;\n\n(function (ParsedPropertyType) {\n  ParsedPropertyType[ParsedPropertyType[\"DEFAULT\"] = 0] = \"DEFAULT\";\n  ParsedPropertyType[ParsedPropertyType[\"LITERAL_ATTR\"] = 1] = \"LITERAL_ATTR\";\n  ParsedPropertyType[ParsedPropertyType[\"ANIMATION\"] = 2] = \"ANIMATION\";\n})(ParsedPropertyType || (ParsedPropertyType = {}));\n\nvar ParsedEvent = // Regular events have a target\n// Animation events have a phase\nfunction ParsedEvent(name, targetOrPhase, type, handler, sourceSpan, handlerSpan) {\n  _classCallCheck(this, ParsedEvent);\n\n  this.name = name;\n  this.targetOrPhase = targetOrPhase;\n  this.type = type;\n  this.handler = handler;\n  this.sourceSpan = sourceSpan;\n  this.handlerSpan = handlerSpan;\n};\n/**\n * ParsedVariable represents a variable declaration in a microsyntax expression.\n */\n\n\nvar ParsedVariable = function ParsedVariable(name, value, sourceSpan, keySpan, valueSpan) {\n  _classCallCheck(this, ParsedVariable);\n\n  this.name = name;\n  this.value = value;\n  this.sourceSpan = sourceSpan;\n  this.keySpan = keySpan;\n  this.valueSpan = valueSpan;\n};\n\nvar BoundElementProperty = function BoundElementProperty(name, type, securityContext, value, unit, sourceSpan, valueSpan) {\n  _classCallCheck(this, BoundElementProperty);\n\n  this.name = name;\n  this.type = type;\n  this.securityContext = securityContext;\n  this.value = value;\n  this.unit = unit;\n  this.sourceSpan = sourceSpan;\n  this.valueSpan = valueSpan;\n};\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar EventHandlerVars = function EventHandlerVars() {\n  _classCallCheck(this, EventHandlerVars);\n};\n\nEventHandlerVars.event = variable('$event');\n\nvar ConvertActionBindingResult = function ConvertActionBindingResult(\n/**\n * Render2 compatible statements,\n */\nstmts,\n/**\n * Variable name used with render2 compatible statements.\n */\nallowDefault) {\n  _classCallCheck(this, ConvertActionBindingResult);\n\n  this.stmts = stmts;\n  this.allowDefault = allowDefault;\n  /**\n   * This is bit of a hack. It converts statements which render2 expects to statements which are\n   * expected by render3.\n   *\n   * Example: `<div click=\"doSomething($event)\">` will generate:\n   *\n   * Render3:\n   * ```\n   * const pd_b:any = ((<any>ctx.doSomething($event)) !== false);\n   * return pd_b;\n   * ```\n   *\n   * but render2 expects:\n   * ```\n   * return ctx.doSomething($event);\n   * ```\n   */\n  // TODO(misko): remove this hack once we no longer support ViewEngine.\n\n  this.render3Stmts = stmts.map(function (statement) {\n    if (statement instanceof DeclareVarStmt && statement.name == allowDefault.name && statement.value instanceof BinaryOperatorExpr) {\n      var lhs = statement.value.lhs;\n      return new ReturnStatement(lhs.value);\n    }\n\n    return statement;\n  });\n};\n/**\n * Converts the given expression AST into an executable output AST, assuming the expression is\n * used in an action binding (e.g. an event handler).\n */\n\n\nfunction convertActionBinding(localResolver, implicitReceiver, action, bindingId, interpolationFunction, baseSourceSpan, implicitReceiverAccesses) {\n  if (!localResolver) {\n    localResolver = new DefaultLocalResolver();\n  }\n\n  var actionWithoutBuiltins = convertPropertyBindingBuiltins({\n    createLiteralArrayConverter: function createLiteralArrayConverter(argCount) {\n      // Note: no caching for literal arrays in actions.\n      return function (args) {\n        return literalArr(args);\n      };\n    },\n    createLiteralMapConverter: function createLiteralMapConverter(keys) {\n      // Note: no caching for literal maps in actions.\n      return function (values) {\n        var entries = keys.map(function (k, i) {\n          return {\n            key: k.key,\n            value: values[i],\n            quoted: k.quoted\n          };\n        });\n        return literalMap(entries);\n      };\n    },\n    createPipeConverter: function createPipeConverter(name) {\n      throw new Error(\"Illegal State: Actions are not allowed to contain pipes. Pipe: \".concat(name));\n    }\n  }, action);\n  var visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId, interpolationFunction, baseSourceSpan, implicitReceiverAccesses);\n  var actionStmts = [];\n  flattenStatements(actionWithoutBuiltins.visit(visitor, _Mode.Statement), actionStmts);\n  prependTemporaryDecls(visitor.temporaryCount, bindingId, actionStmts);\n\n  if (visitor.usesImplicitReceiver) {\n    localResolver.notifyImplicitReceiverUse();\n  }\n\n  var lastIndex = actionStmts.length - 1;\n  var preventDefaultVar = null;\n\n  if (lastIndex >= 0) {\n    var lastStatement = actionStmts[lastIndex];\n    var returnExpr = convertStmtIntoExpression(lastStatement);\n\n    if (returnExpr) {\n      // Note: We need to cast the result of the method call to dynamic,\n      // as it might be a void method!\n      preventDefaultVar = createPreventDefaultVar(bindingId);\n      actionStmts[lastIndex] = preventDefaultVar.set(returnExpr.cast(DYNAMIC_TYPE).notIdentical(literal(false))).toDeclStmt(null, [StmtModifier.Final]);\n    }\n  }\n\n  return new ConvertActionBindingResult(actionStmts, preventDefaultVar);\n}\n\nfunction convertPropertyBindingBuiltins(converterFactory, ast) {\n  return convertBuiltins(converterFactory, ast);\n}\n\nvar ConvertPropertyBindingResult = function ConvertPropertyBindingResult(stmts, currValExpr) {\n  _classCallCheck(this, ConvertPropertyBindingResult);\n\n  this.stmts = stmts;\n  this.currValExpr = currValExpr;\n};\n\nvar BindingForm;\n\n(function (BindingForm) {\n  // The general form of binding expression, supports all expressions.\n  BindingForm[BindingForm[\"General\"] = 0] = \"General\"; // Try to generate a simple binding (no temporaries or statements)\n  // otherwise generate a general binding\n\n  BindingForm[BindingForm[\"TrySimple\"] = 1] = \"TrySimple\";\n})(BindingForm || (BindingForm = {}));\n/**\n * Converts the given expression AST into an executable output AST, assuming the expression\n * is used in property binding. The expression has to be preprocessed via\n * `convertPropertyBindingBuiltins`.\n */\n\n\nfunction _convertPropertyBinding(localResolver, implicitReceiver, expressionWithoutBuiltins, bindingId, form, interpolationFunction) {\n  if (!localResolver) {\n    localResolver = new DefaultLocalResolver();\n  }\n\n  var currValExpr = createCurrValueExpr(bindingId);\n  var visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId, interpolationFunction);\n  var outputExpr = expressionWithoutBuiltins.visit(visitor, _Mode.Expression);\n  var stmts = getStatementsFromVisitor(visitor, bindingId);\n\n  if (visitor.usesImplicitReceiver) {\n    localResolver.notifyImplicitReceiverUse();\n  }\n\n  if (visitor.temporaryCount === 0 && form == BindingForm.TrySimple) {\n    return new ConvertPropertyBindingResult([], outputExpr);\n  }\n\n  stmts.push(currValExpr.set(outputExpr).toDeclStmt(DYNAMIC_TYPE, [StmtModifier.Final]));\n  return new ConvertPropertyBindingResult(stmts, currValExpr);\n}\n/**\n * Given some expression, such as a binding or interpolation expression, and a context expression to\n * look values up on, visit each facet of the given expression resolving values from the context\n * expression such that a list of arguments can be derived from the found values that can be used as\n * arguments to an external update instruction.\n *\n * @param localResolver The resolver to use to look up expressions by name appropriately\n * @param contextVariableExpression The expression representing the context variable used to create\n * the final argument expressions\n * @param expressionWithArgumentsToExtract The expression to visit to figure out what values need to\n * be resolved and what arguments list to build.\n * @param bindingId A name prefix used to create temporary variable names if they're needed for the\n * arguments generated\n * @returns An array of expressions that can be passed as arguments to instruction expressions like\n * `o.importExpr(R3.propertyInterpolate).callFn(result)`\n */\n\n\nfunction convertUpdateArguments(localResolver, contextVariableExpression, expressionWithArgumentsToExtract, bindingId) {\n  var visitor = new _AstToIrVisitor(localResolver, contextVariableExpression, bindingId, undefined);\n  var outputExpr = expressionWithArgumentsToExtract.visit(visitor, _Mode.Expression);\n\n  if (visitor.usesImplicitReceiver) {\n    localResolver.notifyImplicitReceiverUse();\n  }\n\n  var stmts = getStatementsFromVisitor(visitor, bindingId); // Removing the first argument, because it was a length for ViewEngine, not Ivy.\n\n  var args = outputExpr.args.slice(1);\n\n  if (expressionWithArgumentsToExtract instanceof Interpolation) {\n    // If we're dealing with an interpolation of 1 value with an empty prefix and suffix, reduce the\n    // args returned to just the value, because we're going to pass it to a special instruction.\n    var strings = expressionWithArgumentsToExtract.strings;\n\n    if (args.length === 3 && strings[0] === '' && strings[1] === '') {\n      // Single argument interpolate instructions.\n      args = [args[1]];\n    } else if (args.length >= 19) {\n      // 19 or more arguments must be passed to the `interpolateV`-style instructions, which accept\n      // an array of arguments\n      args = [literalArr(args)];\n    }\n  }\n\n  return {\n    stmts: stmts,\n    args: args\n  };\n}\n\nfunction getStatementsFromVisitor(visitor, bindingId) {\n  var stmts = [];\n\n  for (var i = 0; i < visitor.temporaryCount; i++) {\n    stmts.push(temporaryDeclaration(bindingId, i));\n  }\n\n  return stmts;\n}\n\nfunction convertBuiltins(converterFactory, ast) {\n  var visitor = new _BuiltinAstConverter(converterFactory);\n  return ast.visit(visitor);\n}\n\nfunction temporaryName(bindingId, temporaryNumber) {\n  return \"tmp_\".concat(bindingId, \"_\").concat(temporaryNumber);\n}\n\nfunction temporaryDeclaration(bindingId, temporaryNumber) {\n  return new DeclareVarStmt(temporaryName(bindingId, temporaryNumber), NULL_EXPR);\n}\n\nfunction prependTemporaryDecls(temporaryCount, bindingId, statements) {\n  for (var i = temporaryCount - 1; i >= 0; i--) {\n    statements.unshift(temporaryDeclaration(bindingId, i));\n  }\n}\n\nvar _Mode;\n\n(function (_Mode) {\n  _Mode[_Mode[\"Statement\"] = 0] = \"Statement\";\n  _Mode[_Mode[\"Expression\"] = 1] = \"Expression\";\n})(_Mode || (_Mode = {}));\n\nfunction ensureStatementMode(mode, ast) {\n  if (mode !== _Mode.Statement) {\n    throw new Error(\"Expected a statement, but saw \".concat(ast));\n  }\n}\n\nfunction ensureExpressionMode(mode, ast) {\n  if (mode !== _Mode.Expression) {\n    throw new Error(\"Expected an expression, but saw \".concat(ast));\n  }\n}\n\nfunction convertToStatementIfNeeded(mode, expr) {\n  if (mode === _Mode.Statement) {\n    return expr.toStmt();\n  } else {\n    return expr;\n  }\n}\n\nvar _BuiltinAstConverter = /*#__PURE__*/function (_AstTransformer$) {\n  _inherits(_BuiltinAstConverter, _AstTransformer$);\n\n  var _super74 = _createSuper(_BuiltinAstConverter);\n\n  function _BuiltinAstConverter(_converterFactory) {\n    var _this107;\n\n    _classCallCheck(this, _BuiltinAstConverter);\n\n    _this107 = _super74.call(this);\n    _this107._converterFactory = _converterFactory;\n    return _this107;\n  }\n\n  _createClass(_BuiltinAstConverter, [{\n    key: \"visitPipe\",\n    value: function visitPipe(ast, context) {\n      var _this108 = this;\n\n      var args = [ast.exp].concat(_toConsumableArray(ast.args)).map(function (ast) {\n        return ast.visit(_this108, context);\n      });\n      return new BuiltinFunctionCall(ast.span, ast.sourceSpan, args, this._converterFactory.createPipeConverter(ast.name, args.length));\n    }\n  }, {\n    key: \"visitLiteralArray\",\n    value: function visitLiteralArray(ast, context) {\n      var _this109 = this;\n\n      var args = ast.expressions.map(function (ast) {\n        return ast.visit(_this109, context);\n      });\n      return new BuiltinFunctionCall(ast.span, ast.sourceSpan, args, this._converterFactory.createLiteralArrayConverter(ast.expressions.length));\n    }\n  }, {\n    key: \"visitLiteralMap\",\n    value: function visitLiteralMap(ast, context) {\n      var _this110 = this;\n\n      var args = ast.values.map(function (ast) {\n        return ast.visit(_this110, context);\n      });\n      return new BuiltinFunctionCall(ast.span, ast.sourceSpan, args, this._converterFactory.createLiteralMapConverter(ast.keys));\n    }\n  }]);\n\n  return _BuiltinAstConverter;\n}(AstTransformer$1);\n\nvar _AstToIrVisitor = /*#__PURE__*/function () {\n  function _AstToIrVisitor(_localResolver, _implicitReceiver, bindingId, interpolationFunction, baseSourceSpan, implicitReceiverAccesses) {\n    _classCallCheck(this, _AstToIrVisitor);\n\n    this._localResolver = _localResolver;\n    this._implicitReceiver = _implicitReceiver;\n    this.bindingId = bindingId;\n    this.interpolationFunction = interpolationFunction;\n    this.baseSourceSpan = baseSourceSpan;\n    this.implicitReceiverAccesses = implicitReceiverAccesses;\n    this._nodeMap = new Map();\n    this._resultMap = new Map();\n    this._currentTemporary = 0;\n    this.temporaryCount = 0;\n    this.usesImplicitReceiver = false;\n  }\n\n  _createClass(_AstToIrVisitor, [{\n    key: \"visitBinary\",\n    value: function visitBinary(ast, mode) {\n      var op;\n\n      switch (ast.operation) {\n        case '+':\n          op = BinaryOperator.Plus;\n          break;\n\n        case '-':\n          op = BinaryOperator.Minus;\n          break;\n\n        case '*':\n          op = BinaryOperator.Multiply;\n          break;\n\n        case '/':\n          op = BinaryOperator.Divide;\n          break;\n\n        case '%':\n          op = BinaryOperator.Modulo;\n          break;\n\n        case '&&':\n          op = BinaryOperator.And;\n          break;\n\n        case '||':\n          op = BinaryOperator.Or;\n          break;\n\n        case '==':\n          op = BinaryOperator.Equals;\n          break;\n\n        case '!=':\n          op = BinaryOperator.NotEquals;\n          break;\n\n        case '===':\n          op = BinaryOperator.Identical;\n          break;\n\n        case '!==':\n          op = BinaryOperator.NotIdentical;\n          break;\n\n        case '<':\n          op = BinaryOperator.Lower;\n          break;\n\n        case '>':\n          op = BinaryOperator.Bigger;\n          break;\n\n        case '<=':\n          op = BinaryOperator.LowerEquals;\n          break;\n\n        case '>=':\n          op = BinaryOperator.BiggerEquals;\n          break;\n\n        default:\n          throw new Error(\"Unsupported operation \".concat(ast.operation));\n      }\n\n      return convertToStatementIfNeeded(mode, new BinaryOperatorExpr(op, this._visit(ast.left, _Mode.Expression), this._visit(ast.right, _Mode.Expression), undefined, this.convertSourceSpan(ast.span)));\n    }\n  }, {\n    key: \"visitChain\",\n    value: function visitChain(ast, mode) {\n      ensureStatementMode(mode, ast);\n      return this.visitAll(ast.expressions, mode);\n    }\n  }, {\n    key: \"visitConditional\",\n    value: function visitConditional(ast, mode) {\n      var value = this._visit(ast.condition, _Mode.Expression);\n\n      return convertToStatementIfNeeded(mode, value.conditional(this._visit(ast.trueExp, _Mode.Expression), this._visit(ast.falseExp, _Mode.Expression), this.convertSourceSpan(ast.span)));\n    }\n  }, {\n    key: \"visitPipe\",\n    value: function visitPipe(ast, mode) {\n      throw new Error(\"Illegal state: Pipes should have been converted into functions. Pipe: \".concat(ast.name));\n    }\n  }, {\n    key: \"visitFunctionCall\",\n    value: function visitFunctionCall(ast, mode) {\n      var convertedArgs = this.visitAll(ast.args, _Mode.Expression);\n      var fnResult;\n\n      if (ast instanceof BuiltinFunctionCall) {\n        fnResult = ast.converter(convertedArgs);\n      } else {\n        fnResult = this._visit(ast.target, _Mode.Expression).callFn(convertedArgs, this.convertSourceSpan(ast.span));\n      }\n\n      return convertToStatementIfNeeded(mode, fnResult);\n    }\n  }, {\n    key: \"visitImplicitReceiver\",\n    value: function visitImplicitReceiver(ast, mode) {\n      ensureExpressionMode(mode, ast);\n      this.usesImplicitReceiver = true;\n      return this._implicitReceiver;\n    }\n  }, {\n    key: \"visitInterpolation\",\n    value: function visitInterpolation(ast, mode) {\n      ensureExpressionMode(mode, ast);\n      var args = [literal(ast.expressions.length)];\n\n      for (var i = 0; i < ast.strings.length - 1; i++) {\n        args.push(literal(ast.strings[i]));\n        args.push(this._visit(ast.expressions[i], _Mode.Expression));\n      }\n\n      args.push(literal(ast.strings[ast.strings.length - 1]));\n\n      if (this.interpolationFunction) {\n        return this.interpolationFunction(args);\n      }\n\n      return ast.expressions.length <= 9 ? importExpr(Identifiers.inlineInterpolate).callFn(args) : importExpr(Identifiers.interpolate).callFn([args[0], literalArr(args.slice(1), undefined, this.convertSourceSpan(ast.span))]);\n    }\n  }, {\n    key: \"visitKeyedRead\",\n    value: function visitKeyedRead(ast, mode) {\n      var leftMostSafe = this.leftMostSafeNode(ast);\n\n      if (leftMostSafe) {\n        return this.convertSafeAccess(ast, leftMostSafe, mode);\n      } else {\n        return convertToStatementIfNeeded(mode, this._visit(ast.obj, _Mode.Expression).key(this._visit(ast.key, _Mode.Expression)));\n      }\n    }\n  }, {\n    key: \"visitKeyedWrite\",\n    value: function visitKeyedWrite(ast, mode) {\n      var obj = this._visit(ast.obj, _Mode.Expression);\n\n      var key = this._visit(ast.key, _Mode.Expression);\n\n      var value = this._visit(ast.value, _Mode.Expression);\n\n      return convertToStatementIfNeeded(mode, obj.key(key).set(value));\n    }\n  }, {\n    key: \"visitLiteralArray\",\n    value: function visitLiteralArray(ast, mode) {\n      throw new Error(\"Illegal State: literal arrays should have been converted into functions\");\n    }\n  }, {\n    key: \"visitLiteralMap\",\n    value: function visitLiteralMap(ast, mode) {\n      throw new Error(\"Illegal State: literal maps should have been converted into functions\");\n    }\n  }, {\n    key: \"visitLiteralPrimitive\",\n    value: function visitLiteralPrimitive(ast, mode) {\n      // For literal values of null, undefined, true, or false allow type interference\n      // to infer the type.\n      var type = ast.value === null || ast.value === undefined || ast.value === true || ast.value === true ? INFERRED_TYPE : undefined;\n      return convertToStatementIfNeeded(mode, literal(ast.value, type, this.convertSourceSpan(ast.span)));\n    }\n  }, {\n    key: \"_getLocal\",\n    value: function _getLocal(name) {\n      return this._localResolver.getLocal(name);\n    }\n  }, {\n    key: \"visitMethodCall\",\n    value: function visitMethodCall(ast, mode) {\n      if (ast.receiver instanceof ImplicitReceiver && ast.name == '$any') {\n        var args = this.visitAll(ast.args, _Mode.Expression);\n\n        if (args.length != 1) {\n          throw new Error(\"Invalid call to $any, expected 1 argument but received \".concat(args.length || 'none'));\n        }\n\n        return args[0].cast(DYNAMIC_TYPE, this.convertSourceSpan(ast.span));\n      }\n\n      var leftMostSafe = this.leftMostSafeNode(ast);\n\n      if (leftMostSafe) {\n        return this.convertSafeAccess(ast, leftMostSafe, mode);\n      } else {\n        var _args = this.visitAll(ast.args, _Mode.Expression);\n\n        var prevUsesImplicitReceiver = this.usesImplicitReceiver;\n        var result = null;\n\n        var receiver = this._visit(ast.receiver, _Mode.Expression);\n\n        if (receiver === this._implicitReceiver) {\n          var varExpr = this._getLocal(ast.name);\n\n          if (varExpr) {\n            // Restore the previous \"usesImplicitReceiver\" state since the implicit\n            // receiver has been replaced with a resolved local expression.\n            this.usesImplicitReceiver = prevUsesImplicitReceiver;\n            result = varExpr.callFn(_args);\n          }\n\n          this.addImplicitReceiverAccess(ast.name);\n        }\n\n        if (result == null) {\n          result = receiver.callMethod(ast.name, _args, this.convertSourceSpan(ast.span));\n        }\n\n        return convertToStatementIfNeeded(mode, result);\n      }\n    }\n  }, {\n    key: \"visitPrefixNot\",\n    value: function visitPrefixNot(ast, mode) {\n      return convertToStatementIfNeeded(mode, not(this._visit(ast.expression, _Mode.Expression)));\n    }\n  }, {\n    key: \"visitNonNullAssert\",\n    value: function visitNonNullAssert(ast, mode) {\n      return convertToStatementIfNeeded(mode, assertNotNull(this._visit(ast.expression, _Mode.Expression)));\n    }\n  }, {\n    key: \"visitPropertyRead\",\n    value: function visitPropertyRead(ast, mode) {\n      var leftMostSafe = this.leftMostSafeNode(ast);\n\n      if (leftMostSafe) {\n        return this.convertSafeAccess(ast, leftMostSafe, mode);\n      } else {\n        var result = null;\n        var prevUsesImplicitReceiver = this.usesImplicitReceiver;\n\n        var receiver = this._visit(ast.receiver, _Mode.Expression);\n\n        if (receiver === this._implicitReceiver) {\n          result = this._getLocal(ast.name);\n\n          if (result) {\n            // Restore the previous \"usesImplicitReceiver\" state since the implicit\n            // receiver has been replaced with a resolved local expression.\n            this.usesImplicitReceiver = prevUsesImplicitReceiver;\n          }\n\n          this.addImplicitReceiverAccess(ast.name);\n        }\n\n        if (result == null) {\n          result = receiver.prop(ast.name);\n        }\n\n        return convertToStatementIfNeeded(mode, result);\n      }\n    }\n  }, {\n    key: \"visitPropertyWrite\",\n    value: function visitPropertyWrite(ast, mode) {\n      var receiver = this._visit(ast.receiver, _Mode.Expression);\n\n      var prevUsesImplicitReceiver = this.usesImplicitReceiver;\n      var varExpr = null;\n\n      if (receiver === this._implicitReceiver) {\n        var localExpr = this._getLocal(ast.name);\n\n        if (localExpr) {\n          if (localExpr instanceof ReadPropExpr) {\n            // If the local variable is a property read expression, it's a reference\n            // to a 'context.property' value and will be used as the target of the\n            // write expression.\n            varExpr = localExpr; // Restore the previous \"usesImplicitReceiver\" state since the implicit\n            // receiver has been replaced with a resolved local expression.\n\n            this.usesImplicitReceiver = prevUsesImplicitReceiver;\n            this.addImplicitReceiverAccess(ast.name);\n          } else {\n            // Otherwise it's an error.\n            var _receiver = ast.name;\n            var value = ast.value instanceof PropertyRead ? ast.value.name : undefined;\n            throw new Error(\"Cannot assign value \\\"\".concat(value, \"\\\" to template variable \\\"\").concat(_receiver, \"\\\". Template variables are read-only.\"));\n          }\n        }\n      } // If no local expression could be produced, use the original receiver's\n      // property as the target.\n\n\n      if (varExpr === null) {\n        varExpr = receiver.prop(ast.name);\n      }\n\n      return convertToStatementIfNeeded(mode, varExpr.set(this._visit(ast.value, _Mode.Expression)));\n    }\n  }, {\n    key: \"visitSafePropertyRead\",\n    value: function visitSafePropertyRead(ast, mode) {\n      return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n    }\n  }, {\n    key: \"visitSafeMethodCall\",\n    value: function visitSafeMethodCall(ast, mode) {\n      return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n    }\n  }, {\n    key: \"visitAll\",\n    value: function visitAll(asts, mode) {\n      var _this111 = this;\n\n      return asts.map(function (ast) {\n        return _this111._visit(ast, mode);\n      });\n    }\n  }, {\n    key: \"visitQuote\",\n    value: function visitQuote(ast, mode) {\n      throw new Error(\"Quotes are not supported for evaluation!\\n        Statement: \".concat(ast.uninterpretedExpression, \" located at \").concat(ast.location));\n    }\n  }, {\n    key: \"_visit\",\n    value: function _visit(ast, mode) {\n      var result = this._resultMap.get(ast);\n\n      if (result) return result;\n      return (this._nodeMap.get(ast) || ast).visit(this, mode);\n    }\n  }, {\n    key: \"convertSafeAccess\",\n    value: function convertSafeAccess(ast, leftMostSafe, mode) {\n      // If the expression contains a safe access node on the left it needs to be converted to\n      // an expression that guards the access to the member by checking the receiver for blank. As\n      // execution proceeds from left to right, the left most part of the expression must be guarded\n      // first but, because member access is left associative, the right side of the expression is at\n      // the top of the AST. The desired result requires lifting a copy of the left part of the\n      // expression up to test it for blank before generating the unguarded version.\n      // Consider, for example the following expression: a?.b.c?.d.e\n      // This results in the ast:\n      //         .\n      //        / \\\n      //       ?.   e\n      //      /  \\\n      //     .    d\n      //    / \\\n      //   ?.  c\n      //  /  \\\n      // a    b\n      // The following tree should be generated:\n      //\n      //        /---- ? ----\\\n      //       /      |      \\\n      //     a   /--- ? ---\\  null\n      //        /     |     \\\n      //       .      .     null\n      //      / \\    / \\\n      //     .  c   .   e\n      //    / \\    / \\\n      //   a   b  .   d\n      //         / \\\n      //        .   c\n      //       / \\\n      //      a   b\n      //\n      // Notice that the first guard condition is the left hand of the left most safe access node\n      // which comes in as leftMostSafe to this routine.\n      var guardedExpression = this._visit(leftMostSafe.receiver, _Mode.Expression);\n\n      var temporary = undefined;\n\n      if (this.needsTemporary(leftMostSafe.receiver)) {\n        // If the expression has method calls or pipes then we need to save the result into a\n        // temporary variable to avoid calling stateful or impure code more than once.\n        temporary = this.allocateTemporary(); // Preserve the result in the temporary variable\n\n        guardedExpression = temporary.set(guardedExpression); // Ensure all further references to the guarded expression refer to the temporary instead.\n\n        this._resultMap.set(leftMostSafe.receiver, temporary);\n      }\n\n      var condition = guardedExpression.isBlank(); // Convert the ast to an unguarded access to the receiver's member. The map will substitute\n      // leftMostNode with its unguarded version in the call to `this.visit()`.\n\n      if (leftMostSafe instanceof SafeMethodCall) {\n        this._nodeMap.set(leftMostSafe, new MethodCall(leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.nameSpan, leftMostSafe.receiver, leftMostSafe.name, leftMostSafe.args));\n      } else {\n        this._nodeMap.set(leftMostSafe, new PropertyRead(leftMostSafe.span, leftMostSafe.sourceSpan, leftMostSafe.nameSpan, leftMostSafe.receiver, leftMostSafe.name));\n      } // Recursively convert the node now without the guarded member access.\n\n\n      var access = this._visit(ast, _Mode.Expression); // Remove the mapping. This is not strictly required as the converter only traverses each node\n      // once but is safer if the conversion is changed to traverse the nodes more than once.\n\n\n      this._nodeMap.delete(leftMostSafe); // If we allocated a temporary, release it.\n\n\n      if (temporary) {\n        this.releaseTemporary(temporary);\n      } // Produce the conditional\n\n\n      return convertToStatementIfNeeded(mode, condition.conditional(literal(null), access));\n    } // Given an expression of the form a?.b.c?.d.e then the left most safe node is\n    // the (a?.b). The . and ?. are left associative thus can be rewritten as:\n    // ((((a?.c).b).c)?.d).e. This returns the most deeply nested safe read or\n    // safe method call as this needs to be transformed initially to:\n    //   a == null ? null : a.c.b.c?.d.e\n    // then to:\n    //   a == null ? null : a.b.c == null ? null : a.b.c.d.e\n\n  }, {\n    key: \"leftMostSafeNode\",\n    value: function leftMostSafeNode(ast) {\n      var _this112 = this;\n\n      var visit = function visit(visitor, ast) {\n        return (_this112._nodeMap.get(ast) || ast).visit(visitor);\n      };\n\n      return ast.visit({\n        visitBinary: function visitBinary(ast) {\n          return null;\n        },\n        visitChain: function visitChain(ast) {\n          return null;\n        },\n        visitConditional: function visitConditional(ast) {\n          return null;\n        },\n        visitFunctionCall: function visitFunctionCall(ast) {\n          return null;\n        },\n        visitImplicitReceiver: function visitImplicitReceiver(ast) {\n          return null;\n        },\n        visitInterpolation: function visitInterpolation(ast) {\n          return null;\n        },\n        visitKeyedRead: function visitKeyedRead(ast) {\n          return visit(this, ast.obj);\n        },\n        visitKeyedWrite: function visitKeyedWrite(ast) {\n          return null;\n        },\n        visitLiteralArray: function visitLiteralArray(ast) {\n          return null;\n        },\n        visitLiteralMap: function visitLiteralMap(ast) {\n          return null;\n        },\n        visitLiteralPrimitive: function visitLiteralPrimitive(ast) {\n          return null;\n        },\n        visitMethodCall: function visitMethodCall(ast) {\n          return visit(this, ast.receiver);\n        },\n        visitPipe: function visitPipe(ast) {\n          return null;\n        },\n        visitPrefixNot: function visitPrefixNot(ast) {\n          return null;\n        },\n        visitNonNullAssert: function visitNonNullAssert(ast) {\n          return null;\n        },\n        visitPropertyRead: function visitPropertyRead(ast) {\n          return visit(this, ast.receiver);\n        },\n        visitPropertyWrite: function visitPropertyWrite(ast) {\n          return null;\n        },\n        visitQuote: function visitQuote(ast) {\n          return null;\n        },\n        visitSafeMethodCall: function visitSafeMethodCall(ast) {\n          return visit(this, ast.receiver) || ast;\n        },\n        visitSafePropertyRead: function visitSafePropertyRead(ast) {\n          return visit(this, ast.receiver) || ast;\n        }\n      });\n    } // Returns true of the AST includes a method or a pipe indicating that, if the\n    // expression is used as the target of a safe property or method access then\n    // the expression should be stored into a temporary variable.\n\n  }, {\n    key: \"needsTemporary\",\n    value: function needsTemporary(ast) {\n      var _this113 = this;\n\n      var visit = function visit(visitor, ast) {\n        return ast && (_this113._nodeMap.get(ast) || ast).visit(visitor);\n      };\n\n      var visitSome = function visitSome(visitor, ast) {\n        return ast.some(function (ast) {\n          return visit(visitor, ast);\n        });\n      };\n\n      return ast.visit({\n        visitBinary: function visitBinary(ast) {\n          return visit(this, ast.left) || visit(this, ast.right);\n        },\n        visitChain: function visitChain(ast) {\n          return false;\n        },\n        visitConditional: function visitConditional(ast) {\n          return visit(this, ast.condition) || visit(this, ast.trueExp) || visit(this, ast.falseExp);\n        },\n        visitFunctionCall: function visitFunctionCall(ast) {\n          return true;\n        },\n        visitImplicitReceiver: function visitImplicitReceiver(ast) {\n          return false;\n        },\n        visitInterpolation: function visitInterpolation(ast) {\n          return visitSome(this, ast.expressions);\n        },\n        visitKeyedRead: function visitKeyedRead(ast) {\n          return false;\n        },\n        visitKeyedWrite: function visitKeyedWrite(ast) {\n          return false;\n        },\n        visitLiteralArray: function visitLiteralArray(ast) {\n          return true;\n        },\n        visitLiteralMap: function visitLiteralMap(ast) {\n          return true;\n        },\n        visitLiteralPrimitive: function visitLiteralPrimitive(ast) {\n          return false;\n        },\n        visitMethodCall: function visitMethodCall(ast) {\n          return true;\n        },\n        visitPipe: function visitPipe(ast) {\n          return true;\n        },\n        visitPrefixNot: function visitPrefixNot(ast) {\n          return visit(this, ast.expression);\n        },\n        visitNonNullAssert: function visitNonNullAssert(ast) {\n          return visit(this, ast.expression);\n        },\n        visitPropertyRead: function visitPropertyRead(ast) {\n          return false;\n        },\n        visitPropertyWrite: function visitPropertyWrite(ast) {\n          return false;\n        },\n        visitQuote: function visitQuote(ast) {\n          return false;\n        },\n        visitSafeMethodCall: function visitSafeMethodCall(ast) {\n          return true;\n        },\n        visitSafePropertyRead: function visitSafePropertyRead(ast) {\n          return false;\n        }\n      });\n    }\n  }, {\n    key: \"allocateTemporary\",\n    value: function allocateTemporary() {\n      var tempNumber = this._currentTemporary++;\n      this.temporaryCount = Math.max(this._currentTemporary, this.temporaryCount);\n      return new ReadVarExpr(temporaryName(this.bindingId, tempNumber));\n    }\n  }, {\n    key: \"releaseTemporary\",\n    value: function releaseTemporary(temporary) {\n      this._currentTemporary--;\n\n      if (temporary.name != temporaryName(this.bindingId, this._currentTemporary)) {\n        throw new Error(\"Temporary \".concat(temporary.name, \" released out of order\"));\n      }\n    }\n    /**\n     * Creates an absolute `ParseSourceSpan` from the relative `ParseSpan`.\n     *\n     * `ParseSpan` objects are relative to the start of the expression.\n     * This method converts these to full `ParseSourceSpan` objects that\n     * show where the span is within the overall source file.\n     *\n     * @param span the relative span to convert.\n     * @returns a `ParseSourceSpan` for the given span or null if no\n     * `baseSourceSpan` was provided to this class.\n     */\n\n  }, {\n    key: \"convertSourceSpan\",\n    value: function convertSourceSpan(span) {\n      if (this.baseSourceSpan) {\n        var start = this.baseSourceSpan.start.moveBy(span.start);\n        var end = this.baseSourceSpan.start.moveBy(span.end);\n        return new ParseSourceSpan(start, end);\n      } else {\n        return null;\n      }\n    }\n    /** Adds the name of an AST to the list of implicit receiver accesses. */\n\n  }, {\n    key: \"addImplicitReceiverAccess\",\n    value: function addImplicitReceiverAccess(name) {\n      if (this.implicitReceiverAccesses) {\n        this.implicitReceiverAccesses.add(name);\n      }\n    }\n  }]);\n\n  return _AstToIrVisitor;\n}();\n\nfunction flattenStatements(arg, output) {\n  if (Array.isArray(arg)) {\n    arg.forEach(function (entry) {\n      return flattenStatements(entry, output);\n    });\n  } else {\n    output.push(arg);\n  }\n}\n\nvar DefaultLocalResolver = /*#__PURE__*/function () {\n  function DefaultLocalResolver() {\n    _classCallCheck(this, DefaultLocalResolver);\n  }\n\n  _createClass(DefaultLocalResolver, [{\n    key: \"notifyImplicitReceiverUse\",\n    value: function notifyImplicitReceiverUse() {}\n  }, {\n    key: \"getLocal\",\n    value: function getLocal(name) {\n      if (name === EventHandlerVars.event.name) {\n        return EventHandlerVars.event;\n      }\n\n      return null;\n    }\n  }]);\n\n  return DefaultLocalResolver;\n}();\n\nfunction createCurrValueExpr(bindingId) {\n  return variable(\"currVal_\".concat(bindingId)); // fix syntax highlighting: `\n}\n\nfunction createPreventDefaultVar(bindingId) {\n  return variable(\"pd_\".concat(bindingId));\n}\n\nfunction convertStmtIntoExpression(stmt) {\n  if (stmt instanceof ExpressionStatement) {\n    return stmt.expr;\n  } else if (stmt instanceof ReturnStatement) {\n    return stmt.value;\n  }\n\n  return null;\n}\n\nvar BuiltinFunctionCall = /*#__PURE__*/function (_FunctionCall) {\n  _inherits(BuiltinFunctionCall, _FunctionCall);\n\n  var _super75 = _createSuper(BuiltinFunctionCall);\n\n  function BuiltinFunctionCall(span, sourceSpan, args, converter) {\n    var _this114;\n\n    _classCallCheck(this, BuiltinFunctionCall);\n\n    _this114 = _super75.call(this, span, sourceSpan, null, args);\n    _this114.args = args;\n    _this114.converter = converter;\n    return _this114;\n  }\n\n  return BuiltinFunctionCall;\n}(FunctionCall);\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * This file is a port of shadowCSS from webcomponents.js to TypeScript.\n *\n * Please make sure to keep to edits in sync with the source file.\n *\n * Source:\n * https://github.com/webcomponents/webcomponentsjs/blob/4efecd7e0e/src/ShadowCSS/ShadowCSS.js\n *\n * The original file level comment is reproduced below\n */\n\n/*\n  This is a limited shim for ShadowDOM css styling.\n  https://dvcs.w3.org/hg/webcomponents/raw-file/tip/spec/shadow/index.html#styles\n\n  The intention here is to support only the styling features which can be\n  relatively simply implemented. The goal is to allow users to avoid the\n  most obvious pitfalls and do so without compromising performance significantly.\n  For ShadowDOM styling that's not covered here, a set of best practices\n  can be provided that should allow users to accomplish more complex styling.\n\n  The following is a list of specific ShadowDOM styling features and a brief\n  discussion of the approach used to shim.\n\n  Shimmed features:\n\n  * :host, :host-context: ShadowDOM allows styling of the shadowRoot's host\n  element using the :host rule. To shim this feature, the :host styles are\n  reformatted and prefixed with a given scope name and promoted to a\n  document level stylesheet.\n  For example, given a scope name of .foo, a rule like this:\n\n    :host {\n        background: red;\n      }\n    }\n\n  becomes:\n\n    .foo {\n      background: red;\n    }\n\n  * encapsulation: Styles defined within ShadowDOM, apply only to\n  dom inside the ShadowDOM. Polymer uses one of two techniques to implement\n  this feature.\n\n  By default, rules are prefixed with the host element tag name\n  as a descendant selector. This ensures styling does not leak out of the 'top'\n  of the element's ShadowDOM. For example,\n\n  div {\n      font-weight: bold;\n    }\n\n  becomes:\n\n  x-foo div {\n      font-weight: bold;\n    }\n\n  becomes:\n\n\n  Alternatively, if WebComponents.ShadowCSS.strictStyling is set to true then\n  selectors are scoped by adding an attribute selector suffix to each\n  simple selector that contains the host element tag name. Each element\n  in the element's ShadowDOM template is also given the scope attribute.\n  Thus, these rules match only elements that have the scope attribute.\n  For example, given a scope name of x-foo, a rule like this:\n\n    div {\n      font-weight: bold;\n    }\n\n  becomes:\n\n    div[x-foo] {\n      font-weight: bold;\n    }\n\n  Note that elements that are dynamically added to a scope must have the scope\n  selector added to them manually.\n\n  * upper/lower bound encapsulation: Styles which are defined outside a\n  shadowRoot should not cross the ShadowDOM boundary and should not apply\n  inside a shadowRoot.\n\n  This styling behavior is not emulated. Some possible ways to do this that\n  were rejected due to complexity and/or performance concerns include: (1) reset\n  every possible property for every possible selector for a given scope name;\n  (2) re-implement css in javascript.\n\n  As an alternative, users should make sure to use selectors\n  specific to the scope in which they are working.\n\n  * ::distributed: This behavior is not emulated. It's often not necessary\n  to style the contents of a specific insertion point and instead, descendants\n  of the host element can be styled selectively. Users can also create an\n  extra node around an insertion point and style that node's contents\n  via descendent selectors. For example, with a shadowRoot like this:\n\n    <style>\n      ::content(div) {\n        background: red;\n      }\n    </style>\n    <content></content>\n\n  could become:\n\n    <style>\n      / *@polyfill .content-container div * /\n      ::content(div) {\n        background: red;\n      }\n    </style>\n    <div class=\"content-container\">\n      <content></content>\n    </div>\n\n  Note the use of @polyfill in the comment above a ShadowDOM specific style\n  declaration. This is a directive to the styling shim to use the selector\n  in comments in lieu of the next selector when running under polyfill.\n*/\n\n\nvar ShadowCss = /*#__PURE__*/function () {\n  function ShadowCss() {\n    _classCallCheck(this, ShadowCss);\n\n    this.strictStyling = true;\n  }\n  /*\n   * Shim some cssText with the given selector. Returns cssText that can\n   * be included in the document via WebComponents.ShadowCSS.addCssToDocument(css).\n   *\n   * When strictStyling is true:\n   * - selector is the attribute added to all elements inside the host,\n   * - hostSelector is the attribute added to the host itself.\n   */\n\n\n  _createClass(ShadowCss, [{\n    key: \"shimCssText\",\n    value: function shimCssText(cssText, selector) {\n      var hostSelector = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      var commentsWithHash = extractCommentsWithHash(cssText);\n      cssText = stripComments(cssText);\n      cssText = this._insertDirectives(cssText);\n\n      var scopedCssText = this._scopeCssText(cssText, selector, hostSelector);\n\n      return [scopedCssText].concat(_toConsumableArray(commentsWithHash)).join('\\n');\n    }\n  }, {\n    key: \"_insertDirectives\",\n    value: function _insertDirectives(cssText) {\n      cssText = this._insertPolyfillDirectivesInCssText(cssText);\n      return this._insertPolyfillRulesInCssText(cssText);\n    }\n    /*\n     * Process styles to convert native ShadowDOM rules that will trip\n     * up the css parser; we rely on decorating the stylesheet with inert rules.\n     *\n     * For example, we convert this rule:\n     *\n     * polyfill-next-selector { content: ':host menu-item'; }\n     * ::content menu-item {\n     *\n     * to this:\n     *\n     * scopeName menu-item {\n     *\n     **/\n\n  }, {\n    key: \"_insertPolyfillDirectivesInCssText\",\n    value: function _insertPolyfillDirectivesInCssText(cssText) {\n      // Difference with webcomponents.js: does not handle comments\n      return cssText.replace(_cssContentNextSelectorRe, function () {\n        return (arguments.length <= 2 ? undefined : arguments[2]) + '{';\n      });\n    }\n    /*\n     * Process styles to add rules which will only apply under the polyfill\n     *\n     * For example, we convert this rule:\n     *\n     * polyfill-rule {\n     *   content: ':host menu-item';\n     * ...\n     * }\n     *\n     * to this:\n     *\n     * scopeName menu-item {...}\n     *\n     **/\n\n  }, {\n    key: \"_insertPolyfillRulesInCssText\",\n    value: function _insertPolyfillRulesInCssText(cssText) {\n      // Difference with webcomponents.js: does not handle comments\n      return cssText.replace(_cssContentRuleRe, function () {\n        for (var _len3 = arguments.length, m = new Array(_len3), _key4 = 0; _key4 < _len3; _key4++) {\n          m[_key4] = arguments[_key4];\n        }\n\n        var rule = m[0].replace(m[1], '').replace(m[2], '');\n        return m[4] + rule;\n      });\n    }\n    /* Ensure styles are scoped. Pseudo-scoping takes a rule like:\n     *\n     *  .foo {... }\n     *\n     *  and converts this to\n     *\n     *  scopeName .foo { ... }\n     */\n\n  }, {\n    key: \"_scopeCssText\",\n    value: function _scopeCssText(cssText, scopeSelector, hostSelector) {\n      var unscopedRules = this._extractUnscopedRulesFromCssText(cssText); // replace :host and :host-context -shadowcsshost and -shadowcsshost respectively\n\n\n      cssText = this._insertPolyfillHostInCssText(cssText);\n      cssText = this._convertColonHost(cssText);\n      cssText = this._convertColonHostContext(cssText);\n      cssText = this._convertShadowDOMSelectors(cssText);\n\n      if (scopeSelector) {\n        cssText = this._scopeSelectors(cssText, scopeSelector, hostSelector);\n      }\n\n      cssText = cssText + '\\n' + unscopedRules;\n      return cssText.trim();\n    }\n    /*\n     * Process styles to add rules which will only apply under the polyfill\n     * and do not process via CSSOM. (CSSOM is destructive to rules on rare\n     * occasions, e.g. -webkit-calc on Safari.)\n     * For example, we convert this rule:\n     *\n     * @polyfill-unscoped-rule {\n     *   content: 'menu-item';\n     * ... }\n     *\n     * to this:\n     *\n     * menu-item {...}\n     *\n     **/\n\n  }, {\n    key: \"_extractUnscopedRulesFromCssText\",\n    value: function _extractUnscopedRulesFromCssText(cssText) {\n      // Difference with webcomponents.js: does not handle comments\n      var r = '';\n      var m;\n      _cssContentUnscopedRuleRe.lastIndex = 0;\n\n      while ((m = _cssContentUnscopedRuleRe.exec(cssText)) !== null) {\n        var rule = m[0].replace(m[2], '').replace(m[1], m[4]);\n        r += rule + '\\n\\n';\n      }\n\n      return r;\n    }\n    /*\n     * convert a rule like :host(.foo) > .bar { }\n     *\n     * to\n     *\n     * .foo<scopeName> > .bar\n     */\n\n  }, {\n    key: \"_convertColonHost\",\n    value: function _convertColonHost(cssText) {\n      return this._convertColonRule(cssText, _cssColonHostRe, this._colonHostPartReplacer);\n    }\n    /*\n     * convert a rule like :host-context(.foo) > .bar { }\n     *\n     * to\n     *\n     * .foo<scopeName> > .bar, .foo scopeName > .bar { }\n     *\n     * and\n     *\n     * :host-context(.foo:host) .bar { ... }\n     *\n     * to\n     *\n     * .foo<scopeName> .bar { ... }\n     */\n\n  }, {\n    key: \"_convertColonHostContext\",\n    value: function _convertColonHostContext(cssText) {\n      return this._convertColonRule(cssText, _cssColonHostContextRe, this._colonHostContextPartReplacer);\n    }\n  }, {\n    key: \"_convertColonRule\",\n    value: function _convertColonRule(cssText, regExp, partReplacer) {\n      // m[1] = :host(-context), m[2] = contents of (), m[3] rest of rule\n      return cssText.replace(regExp, function () {\n        for (var _len4 = arguments.length, m = new Array(_len4), _key5 = 0; _key5 < _len4; _key5++) {\n          m[_key5] = arguments[_key5];\n        }\n\n        if (m[2]) {\n          var parts = m[2].split(',');\n          var r = [];\n\n          for (var i = 0; i < parts.length; i++) {\n            var p = parts[i].trim();\n            if (!p) break;\n            r.push(partReplacer(_polyfillHostNoCombinator, p, m[3]));\n          }\n\n          return r.join(',');\n        } else {\n          return _polyfillHostNoCombinator + m[3];\n        }\n      });\n    }\n  }, {\n    key: \"_colonHostContextPartReplacer\",\n    value: function _colonHostContextPartReplacer(host, part, suffix) {\n      if (part.indexOf(_polyfillHost) > -1) {\n        return this._colonHostPartReplacer(host, part, suffix);\n      } else {\n        return host + part + suffix + ', ' + part + ' ' + host + suffix;\n      }\n    }\n  }, {\n    key: \"_colonHostPartReplacer\",\n    value: function _colonHostPartReplacer(host, part, suffix) {\n      return host + part.replace(_polyfillHost, '') + suffix;\n    }\n    /*\n     * Convert combinators like ::shadow and pseudo-elements like ::content\n     * by replacing with space.\n     */\n\n  }, {\n    key: \"_convertShadowDOMSelectors\",\n    value: function _convertShadowDOMSelectors(cssText) {\n      return _shadowDOMSelectorsRe.reduce(function (result, pattern) {\n        return result.replace(pattern, ' ');\n      }, cssText);\n    } // change a selector like 'div' to 'name div'\n\n  }, {\n    key: \"_scopeSelectors\",\n    value: function _scopeSelectors(cssText, scopeSelector, hostSelector) {\n      var _this115 = this;\n\n      return processRules(cssText, function (rule) {\n        var selector = rule.selector;\n        var content = rule.content;\n\n        if (rule.selector[0] != '@') {\n          selector = _this115._scopeSelector(rule.selector, scopeSelector, hostSelector, _this115.strictStyling);\n        } else if (rule.selector.startsWith('@media') || rule.selector.startsWith('@supports') || rule.selector.startsWith('@page') || rule.selector.startsWith('@document')) {\n          content = _this115._scopeSelectors(rule.content, scopeSelector, hostSelector);\n        }\n\n        return new CssRule(selector, content);\n      });\n    }\n  }, {\n    key: \"_scopeSelector\",\n    value: function _scopeSelector(selector, scopeSelector, hostSelector, strict) {\n      var _this116 = this;\n\n      return selector.split(',').map(function (part) {\n        return part.trim().split(_shadowDeepSelectors);\n      }).map(function (deepParts) {\n        var _deepParts = _toArray(deepParts),\n            shallowPart = _deepParts[0],\n            otherParts = _deepParts.slice(1);\n\n        var applyScope = function applyScope(shallowPart) {\n          if (_this116._selectorNeedsScoping(shallowPart, scopeSelector)) {\n            return strict ? _this116._applyStrictSelectorScope(shallowPart, scopeSelector, hostSelector) : _this116._applySelectorScope(shallowPart, scopeSelector, hostSelector);\n          } else {\n            return shallowPart;\n          }\n        };\n\n        return [applyScope(shallowPart)].concat(_toConsumableArray(otherParts)).join(' ');\n      }).join(', ');\n    }\n  }, {\n    key: \"_selectorNeedsScoping\",\n    value: function _selectorNeedsScoping(selector, scopeSelector) {\n      var re = this._makeScopeMatcher(scopeSelector);\n\n      return !re.test(selector);\n    }\n  }, {\n    key: \"_makeScopeMatcher\",\n    value: function _makeScopeMatcher(scopeSelector) {\n      var lre = /\\[/g;\n      var rre = /\\]/g;\n      scopeSelector = scopeSelector.replace(lre, '\\\\[').replace(rre, '\\\\]');\n      return new RegExp('^(' + scopeSelector + ')' + _selectorReSuffix, 'm');\n    }\n  }, {\n    key: \"_applySelectorScope\",\n    value: function _applySelectorScope(selector, scopeSelector, hostSelector) {\n      // Difference from webcomponents.js: scopeSelector could not be an array\n      return this._applySimpleSelectorScope(selector, scopeSelector, hostSelector);\n    } // scope via name and [is=name]\n\n  }, {\n    key: \"_applySimpleSelectorScope\",\n    value: function _applySimpleSelectorScope(selector, scopeSelector, hostSelector) {\n      // In Android browser, the lastIndex is not reset when the regex is used in String.replace()\n      _polyfillHostRe.lastIndex = 0;\n\n      if (_polyfillHostRe.test(selector)) {\n        var replaceBy = this.strictStyling ? \"[\".concat(hostSelector, \"]\") : scopeSelector;\n        return selector.replace(_polyfillHostNoCombinatorRe, function (hnc, selector) {\n          return selector.replace(/([^:]*)(:*)(.*)/, function (_, before, colon, after) {\n            return before + replaceBy + colon + after;\n          });\n        }).replace(_polyfillHostRe, replaceBy + ' ');\n      }\n\n      return scopeSelector + ' ' + selector;\n    } // return a selector with [name] suffix on each simple selector\n    // e.g. .foo.bar > .zot becomes .foo[name].bar[name] > .zot[name]  /** @internal */\n\n  }, {\n    key: \"_applyStrictSelectorScope\",\n    value: function _applyStrictSelectorScope(selector, scopeSelector, hostSelector) {\n      var _this117 = this;\n\n      var isRe = /\\[is=([^\\]]*)\\]/g;\n      scopeSelector = scopeSelector.replace(isRe, function (_) {\n        return arguments.length <= 1 ? undefined : arguments[1];\n      });\n      var attrName = '[' + scopeSelector + ']';\n\n      var _scopeSelectorPart = function _scopeSelectorPart(p) {\n        var scopedP = p.trim();\n\n        if (!scopedP) {\n          return '';\n        }\n\n        if (p.indexOf(_polyfillHostNoCombinator) > -1) {\n          scopedP = _this117._applySimpleSelectorScope(p, scopeSelector, hostSelector);\n        } else {\n          // remove :host since it should be unnecessary\n          var t = p.replace(_polyfillHostRe, '');\n\n          if (t.length > 0) {\n            var matches = t.match(/([^:]*)(:*)(.*)/);\n\n            if (matches) {\n              scopedP = matches[1] + attrName + matches[2] + matches[3];\n            }\n          }\n        }\n\n        return scopedP;\n      };\n\n      var safeContent = new SafeSelector(selector);\n      selector = safeContent.content();\n      var scopedSelector = '';\n      var startIndex = 0;\n      var res;\n      var sep = /( |>|\\+|~(?!=))\\s*/g; // If a selector appears before :host it should not be shimmed as it\n      // matches on ancestor elements and not on elements in the host's shadow\n      // `:host-context(div)` is transformed to\n      // `-shadowcsshost-no-combinatordiv, div -shadowcsshost-no-combinator`\n      // the `div` is not part of the component in the 2nd selectors and should not be scoped.\n      // Historically `component-tag:host` was matching the component so we also want to preserve\n      // this behavior to avoid breaking legacy apps (it should not match).\n      // The behavior should be:\n      // - `tag:host` -> `tag[h]` (this is to avoid breaking legacy apps, should not match anything)\n      // - `tag :host` -> `tag [h]` (`tag` is not scoped because it's considered part of a\n      //   `:host-context(tag)`)\n\n      var hasHost = selector.indexOf(_polyfillHostNoCombinator) > -1; // Only scope parts after the first `-shadowcsshost-no-combinator` when it is present\n\n      var shouldScope = !hasHost;\n\n      while ((res = sep.exec(selector)) !== null) {\n        var separator = res[1];\n\n        var _part = selector.slice(startIndex, res.index).trim();\n\n        shouldScope = shouldScope || _part.indexOf(_polyfillHostNoCombinator) > -1;\n        var scopedPart = shouldScope ? _scopeSelectorPart(_part) : _part;\n        scopedSelector += \"\".concat(scopedPart, \" \").concat(separator, \" \");\n        startIndex = sep.lastIndex;\n      }\n\n      var part = selector.substring(startIndex);\n      shouldScope = shouldScope || part.indexOf(_polyfillHostNoCombinator) > -1;\n      scopedSelector += shouldScope ? _scopeSelectorPart(part) : part; // replace the placeholders with their original values\n\n      return safeContent.restore(scopedSelector);\n    }\n  }, {\n    key: \"_insertPolyfillHostInCssText\",\n    value: function _insertPolyfillHostInCssText(selector) {\n      return selector.replace(_colonHostContextRe, _polyfillHostContext).replace(_colonHostRe, _polyfillHost);\n    }\n  }]);\n\n  return ShadowCss;\n}();\n\nvar SafeSelector = /*#__PURE__*/function () {\n  function SafeSelector(selector) {\n    var _this118 = this;\n\n    _classCallCheck(this, SafeSelector);\n\n    this.placeholders = [];\n    this.index = 0; // Replaces attribute selectors with placeholders.\n    // The WS in [attr=\"va lue\"] would otherwise be interpreted as a selector separator.\n\n    selector = selector.replace(/(\\[[^\\]]*\\])/g, function (_, keep) {\n      var replaceBy = \"__ph-\".concat(_this118.index, \"__\");\n\n      _this118.placeholders.push(keep);\n\n      _this118.index++;\n      return replaceBy;\n    }); // Replaces the expression in `:nth-child(2n + 1)` with a placeholder.\n    // WS and \"+\" would otherwise be interpreted as selector separators.\n\n    this._content = selector.replace(/(:nth-[-\\w]+)(\\([^)]+\\))/g, function (_, pseudo, exp) {\n      var replaceBy = \"__ph-\".concat(_this118.index, \"__\");\n\n      _this118.placeholders.push(exp);\n\n      _this118.index++;\n      return pseudo + replaceBy;\n    });\n  }\n\n  _createClass(SafeSelector, [{\n    key: \"restore\",\n    value: function restore(content) {\n      var _this119 = this;\n\n      return content.replace(/__ph-(\\d+)__/g, function (ph, index) {\n        return _this119.placeholders[+index];\n      });\n    }\n  }, {\n    key: \"content\",\n    value: function content() {\n      return this._content;\n    }\n  }]);\n\n  return SafeSelector;\n}();\n\nvar _cssContentNextSelectorRe = /polyfill-next-selector[^}]*content:[\\s]*?(['\"])(.*?)\\1[;\\s]*}([^{]*?){/gim;\nvar _cssContentRuleRe = /(polyfill-rule)[^}]*(content:[\\s]*(['\"])(.*?)\\3)[;\\s]*[^}]*}/gim;\nvar _cssContentUnscopedRuleRe = /(polyfill-unscoped-rule)[^}]*(content:[\\s]*(['\"])(.*?)\\3)[;\\s]*[^}]*}/gim;\nvar _polyfillHost = '-shadowcsshost'; // note: :host-context pre-processed to -shadowcsshostcontext.\n\nvar _polyfillHostContext = '-shadowcsscontext';\n\nvar _parenSuffix = ')(?:\\\\((' + '(?:\\\\([^)(]*\\\\)|[^)(]*)+?' + ')\\\\))?([^,{]*)';\n\nvar _cssColonHostRe = new RegExp('(' + _polyfillHost + _parenSuffix, 'gim');\n\nvar _cssColonHostContextRe = new RegExp('(' + _polyfillHostContext + _parenSuffix, 'gim');\n\nvar _polyfillHostNoCombinator = _polyfillHost + '-no-combinator';\n\nvar _polyfillHostNoCombinatorRe = /-shadowcsshost-no-combinator([^\\s]*)/;\nvar _shadowDOMSelectorsRe = [/::shadow/g, /::content/g, // Deprecated selectors\n/\\/shadow-deep\\//g, /\\/shadow\\//g]; // The deep combinator is deprecated in the CSS spec\n// Support for `>>>`, `deep`, `::ng-deep` is then also deprecated and will be removed in the future.\n// see https://github.com/angular/angular/pull/17677\n\nvar _shadowDeepSelectors = /(?:>>>)|(?:\\/deep\\/)|(?:::ng-deep)/g;\nvar _selectorReSuffix = '([>\\\\s~+\\[.,{:][\\\\s\\\\S]*)?$';\nvar _polyfillHostRe = /-shadowcsshost/gim;\nvar _colonHostRe = /:host/gim;\nvar _colonHostContextRe = /:host-context/gim;\nvar _commentRe = /\\/\\*\\s*[\\s\\S]*?\\*\\//g;\n\nfunction stripComments(input) {\n  return input.replace(_commentRe, '');\n}\n\nvar _commentWithHashRe = /\\/\\*\\s*#\\s*source(Mapping)?URL=[\\s\\S]+?\\*\\//g;\n\nfunction extractCommentsWithHash(input) {\n  return input.match(_commentWithHashRe) || [];\n}\n\nvar _ruleRe = /(\\s*)([^;\\{\\}]+?)(\\s*)((?:{%BLOCK%}?\\s*;?)|(?:\\s*;))/g;\nvar _curlyRe = /([{}])/g;\nvar OPEN_CURLY = '{';\nvar CLOSE_CURLY = '}';\nvar BLOCK_PLACEHOLDER = '%BLOCK%';\n\nvar CssRule = function CssRule(selector, content) {\n  _classCallCheck(this, CssRule);\n\n  this.selector = selector;\n  this.content = content;\n};\n\nfunction processRules(input, ruleCallback) {\n  var inputWithEscapedBlocks = escapeBlocks(input);\n  var nextBlockIndex = 0;\n  return inputWithEscapedBlocks.escapedString.replace(_ruleRe, function () {\n    var selector = arguments.length <= 2 ? undefined : arguments[2];\n    var content = '';\n    var suffix = arguments.length <= 4 ? undefined : arguments[4];\n    var contentPrefix = '';\n\n    if (suffix && suffix.startsWith('{' + BLOCK_PLACEHOLDER)) {\n      content = inputWithEscapedBlocks.blocks[nextBlockIndex++];\n      suffix = suffix.substring(BLOCK_PLACEHOLDER.length + 1);\n      contentPrefix = '{';\n    }\n\n    var rule = ruleCallback(new CssRule(selector, content));\n    return \"\".concat(arguments.length <= 1 ? undefined : arguments[1]).concat(rule.selector).concat(arguments.length <= 3 ? undefined : arguments[3]).concat(contentPrefix).concat(rule.content).concat(suffix);\n  });\n}\n\nvar StringWithEscapedBlocks = function StringWithEscapedBlocks(escapedString, blocks) {\n  _classCallCheck(this, StringWithEscapedBlocks);\n\n  this.escapedString = escapedString;\n  this.blocks = blocks;\n};\n\nfunction escapeBlocks(input) {\n  var inputParts = input.split(_curlyRe);\n  var resultParts = [];\n  var escapedBlocks = [];\n  var bracketCount = 0;\n  var currentBlockParts = [];\n\n  for (var partIndex = 0; partIndex < inputParts.length; partIndex++) {\n    var part = inputParts[partIndex];\n\n    if (part == CLOSE_CURLY) {\n      bracketCount--;\n    }\n\n    if (bracketCount > 0) {\n      currentBlockParts.push(part);\n    } else {\n      if (currentBlockParts.length > 0) {\n        escapedBlocks.push(currentBlockParts.join(''));\n        resultParts.push(BLOCK_PLACEHOLDER);\n        currentBlockParts = [];\n      }\n\n      resultParts.push(part);\n    }\n\n    if (part == OPEN_CURLY) {\n      bracketCount++;\n    }\n  }\n\n  if (currentBlockParts.length > 0) {\n    escapedBlocks.push(currentBlockParts.join(''));\n    resultParts.push(BLOCK_PLACEHOLDER);\n  }\n\n  return new StringWithEscapedBlocks(resultParts.join(''), escapedBlocks);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar COMPONENT_VARIABLE = '%COMP%';\nvar HOST_ATTR = \"_nghost-\".concat(COMPONENT_VARIABLE);\nvar CONTENT_ATTR = \"_ngcontent-\".concat(COMPONENT_VARIABLE);\n\nvar StylesCompileDependency = function StylesCompileDependency(name, moduleUrl, setValue) {\n  _classCallCheck(this, StylesCompileDependency);\n\n  this.name = name;\n  this.moduleUrl = moduleUrl;\n  this.setValue = setValue;\n};\n\nvar CompiledStylesheet = function CompiledStylesheet(outputCtx, stylesVar, dependencies, isShimmed, meta) {\n  _classCallCheck(this, CompiledStylesheet);\n\n  this.outputCtx = outputCtx;\n  this.stylesVar = stylesVar;\n  this.dependencies = dependencies;\n  this.isShimmed = isShimmed;\n  this.meta = meta;\n};\n\nvar StyleCompiler = /*#__PURE__*/function () {\n  function StyleCompiler(_urlResolver) {\n    _classCallCheck(this, StyleCompiler);\n\n    this._urlResolver = _urlResolver;\n    this._shadowCss = new ShadowCss();\n  }\n\n  _createClass(StyleCompiler, [{\n    key: \"compileComponent\",\n    value: function compileComponent(outputCtx, comp) {\n      var template = comp.template;\n      return this._compileStyles(outputCtx, comp, new CompileStylesheetMetadata({\n        styles: template.styles,\n        styleUrls: template.styleUrls,\n        moduleUrl: identifierModuleUrl(comp.type)\n      }), this.needsStyleShim(comp), true);\n    }\n  }, {\n    key: \"compileStyles\",\n    value: function compileStyles(outputCtx, comp, stylesheet) {\n      var shim = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.needsStyleShim(comp);\n      return this._compileStyles(outputCtx, comp, stylesheet, shim, false);\n    }\n  }, {\n    key: \"needsStyleShim\",\n    value: function needsStyleShim(comp) {\n      return comp.template.encapsulation === ViewEncapsulation.Emulated;\n    }\n  }, {\n    key: \"_compileStyles\",\n    value: function _compileStyles(outputCtx, comp, stylesheet, shim, isComponentStylesheet) {\n      var _this120 = this;\n\n      var styleExpressions = stylesheet.styles.map(function (plainStyle) {\n        return literal(_this120._shimIfNeeded(plainStyle, shim));\n      });\n      var dependencies = [];\n      stylesheet.styleUrls.forEach(function (styleUrl) {\n        var exprIndex = styleExpressions.length; // Note: This placeholder will be filled later.\n\n        styleExpressions.push(null);\n        dependencies.push(new StylesCompileDependency(getStylesVarName(null), styleUrl, function (value) {\n          return styleExpressions[exprIndex] = outputCtx.importExpr(value);\n        }));\n      }); // styles variable contains plain strings and arrays of other styles arrays (recursive),\n      // so we set its type to dynamic.\n\n      var stylesVar = getStylesVarName(isComponentStylesheet ? comp : null);\n      var stmt = variable(stylesVar).set(literalArr(styleExpressions, new ArrayType(DYNAMIC_TYPE, [TypeModifier.Const]))).toDeclStmt(null, isComponentStylesheet ? [StmtModifier.Final] : [StmtModifier.Final, StmtModifier.Exported]);\n      outputCtx.statements.push(stmt);\n      return new CompiledStylesheet(outputCtx, stylesVar, dependencies, shim, stylesheet);\n    }\n  }, {\n    key: \"_shimIfNeeded\",\n    value: function _shimIfNeeded(style, shim) {\n      return shim ? this._shadowCss.shimCssText(style, CONTENT_ATTR, HOST_ATTR) : style;\n    }\n  }]);\n\n  return StyleCompiler;\n}();\n\nfunction getStylesVarName(component) {\n  var result = \"styles\";\n\n  if (component) {\n    result += \"_\".concat(identifierName(component.type));\n  }\n\n  return result;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * A path is an ordered set of elements. Typically a path is to  a\n * particular offset in a source file. The head of the list is the top\n * most node. The tail is the node that contains the offset directly.\n *\n * For example, the expression `a + b + c` might have an ast that looks\n * like:\n *     +\n *    / \\\n *   a   +\n *      / \\\n *     b   c\n *\n * The path to the node at offset 9 would be `['+' at 1-10, '+' at 7-10,\n * 'c' at 9-10]` and the path the node at offset 1 would be\n * `['+' at 1-10, 'a' at 1-2]`.\n */\n\n\nvar AstPath = /*#__PURE__*/function () {\n  function AstPath(path) {\n    var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n\n    _classCallCheck(this, AstPath);\n\n    this.path = path;\n    this.position = position;\n  }\n\n  _createClass(AstPath, [{\n    key: \"parentOf\",\n    value: function parentOf(node) {\n      return node && this.path[this.path.indexOf(node) - 1];\n    }\n  }, {\n    key: \"childOf\",\n    value: function childOf(node) {\n      return this.path[this.path.indexOf(node) + 1];\n    }\n  }, {\n    key: \"first\",\n    value: function first(ctor) {\n      for (var i = this.path.length - 1; i >= 0; i--) {\n        var item = this.path[i];\n        if (item instanceof ctor) return item;\n      }\n    }\n  }, {\n    key: \"push\",\n    value: function push(node) {\n      this.path.push(node);\n    }\n  }, {\n    key: \"pop\",\n    value: function pop() {\n      return this.path.pop();\n    }\n  }, {\n    key: \"empty\",\n    get: function get() {\n      return !this.path || !this.path.length;\n    }\n  }, {\n    key: \"head\",\n    get: function get() {\n      return this.path[0];\n    }\n  }, {\n    key: \"tail\",\n    get: function get() {\n      return this.path[this.path.length - 1];\n    }\n  }]);\n\n  return AstPath;\n}();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar NodeWithI18n = function NodeWithI18n(sourceSpan, i18n) {\n  _classCallCheck(this, NodeWithI18n);\n\n  this.sourceSpan = sourceSpan;\n  this.i18n = i18n;\n};\n\nvar Text$3 = /*#__PURE__*/function (_NodeWithI18n) {\n  _inherits(Text$3, _NodeWithI18n);\n\n  var _super76 = _createSuper(Text$3);\n\n  function Text$3(value, sourceSpan, i18n) {\n    var _this121;\n\n    _classCallCheck(this, Text$3);\n\n    _this121 = _super76.call(this, sourceSpan, i18n);\n    _this121.value = value;\n    return _this121;\n  }\n\n  _createClass(Text$3, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      return visitor.visitText(this, context);\n    }\n  }]);\n\n  return Text$3;\n}(NodeWithI18n);\n\nvar Expansion = /*#__PURE__*/function (_NodeWithI18n2) {\n  _inherits(Expansion, _NodeWithI18n2);\n\n  var _super77 = _createSuper(Expansion);\n\n  function Expansion(switchValue, type, cases, sourceSpan, switchValueSourceSpan, i18n) {\n    var _this122;\n\n    _classCallCheck(this, Expansion);\n\n    _this122 = _super77.call(this, sourceSpan, i18n);\n    _this122.switchValue = switchValue;\n    _this122.type = type;\n    _this122.cases = cases;\n    _this122.switchValueSourceSpan = switchValueSourceSpan;\n    return _this122;\n  }\n\n  _createClass(Expansion, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      return visitor.visitExpansion(this, context);\n    }\n  }]);\n\n  return Expansion;\n}(NodeWithI18n);\n\nvar ExpansionCase = /*#__PURE__*/function () {\n  function ExpansionCase(value, expression, sourceSpan, valueSourceSpan, expSourceSpan) {\n    _classCallCheck(this, ExpansionCase);\n\n    this.value = value;\n    this.expression = expression;\n    this.sourceSpan = sourceSpan;\n    this.valueSourceSpan = valueSourceSpan;\n    this.expSourceSpan = expSourceSpan;\n  }\n\n  _createClass(ExpansionCase, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      return visitor.visitExpansionCase(this, context);\n    }\n  }]);\n\n  return ExpansionCase;\n}();\n\nvar Attribute = /*#__PURE__*/function (_NodeWithI18n3) {\n  _inherits(Attribute, _NodeWithI18n3);\n\n  var _super78 = _createSuper(Attribute);\n\n  function Attribute(name, value, sourceSpan, valueSpan, i18n) {\n    var _this123;\n\n    _classCallCheck(this, Attribute);\n\n    _this123 = _super78.call(this, sourceSpan, i18n);\n    _this123.name = name;\n    _this123.value = value;\n    _this123.valueSpan = valueSpan;\n    return _this123;\n  }\n\n  _createClass(Attribute, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      return visitor.visitAttribute(this, context);\n    }\n  }]);\n\n  return Attribute;\n}(NodeWithI18n);\n\nvar Element$1 = /*#__PURE__*/function (_NodeWithI18n4) {\n  _inherits(Element$1, _NodeWithI18n4);\n\n  var _super79 = _createSuper(Element$1);\n\n  function Element$1(name, attrs, children, sourceSpan) {\n    var _this124;\n\n    var startSourceSpan = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    var endSourceSpan = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;\n    var i18n = arguments.length > 6 ? arguments[6] : undefined;\n\n    _classCallCheck(this, Element$1);\n\n    _this124 = _super79.call(this, sourceSpan, i18n);\n    _this124.name = name;\n    _this124.attrs = attrs;\n    _this124.children = children;\n    _this124.startSourceSpan = startSourceSpan;\n    _this124.endSourceSpan = endSourceSpan;\n    return _this124;\n  }\n\n  _createClass(Element$1, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      return visitor.visitElement(this, context);\n    }\n  }]);\n\n  return Element$1;\n}(NodeWithI18n);\n\nvar Comment = /*#__PURE__*/function () {\n  function Comment(value, sourceSpan) {\n    _classCallCheck(this, Comment);\n\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n  }\n\n  _createClass(Comment, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      return visitor.visitComment(this, context);\n    }\n  }]);\n\n  return Comment;\n}();\n\nfunction visitAll$1(visitor, nodes) {\n  var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var result = [];\n  var visit = visitor.visit ? function (ast) {\n    return visitor.visit(ast, context) || ast.visit(visitor, context);\n  } : function (ast) {\n    return ast.visit(visitor, context);\n  };\n  nodes.forEach(function (ast) {\n    var astResult = visit(ast);\n\n    if (astResult) {\n      result.push(astResult);\n    }\n  });\n  return result;\n}\n\nvar RecursiveVisitor$1 = /*#__PURE__*/function () {\n  function RecursiveVisitor$1() {\n    _classCallCheck(this, RecursiveVisitor$1);\n  }\n\n  _createClass(RecursiveVisitor$1, [{\n    key: \"visitElement\",\n    value: function visitElement(ast, context) {\n      this.visitChildren(context, function (visit) {\n        visit(ast.attrs);\n        visit(ast.children);\n      });\n    }\n  }, {\n    key: \"visitAttribute\",\n    value: function visitAttribute(ast, context) {}\n  }, {\n    key: \"visitText\",\n    value: function visitText(ast, context) {}\n  }, {\n    key: \"visitComment\",\n    value: function visitComment(ast, context) {}\n  }, {\n    key: \"visitExpansion\",\n    value: function visitExpansion(ast, context) {\n      return this.visitChildren(context, function (visit) {\n        visit(ast.cases);\n      });\n    }\n  }, {\n    key: \"visitExpansionCase\",\n    value: function visitExpansionCase(ast, context) {}\n  }, {\n    key: \"visitChildren\",\n    value: function visitChildren(context, cb) {\n      var results = [];\n      var t = this;\n\n      function visit(children) {\n        if (children) results.push(visitAll$1(t, children, context));\n      }\n\n      cb(visit);\n      return Array.prototype.concat.apply([], results);\n    }\n  }]);\n\n  return RecursiveVisitor$1;\n}();\n\nfunction spanOf(ast) {\n  var start = ast.sourceSpan.start.offset;\n  var end = ast.sourceSpan.end.offset;\n\n  if (ast instanceof Element$1) {\n    if (ast.endSourceSpan) {\n      end = ast.endSourceSpan.end.offset;\n    } else if (ast.children && ast.children.length) {\n      end = spanOf(ast.children[ast.children.length - 1]).end;\n    }\n  }\n\n  return {\n    start: start,\n    end: end\n  };\n}\n\nfunction findNode(nodes, position) {\n  var path = [];\n  var visitor = new ( /*#__PURE__*/function (_RecursiveVisitor$) {\n    _inherits(_class, _RecursiveVisitor$);\n\n    var _super80 = _createSuper(_class);\n\n    function _class() {\n      _classCallCheck(this, _class);\n\n      return _super80.apply(this, arguments);\n    }\n\n    _createClass(_class, [{\n      key: \"visit\",\n      value: function visit(ast, context) {\n        var span = spanOf(ast);\n\n        if (span.start <= position && position < span.end) {\n          path.push(ast);\n        } else {\n          // Returning a value here will result in the children being skipped.\n          return true;\n        }\n      }\n    }]);\n\n    return _class;\n  }(RecursiveVisitor$1))();\n  visitAll$1(visitor, nodes);\n  return new AstPath(path, position);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar TokenType;\n\n(function (TokenType) {\n  TokenType[TokenType[\"TAG_OPEN_START\"] = 0] = \"TAG_OPEN_START\";\n  TokenType[TokenType[\"TAG_OPEN_END\"] = 1] = \"TAG_OPEN_END\";\n  TokenType[TokenType[\"TAG_OPEN_END_VOID\"] = 2] = \"TAG_OPEN_END_VOID\";\n  TokenType[TokenType[\"TAG_CLOSE\"] = 3] = \"TAG_CLOSE\";\n  TokenType[TokenType[\"TEXT\"] = 4] = \"TEXT\";\n  TokenType[TokenType[\"ESCAPABLE_RAW_TEXT\"] = 5] = \"ESCAPABLE_RAW_TEXT\";\n  TokenType[TokenType[\"RAW_TEXT\"] = 6] = \"RAW_TEXT\";\n  TokenType[TokenType[\"COMMENT_START\"] = 7] = \"COMMENT_START\";\n  TokenType[TokenType[\"COMMENT_END\"] = 8] = \"COMMENT_END\";\n  TokenType[TokenType[\"CDATA_START\"] = 9] = \"CDATA_START\";\n  TokenType[TokenType[\"CDATA_END\"] = 10] = \"CDATA_END\";\n  TokenType[TokenType[\"ATTR_NAME\"] = 11] = \"ATTR_NAME\";\n  TokenType[TokenType[\"ATTR_QUOTE\"] = 12] = \"ATTR_QUOTE\";\n  TokenType[TokenType[\"ATTR_VALUE\"] = 13] = \"ATTR_VALUE\";\n  TokenType[TokenType[\"DOC_TYPE\"] = 14] = \"DOC_TYPE\";\n  TokenType[TokenType[\"EXPANSION_FORM_START\"] = 15] = \"EXPANSION_FORM_START\";\n  TokenType[TokenType[\"EXPANSION_CASE_VALUE\"] = 16] = \"EXPANSION_CASE_VALUE\";\n  TokenType[TokenType[\"EXPANSION_CASE_EXP_START\"] = 17] = \"EXPANSION_CASE_EXP_START\";\n  TokenType[TokenType[\"EXPANSION_CASE_EXP_END\"] = 18] = \"EXPANSION_CASE_EXP_END\";\n  TokenType[TokenType[\"EXPANSION_FORM_END\"] = 19] = \"EXPANSION_FORM_END\";\n  TokenType[TokenType[\"EOF\"] = 20] = \"EOF\";\n})(TokenType || (TokenType = {}));\n\nvar Token = function Token(type, parts, sourceSpan) {\n  _classCallCheck(this, Token);\n\n  this.type = type;\n  this.parts = parts;\n  this.sourceSpan = sourceSpan;\n};\n\nvar TokenError = /*#__PURE__*/function (_ParseError) {\n  _inherits(TokenError, _ParseError);\n\n  var _super81 = _createSuper(TokenError);\n\n  function TokenError(errorMsg, tokenType, span) {\n    var _this125;\n\n    _classCallCheck(this, TokenError);\n\n    _this125 = _super81.call(this, span, errorMsg);\n    _this125.tokenType = tokenType;\n    return _this125;\n  }\n\n  return TokenError;\n}(ParseError);\n\nvar TokenizeResult = function TokenizeResult(tokens, errors, nonNormalizedIcuExpressions) {\n  _classCallCheck(this, TokenizeResult);\n\n  this.tokens = tokens;\n  this.errors = errors;\n  this.nonNormalizedIcuExpressions = nonNormalizedIcuExpressions;\n};\n\nfunction tokenize(source, url, getTagDefinition) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var tokenizer = new _Tokenizer(new ParseSourceFile(source, url), getTagDefinition, options);\n  tokenizer.tokenize();\n  return new TokenizeResult(mergeTextTokens(tokenizer.tokens), tokenizer.errors, tokenizer.nonNormalizedIcuExpressions);\n}\n\nvar _CR_OR_CRLF_REGEXP = /\\r\\n?/g;\n\nfunction _unexpectedCharacterErrorMsg(charCode) {\n  var char = charCode === $EOF ? 'EOF' : String.fromCharCode(charCode);\n  return \"Unexpected character \\\"\".concat(char, \"\\\"\");\n}\n\nfunction _unknownEntityErrorMsg(entitySrc) {\n  return \"Unknown entity \\\"\".concat(entitySrc, \"\\\" - use the \\\"&#<decimal>;\\\" or  \\\"&#x<hex>;\\\" syntax\");\n}\n\nvar _ControlFlowError = function _ControlFlowError(error) {\n  _classCallCheck(this, _ControlFlowError);\n\n  this.error = error;\n}; // See http://www.w3.org/TR/html51/syntax.html#writing\n\n\nvar _Tokenizer = /*#__PURE__*/function () {\n  /**\n   * @param _file The html source file being tokenized.\n   * @param _getTagDefinition A function that will retrieve a tag definition for a given tag name.\n   * @param options Configuration of the tokenization.\n   */\n  function _Tokenizer(_file, _getTagDefinition, options) {\n    _classCallCheck(this, _Tokenizer);\n\n    this._getTagDefinition = _getTagDefinition;\n    this._currentTokenStart = null;\n    this._currentTokenType = null;\n    this._expansionCaseStack = [];\n    this._inInterpolation = false;\n    this.tokens = [];\n    this.errors = [];\n    this.nonNormalizedIcuExpressions = [];\n    this._tokenizeIcu = options.tokenizeExpansionForms || false;\n    this._interpolationConfig = options.interpolationConfig || DEFAULT_INTERPOLATION_CONFIG;\n    this._leadingTriviaCodePoints = options.leadingTriviaChars && options.leadingTriviaChars.map(function (c) {\n      return c.codePointAt(0) || 0;\n    });\n    var range = options.range || {\n      endPos: _file.content.length,\n      startPos: 0,\n      startLine: 0,\n      startCol: 0\n    };\n    this._cursor = options.escapedString ? new EscapedCharacterCursor(_file, range) : new PlainCharacterCursor(_file, range);\n    this._preserveLineEndings = options.preserveLineEndings || false;\n    this._escapedString = options.escapedString || false;\n    this._i18nNormalizeLineEndingsInICUs = options.i18nNormalizeLineEndingsInICUs || false;\n\n    try {\n      this._cursor.init();\n    } catch (e) {\n      this.handleError(e);\n    }\n  }\n\n  _createClass(_Tokenizer, [{\n    key: \"_processCarriageReturns\",\n    value: function _processCarriageReturns(content) {\n      if (this._preserveLineEndings) {\n        return content;\n      } // http://www.w3.org/TR/html5/syntax.html#preprocessing-the-input-stream\n      // In order to keep the original position in the source, we can not\n      // pre-process it.\n      // Instead CRs are processed right before instantiating the tokens.\n\n\n      return content.replace(_CR_OR_CRLF_REGEXP, '\\n');\n    }\n  }, {\n    key: \"tokenize\",\n    value: function tokenize() {\n      while (this._cursor.peek() !== $EOF) {\n        var start = this._cursor.clone();\n\n        try {\n          if (this._attemptCharCode($LT)) {\n            if (this._attemptCharCode($BANG)) {\n              if (this._attemptCharCode($LBRACKET)) {\n                this._consumeCdata(start);\n              } else if (this._attemptCharCode($MINUS)) {\n                this._consumeComment(start);\n              } else {\n                this._consumeDocType(start);\n              }\n            } else if (this._attemptCharCode($SLASH)) {\n              this._consumeTagClose(start);\n            } else {\n              this._consumeTagOpen(start);\n            }\n          } else if (!(this._tokenizeIcu && this._tokenizeExpansionForm())) {\n            this._consumeText();\n          }\n        } catch (e) {\n          this.handleError(e);\n        }\n      }\n\n      this._beginToken(TokenType.EOF);\n\n      this._endToken([]);\n    }\n    /**\n     * @returns whether an ICU token has been created\n     * @internal\n     */\n\n  }, {\n    key: \"_tokenizeExpansionForm\",\n    value: function _tokenizeExpansionForm() {\n      if (this.isExpansionFormStart()) {\n        this._consumeExpansionFormStart();\n\n        return true;\n      }\n\n      if (isExpansionCaseStart(this._cursor.peek()) && this._isInExpansionForm()) {\n        this._consumeExpansionCaseStart();\n\n        return true;\n      }\n\n      if (this._cursor.peek() === $RBRACE) {\n        if (this._isInExpansionCase()) {\n          this._consumeExpansionCaseEnd();\n\n          return true;\n        }\n\n        if (this._isInExpansionForm()) {\n          this._consumeExpansionFormEnd();\n\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_beginToken\",\n    value: function _beginToken(type) {\n      var start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._cursor.clone();\n      this._currentTokenStart = start;\n      this._currentTokenType = type;\n    }\n  }, {\n    key: \"_endToken\",\n    value: function _endToken(parts, end) {\n      if (this._currentTokenStart === null) {\n        throw new TokenError('Programming error - attempted to end a token when there was no start to the token', this._currentTokenType, this._cursor.getSpan(end));\n      }\n\n      if (this._currentTokenType === null) {\n        throw new TokenError('Programming error - attempted to end a token which has no token type', null, this._cursor.getSpan(this._currentTokenStart));\n      }\n\n      var token = new Token(this._currentTokenType, parts, this._cursor.getSpan(this._currentTokenStart, this._leadingTriviaCodePoints));\n      this.tokens.push(token);\n      this._currentTokenStart = null;\n      this._currentTokenType = null;\n      return token;\n    }\n  }, {\n    key: \"_createError\",\n    value: function _createError(msg, span) {\n      if (this._isInExpansionForm()) {\n        msg += \" (Do you have an unescaped \\\"{\\\" in your template? Use \\\"{{ '{' }}\\\") to escape it.)\";\n      }\n\n      var error = new TokenError(msg, this._currentTokenType, span);\n      this._currentTokenStart = null;\n      this._currentTokenType = null;\n      return new _ControlFlowError(error);\n    }\n  }, {\n    key: \"handleError\",\n    value: function handleError(e) {\n      if (e instanceof CursorError) {\n        e = this._createError(e.msg, this._cursor.getSpan(e.cursor));\n      }\n\n      if (e instanceof _ControlFlowError) {\n        this.errors.push(e.error);\n      } else {\n        throw e;\n      }\n    }\n  }, {\n    key: \"_attemptCharCode\",\n    value: function _attemptCharCode(charCode) {\n      if (this._cursor.peek() === charCode) {\n        this._cursor.advance();\n\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_attemptCharCodeCaseInsensitive\",\n    value: function _attemptCharCodeCaseInsensitive(charCode) {\n      if (compareCharCodeCaseInsensitive(this._cursor.peek(), charCode)) {\n        this._cursor.advance();\n\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_requireCharCode\",\n    value: function _requireCharCode(charCode) {\n      var location = this._cursor.clone();\n\n      if (!this._attemptCharCode(charCode)) {\n        throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location));\n      }\n    }\n  }, {\n    key: \"_attemptStr\",\n    value: function _attemptStr(chars) {\n      var len = chars.length;\n\n      if (this._cursor.charsLeft() < len) {\n        return false;\n      }\n\n      var initialPosition = this._cursor.clone();\n\n      for (var i = 0; i < len; i++) {\n        if (!this._attemptCharCode(chars.charCodeAt(i))) {\n          // If attempting to parse the string fails, we want to reset the parser\n          // to where it was before the attempt\n          this._cursor = initialPosition;\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_attemptStrCaseInsensitive\",\n    value: function _attemptStrCaseInsensitive(chars) {\n      for (var i = 0; i < chars.length; i++) {\n        if (!this._attemptCharCodeCaseInsensitive(chars.charCodeAt(i))) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_requireStr\",\n    value: function _requireStr(chars) {\n      var location = this._cursor.clone();\n\n      if (!this._attemptStr(chars)) {\n        throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(location));\n      }\n    }\n  }, {\n    key: \"_attemptCharCodeUntilFn\",\n    value: function _attemptCharCodeUntilFn(predicate) {\n      while (!predicate(this._cursor.peek())) {\n        this._cursor.advance();\n      }\n    }\n  }, {\n    key: \"_requireCharCodeUntilFn\",\n    value: function _requireCharCodeUntilFn(predicate, len) {\n      var start = this._cursor.clone();\n\n      this._attemptCharCodeUntilFn(predicate);\n\n      if (this._cursor.diff(start) < len) {\n        throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));\n      }\n    }\n  }, {\n    key: \"_attemptUntilChar\",\n    value: function _attemptUntilChar(char) {\n      while (this._cursor.peek() !== char) {\n        this._cursor.advance();\n      }\n    }\n  }, {\n    key: \"_readChar\",\n    value: function _readChar(decodeEntities) {\n      if (decodeEntities && this._cursor.peek() === $AMPERSAND) {\n        return this._decodeEntity();\n      } else {\n        // Don't rely upon reading directly from `_input` as the actual char value\n        // may have been generated from an escape sequence.\n        var char = String.fromCodePoint(this._cursor.peek());\n\n        this._cursor.advance();\n\n        return char;\n      }\n    }\n  }, {\n    key: \"_decodeEntity\",\n    value: function _decodeEntity() {\n      var start = this._cursor.clone();\n\n      this._cursor.advance();\n\n      if (this._attemptCharCode($HASH)) {\n        var isHex = this._attemptCharCode($x) || this._attemptCharCode($X);\n\n        var codeStart = this._cursor.clone();\n\n        this._attemptCharCodeUntilFn(isDigitEntityEnd);\n\n        if (this._cursor.peek() != $SEMICOLON) {\n          throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan());\n        }\n\n        var strNum = this._cursor.getChars(codeStart);\n\n        this._cursor.advance();\n\n        try {\n          var charCode = parseInt(strNum, isHex ? 16 : 10);\n          return String.fromCharCode(charCode);\n        } catch (_a) {\n          throw this._createError(_unknownEntityErrorMsg(this._cursor.getChars(start)), this._cursor.getSpan());\n        }\n      } else {\n        var nameStart = this._cursor.clone();\n\n        this._attemptCharCodeUntilFn(isNamedEntityEnd);\n\n        if (this._cursor.peek() != $SEMICOLON) {\n          this._cursor = nameStart;\n          return '&';\n        }\n\n        var name = this._cursor.getChars(nameStart);\n\n        this._cursor.advance();\n\n        var char = NAMED_ENTITIES[name];\n\n        if (!char) {\n          throw this._createError(_unknownEntityErrorMsg(name), this._cursor.getSpan(start));\n        }\n\n        return char;\n      }\n    }\n  }, {\n    key: \"_consumeRawText\",\n    value: function _consumeRawText(decodeEntities, endMarkerPredicate) {\n      this._beginToken(decodeEntities ? TokenType.ESCAPABLE_RAW_TEXT : TokenType.RAW_TEXT);\n\n      var parts = [];\n\n      while (true) {\n        var tagCloseStart = this._cursor.clone();\n\n        var foundEndMarker = endMarkerPredicate();\n        this._cursor = tagCloseStart;\n\n        if (foundEndMarker) {\n          break;\n        }\n\n        parts.push(this._readChar(decodeEntities));\n      }\n\n      return this._endToken([this._processCarriageReturns(parts.join(''))]);\n    }\n  }, {\n    key: \"_consumeComment\",\n    value: function _consumeComment(start) {\n      var _this126 = this;\n\n      this._beginToken(TokenType.COMMENT_START, start);\n\n      this._requireCharCode($MINUS);\n\n      this._endToken([]);\n\n      this._consumeRawText(false, function () {\n        return _this126._attemptStr('-->');\n      });\n\n      this._beginToken(TokenType.COMMENT_END);\n\n      this._requireStr('-->');\n\n      this._endToken([]);\n    }\n  }, {\n    key: \"_consumeCdata\",\n    value: function _consumeCdata(start) {\n      var _this127 = this;\n\n      this._beginToken(TokenType.CDATA_START, start);\n\n      this._requireStr('CDATA[');\n\n      this._endToken([]);\n\n      this._consumeRawText(false, function () {\n        return _this127._attemptStr(']]>');\n      });\n\n      this._beginToken(TokenType.CDATA_END);\n\n      this._requireStr(']]>');\n\n      this._endToken([]);\n    }\n  }, {\n    key: \"_consumeDocType\",\n    value: function _consumeDocType(start) {\n      this._beginToken(TokenType.DOC_TYPE, start);\n\n      var contentStart = this._cursor.clone();\n\n      this._attemptUntilChar($GT);\n\n      var content = this._cursor.getChars(contentStart);\n\n      this._cursor.advance();\n\n      this._endToken([content]);\n    }\n  }, {\n    key: \"_consumePrefixAndName\",\n    value: function _consumePrefixAndName() {\n      var nameOrPrefixStart = this._cursor.clone();\n\n      var prefix = '';\n\n      while (this._cursor.peek() !== $COLON && !isPrefixEnd(this._cursor.peek())) {\n        this._cursor.advance();\n      }\n\n      var nameStart;\n\n      if (this._cursor.peek() === $COLON) {\n        prefix = this._cursor.getChars(nameOrPrefixStart);\n\n        this._cursor.advance();\n\n        nameStart = this._cursor.clone();\n      } else {\n        nameStart = nameOrPrefixStart;\n      }\n\n      this._requireCharCodeUntilFn(isNameEnd, prefix === '' ? 0 : 1);\n\n      var name = this._cursor.getChars(nameStart);\n\n      return [prefix, name];\n    }\n  }, {\n    key: \"_consumeTagOpen\",\n    value: function _consumeTagOpen(start) {\n      var tagName;\n      var prefix;\n      var openTagToken;\n      var tokensBeforeTagOpen = this.tokens.length;\n\n      var innerStart = this._cursor.clone();\n\n      try {\n        if (!isAsciiLetter(this._cursor.peek())) {\n          throw this._createError(_unexpectedCharacterErrorMsg(this._cursor.peek()), this._cursor.getSpan(start));\n        }\n\n        openTagToken = this._consumeTagOpenStart(start);\n        prefix = openTagToken.parts[0];\n        tagName = openTagToken.parts[1];\n\n        this._attemptCharCodeUntilFn(isNotWhitespace);\n\n        while (this._cursor.peek() !== $SLASH && this._cursor.peek() !== $GT) {\n          this._consumeAttributeName();\n\n          this._attemptCharCodeUntilFn(isNotWhitespace);\n\n          if (this._attemptCharCode($EQ)) {\n            this._attemptCharCodeUntilFn(isNotWhitespace);\n\n            this._consumeAttributeValue();\n          }\n\n          this._attemptCharCodeUntilFn(isNotWhitespace);\n        }\n\n        this._consumeTagOpenEnd();\n      } catch (e) {\n        if (e instanceof _ControlFlowError) {\n          // When the start tag is invalid (including invalid \"attributes\"), assume we want a \"<\"\n          this._cursor = innerStart;\n\n          if (openTagToken) {\n            this.tokens.length = tokensBeforeTagOpen;\n          } // Back to back text tokens are merged at the end\n\n\n          this._beginToken(TokenType.TEXT, start);\n\n          this._endToken(['<']);\n\n          return;\n        }\n\n        throw e;\n      }\n\n      var contentTokenType = this._getTagDefinition(tagName).contentType;\n\n      if (contentTokenType === TagContentType.RAW_TEXT) {\n        this._consumeRawTextWithTagClose(prefix, tagName, false);\n      } else if (contentTokenType === TagContentType.ESCAPABLE_RAW_TEXT) {\n        this._consumeRawTextWithTagClose(prefix, tagName, true);\n      }\n    }\n  }, {\n    key: \"_consumeRawTextWithTagClose\",\n    value: function _consumeRawTextWithTagClose(prefix, tagName, decodeEntities) {\n      var _this128 = this;\n\n      var textToken = this._consumeRawText(decodeEntities, function () {\n        if (!_this128._attemptCharCode($LT)) return false;\n        if (!_this128._attemptCharCode($SLASH)) return false;\n\n        _this128._attemptCharCodeUntilFn(isNotWhitespace);\n\n        if (!_this128._attemptStrCaseInsensitive(tagName)) return false;\n\n        _this128._attemptCharCodeUntilFn(isNotWhitespace);\n\n        return _this128._attemptCharCode($GT);\n      });\n\n      this._beginToken(TokenType.TAG_CLOSE);\n\n      this._requireCharCodeUntilFn(function (code) {\n        return code === $GT;\n      }, 3);\n\n      this._cursor.advance(); // Consume the `>`\n\n\n      this._endToken([prefix, tagName]);\n    }\n  }, {\n    key: \"_consumeTagOpenStart\",\n    value: function _consumeTagOpenStart(start) {\n      this._beginToken(TokenType.TAG_OPEN_START, start);\n\n      var parts = this._consumePrefixAndName();\n\n      return this._endToken(parts);\n    }\n  }, {\n    key: \"_consumeAttributeName\",\n    value: function _consumeAttributeName() {\n      var attrNameStart = this._cursor.peek();\n\n      if (attrNameStart === $SQ || attrNameStart === $DQ) {\n        throw this._createError(_unexpectedCharacterErrorMsg(attrNameStart), this._cursor.getSpan());\n      }\n\n      this._beginToken(TokenType.ATTR_NAME);\n\n      var prefixAndName = this._consumePrefixAndName();\n\n      this._endToken(prefixAndName);\n    }\n  }, {\n    key: \"_consumeAttributeValue\",\n    value: function _consumeAttributeValue() {\n      var value;\n\n      if (this._cursor.peek() === $SQ || this._cursor.peek() === $DQ) {\n        this._beginToken(TokenType.ATTR_QUOTE);\n\n        var quoteChar = this._cursor.peek();\n\n        this._cursor.advance();\n\n        this._endToken([String.fromCodePoint(quoteChar)]);\n\n        this._beginToken(TokenType.ATTR_VALUE);\n\n        var parts = [];\n\n        while (this._cursor.peek() !== quoteChar) {\n          parts.push(this._readChar(true));\n        }\n\n        value = parts.join('');\n\n        this._endToken([this._processCarriageReturns(value)]);\n\n        this._beginToken(TokenType.ATTR_QUOTE);\n\n        this._cursor.advance();\n\n        this._endToken([String.fromCodePoint(quoteChar)]);\n      } else {\n        this._beginToken(TokenType.ATTR_VALUE);\n\n        var valueStart = this._cursor.clone();\n\n        this._requireCharCodeUntilFn(isNameEnd, 1);\n\n        value = this._cursor.getChars(valueStart);\n\n        this._endToken([this._processCarriageReturns(value)]);\n      }\n    }\n  }, {\n    key: \"_consumeTagOpenEnd\",\n    value: function _consumeTagOpenEnd() {\n      var tokenType = this._attemptCharCode($SLASH) ? TokenType.TAG_OPEN_END_VOID : TokenType.TAG_OPEN_END;\n\n      this._beginToken(tokenType);\n\n      this._requireCharCode($GT);\n\n      this._endToken([]);\n    }\n  }, {\n    key: \"_consumeTagClose\",\n    value: function _consumeTagClose(start) {\n      this._beginToken(TokenType.TAG_CLOSE, start);\n\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n\n      var prefixAndName = this._consumePrefixAndName();\n\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n\n      this._requireCharCode($GT);\n\n      this._endToken(prefixAndName);\n    }\n  }, {\n    key: \"_consumeExpansionFormStart\",\n    value: function _consumeExpansionFormStart() {\n      this._beginToken(TokenType.EXPANSION_FORM_START);\n\n      this._requireCharCode($LBRACE);\n\n      this._endToken([]);\n\n      this._expansionCaseStack.push(TokenType.EXPANSION_FORM_START);\n\n      this._beginToken(TokenType.RAW_TEXT);\n\n      var condition = this._readUntil($COMMA);\n\n      var normalizedCondition = this._processCarriageReturns(condition);\n\n      if (this._escapedString || this._i18nNormalizeLineEndingsInICUs) {\n        // Either the template is inline or,\n        // we explicitly want to normalize line endings for this text.\n        this._endToken([normalizedCondition]);\n      } else {\n        // The expression is in an external template and, for backward compatibility,\n        // we are not normalizing line endings.\n        var conditionToken = this._endToken([condition]);\n\n        if (normalizedCondition !== condition) {\n          this.nonNormalizedIcuExpressions.push(conditionToken);\n        }\n      }\n\n      this._requireCharCode($COMMA);\n\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n\n      this._beginToken(TokenType.RAW_TEXT);\n\n      var type = this._readUntil($COMMA);\n\n      this._endToken([type]);\n\n      this._requireCharCode($COMMA);\n\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n    }\n  }, {\n    key: \"_consumeExpansionCaseStart\",\n    value: function _consumeExpansionCaseStart() {\n      this._beginToken(TokenType.EXPANSION_CASE_VALUE);\n\n      var value = this._readUntil($LBRACE).trim();\n\n      this._endToken([value]);\n\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n\n      this._beginToken(TokenType.EXPANSION_CASE_EXP_START);\n\n      this._requireCharCode($LBRACE);\n\n      this._endToken([]);\n\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n\n      this._expansionCaseStack.push(TokenType.EXPANSION_CASE_EXP_START);\n    }\n  }, {\n    key: \"_consumeExpansionCaseEnd\",\n    value: function _consumeExpansionCaseEnd() {\n      this._beginToken(TokenType.EXPANSION_CASE_EXP_END);\n\n      this._requireCharCode($RBRACE);\n\n      this._endToken([]);\n\n      this._attemptCharCodeUntilFn(isNotWhitespace);\n\n      this._expansionCaseStack.pop();\n    }\n  }, {\n    key: \"_consumeExpansionFormEnd\",\n    value: function _consumeExpansionFormEnd() {\n      this._beginToken(TokenType.EXPANSION_FORM_END);\n\n      this._requireCharCode($RBRACE);\n\n      this._endToken([]);\n\n      this._expansionCaseStack.pop();\n    }\n  }, {\n    key: \"_consumeText\",\n    value: function _consumeText() {\n      var start = this._cursor.clone();\n\n      this._beginToken(TokenType.TEXT, start);\n\n      var parts = [];\n\n      do {\n        if (this._interpolationConfig && this._attemptStr(this._interpolationConfig.start)) {\n          parts.push(this._interpolationConfig.start);\n          this._inInterpolation = true;\n        } else if (this._interpolationConfig && this._inInterpolation && this._attemptStr(this._interpolationConfig.end)) {\n          parts.push(this._interpolationConfig.end);\n          this._inInterpolation = false;\n        } else {\n          parts.push(this._readChar(true));\n        }\n      } while (!this._isTextEnd());\n\n      this._endToken([this._processCarriageReturns(parts.join(''))]);\n    }\n  }, {\n    key: \"_isTextEnd\",\n    value: function _isTextEnd() {\n      if (this._cursor.peek() === $LT || this._cursor.peek() === $EOF) {\n        return true;\n      }\n\n      if (this._tokenizeIcu && !this._inInterpolation) {\n        if (this.isExpansionFormStart()) {\n          // start of an expansion form\n          return true;\n        }\n\n        if (this._cursor.peek() === $RBRACE && this._isInExpansionCase()) {\n          // end of and expansion case\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_readUntil\",\n    value: function _readUntil(char) {\n      var start = this._cursor.clone();\n\n      this._attemptUntilChar(char);\n\n      return this._cursor.getChars(start);\n    }\n  }, {\n    key: \"_isInExpansionCase\",\n    value: function _isInExpansionCase() {\n      return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === TokenType.EXPANSION_CASE_EXP_START;\n    }\n  }, {\n    key: \"_isInExpansionForm\",\n    value: function _isInExpansionForm() {\n      return this._expansionCaseStack.length > 0 && this._expansionCaseStack[this._expansionCaseStack.length - 1] === TokenType.EXPANSION_FORM_START;\n    }\n  }, {\n    key: \"isExpansionFormStart\",\n    value: function isExpansionFormStart() {\n      if (this._cursor.peek() !== $LBRACE) {\n        return false;\n      }\n\n      if (this._interpolationConfig) {\n        var start = this._cursor.clone();\n\n        var isInterpolation = this._attemptStr(this._interpolationConfig.start);\n\n        this._cursor = start;\n        return !isInterpolation;\n      }\n\n      return true;\n    }\n  }]);\n\n  return _Tokenizer;\n}();\n\nfunction isNotWhitespace(code) {\n  return !isWhitespace(code) || code === $EOF;\n}\n\nfunction isNameEnd(code) {\n  return isWhitespace(code) || code === $GT || code === $SLASH || code === $SQ || code === $DQ || code === $EQ;\n}\n\nfunction isPrefixEnd(code) {\n  return (code < $a || $z < code) && (code < $A || $Z < code) && (code < $0 || code > $9);\n}\n\nfunction isDigitEntityEnd(code) {\n  return code == $SEMICOLON || code == $EOF || !isAsciiHexDigit(code);\n}\n\nfunction isNamedEntityEnd(code) {\n  return code == $SEMICOLON || code == $EOF || !isAsciiLetter(code);\n}\n\nfunction isExpansionCaseStart(peek) {\n  return peek !== $RBRACE;\n}\n\nfunction compareCharCodeCaseInsensitive(code1, code2) {\n  return toUpperCaseCharCode(code1) == toUpperCaseCharCode(code2);\n}\n\nfunction toUpperCaseCharCode(code) {\n  return code >= $a && code <= $z ? code - $a + $A : code;\n}\n\nfunction mergeTextTokens(srcTokens) {\n  var dstTokens = [];\n  var lastDstToken = undefined;\n\n  for (var i = 0; i < srcTokens.length; i++) {\n    var token = srcTokens[i];\n\n    if (lastDstToken && lastDstToken.type == TokenType.TEXT && token.type == TokenType.TEXT) {\n      lastDstToken.parts[0] += token.parts[0];\n      lastDstToken.sourceSpan.end = token.sourceSpan.end;\n    } else {\n      lastDstToken = token;\n      dstTokens.push(lastDstToken);\n    }\n  }\n\n  return dstTokens;\n}\n\nvar PlainCharacterCursor = /*#__PURE__*/function () {\n  function PlainCharacterCursor(fileOrCursor, range) {\n    _classCallCheck(this, PlainCharacterCursor);\n\n    if (fileOrCursor instanceof PlainCharacterCursor) {\n      this.file = fileOrCursor.file;\n      this.input = fileOrCursor.input;\n      this.end = fileOrCursor.end;\n      var state = fileOrCursor.state; // Note: avoid using `{...fileOrCursor.state}` here as that has a severe performance penalty.\n      // In ES5 bundles the object spread operator is translated into the `__assign` helper, which\n      // is not optimized by VMs as efficiently as a raw object literal. Since this constructor is\n      // called in tight loops, this difference matters.\n\n      this.state = {\n        peek: state.peek,\n        offset: state.offset,\n        line: state.line,\n        column: state.column\n      };\n    } else {\n      if (!range) {\n        throw new Error('Programming error: the range argument must be provided with a file argument.');\n      }\n\n      this.file = fileOrCursor;\n      this.input = fileOrCursor.content;\n      this.end = range.endPos;\n      this.state = {\n        peek: -1,\n        offset: range.startPos,\n        line: range.startLine,\n        column: range.startCol\n      };\n    }\n  }\n\n  _createClass(PlainCharacterCursor, [{\n    key: \"clone\",\n    value: function clone() {\n      return new PlainCharacterCursor(this);\n    }\n  }, {\n    key: \"peek\",\n    value: function peek() {\n      return this.state.peek;\n    }\n  }, {\n    key: \"charsLeft\",\n    value: function charsLeft() {\n      return this.end - this.state.offset;\n    }\n  }, {\n    key: \"diff\",\n    value: function diff(other) {\n      return this.state.offset - other.state.offset;\n    }\n  }, {\n    key: \"advance\",\n    value: function advance() {\n      this.advanceState(this.state);\n    }\n  }, {\n    key: \"init\",\n    value: function init() {\n      this.updatePeek(this.state);\n    }\n  }, {\n    key: \"getSpan\",\n    value: function getSpan(start, leadingTriviaCodePoints) {\n      start = start || this;\n      var cloned = false;\n\n      if (leadingTriviaCodePoints) {\n        while (this.diff(start) > 0 && leadingTriviaCodePoints.indexOf(start.peek()) !== -1) {\n          if (!cloned) {\n            start = start.clone();\n            cloned = true;\n          }\n\n          start.advance();\n        }\n      }\n\n      return new ParseSourceSpan(new ParseLocation(start.file, start.state.offset, start.state.line, start.state.column), new ParseLocation(this.file, this.state.offset, this.state.line, this.state.column));\n    }\n  }, {\n    key: \"getChars\",\n    value: function getChars(start) {\n      return this.input.substring(start.state.offset, this.state.offset);\n    }\n  }, {\n    key: \"charAt\",\n    value: function charAt(pos) {\n      return this.input.charCodeAt(pos);\n    }\n  }, {\n    key: \"advanceState\",\n    value: function advanceState(state) {\n      if (state.offset >= this.end) {\n        this.state = state;\n        throw new CursorError('Unexpected character \"EOF\"', this);\n      }\n\n      var currentChar = this.charAt(state.offset);\n\n      if (currentChar === $LF) {\n        state.line++;\n        state.column = 0;\n      } else if (!isNewLine(currentChar)) {\n        state.column++;\n      }\n\n      state.offset++;\n      this.updatePeek(state);\n    }\n  }, {\n    key: \"updatePeek\",\n    value: function updatePeek(state) {\n      state.peek = state.offset >= this.end ? $EOF : this.charAt(state.offset);\n    }\n  }]);\n\n  return PlainCharacterCursor;\n}();\n\nvar EscapedCharacterCursor = /*#__PURE__*/function (_PlainCharacterCursor) {\n  _inherits(EscapedCharacterCursor, _PlainCharacterCursor);\n\n  var _super82 = _createSuper(EscapedCharacterCursor);\n\n  function EscapedCharacterCursor(fileOrCursor, range) {\n    var _this129;\n\n    _classCallCheck(this, EscapedCharacterCursor);\n\n    if (fileOrCursor instanceof EscapedCharacterCursor) {\n      _this129 = _super82.call(this, fileOrCursor);\n      _this129.internalState = Object.assign({}, fileOrCursor.internalState);\n    } else {\n      _this129 = _super82.call(this, fileOrCursor, range);\n      _this129.internalState = _this129.state;\n    }\n\n    return _possibleConstructorReturn(_this129);\n  }\n\n  _createClass(EscapedCharacterCursor, [{\n    key: \"advance\",\n    value: function advance() {\n      this.state = this.internalState;\n\n      _get(_getPrototypeOf(EscapedCharacterCursor.prototype), \"advance\", this).call(this);\n\n      this.processEscapeSequence();\n    }\n  }, {\n    key: \"init\",\n    value: function init() {\n      _get(_getPrototypeOf(EscapedCharacterCursor.prototype), \"init\", this).call(this);\n\n      this.processEscapeSequence();\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new EscapedCharacterCursor(this);\n    }\n  }, {\n    key: \"getChars\",\n    value: function getChars(start) {\n      var cursor = start.clone();\n      var chars = '';\n\n      while (cursor.internalState.offset < this.internalState.offset) {\n        chars += String.fromCodePoint(cursor.peek());\n        cursor.advance();\n      }\n\n      return chars;\n    }\n    /**\n     * Process the escape sequence that starts at the current position in the text.\n     *\n     * This method is called to ensure that `peek` has the unescaped value of escape sequences.\n     */\n\n  }, {\n    key: \"processEscapeSequence\",\n    value: function processEscapeSequence() {\n      var _this130 = this;\n\n      var peek = function peek() {\n        return _this130.internalState.peek;\n      };\n\n      if (peek() === $BACKSLASH) {\n        // We have hit an escape sequence so we need the internal state to become independent\n        // of the external state.\n        this.internalState = Object.assign({}, this.state); // Move past the backslash\n\n        this.advanceState(this.internalState); // First check for standard control char sequences\n\n        if (peek() === $n) {\n          this.state.peek = $LF;\n        } else if (peek() === $r) {\n          this.state.peek = $CR;\n        } else if (peek() === $v) {\n          this.state.peek = $VTAB;\n        } else if (peek() === $t) {\n          this.state.peek = $TAB;\n        } else if (peek() === $b) {\n          this.state.peek = $BSPACE;\n        } else if (peek() === $f) {\n          this.state.peek = $FF;\n        } // Now consider more complex sequences\n        else if (peek() === $u) {\n            // Unicode code-point sequence\n            this.advanceState(this.internalState); // advance past the `u` char\n\n            if (peek() === $LBRACE) {\n              // Variable length Unicode, e.g. `\\x{123}`\n              this.advanceState(this.internalState); // advance past the `{` char\n              // Advance past the variable number of hex digits until we hit a `}` char\n\n              var digitStart = this.clone();\n              var length = 0;\n\n              while (peek() !== $RBRACE) {\n                this.advanceState(this.internalState);\n                length++;\n              }\n\n              this.state.peek = this.decodeHexDigits(digitStart, length);\n            } else {\n              // Fixed length Unicode, e.g. `\\u1234`\n              var _digitStart = this.clone();\n\n              this.advanceState(this.internalState);\n              this.advanceState(this.internalState);\n              this.advanceState(this.internalState);\n              this.state.peek = this.decodeHexDigits(_digitStart, 4);\n            }\n          } else if (peek() === $x) {\n            // Hex char code, e.g. `\\x2F`\n            this.advanceState(this.internalState); // advance past the `x` char\n\n            var _digitStart2 = this.clone();\n\n            this.advanceState(this.internalState);\n            this.state.peek = this.decodeHexDigits(_digitStart2, 2);\n          } else if (isOctalDigit(peek())) {\n            // Octal char code, e.g. `\\012`,\n            var octal = '';\n            var _length = 0;\n            var previous = this.clone();\n\n            while (isOctalDigit(peek()) && _length < 3) {\n              previous = this.clone();\n              octal += String.fromCodePoint(peek());\n              this.advanceState(this.internalState);\n              _length++;\n            }\n\n            this.state.peek = parseInt(octal, 8); // Backup one char\n\n            this.internalState = previous.internalState;\n          } else if (isNewLine(this.internalState.peek)) {\n            // Line continuation `\\` followed by a new line\n            this.advanceState(this.internalState); // advance over the newline\n\n            this.state = this.internalState;\n          } else {\n            // If none of the `if` blocks were executed then we just have an escaped normal character.\n            // In that case we just, effectively, skip the backslash from the character.\n            this.state.peek = this.internalState.peek;\n          }\n      }\n    }\n  }, {\n    key: \"decodeHexDigits\",\n    value: function decodeHexDigits(start, length) {\n      var hex = this.input.substr(start.internalState.offset, length);\n      var charCode = parseInt(hex, 16);\n\n      if (!isNaN(charCode)) {\n        return charCode;\n      } else {\n        start.state = start.internalState;\n        throw new CursorError('Invalid hexadecimal escape sequence', start);\n      }\n    }\n  }]);\n\n  return EscapedCharacterCursor;\n}(PlainCharacterCursor);\n\nvar CursorError = function CursorError(msg, cursor) {\n  _classCallCheck(this, CursorError);\n\n  this.msg = msg;\n  this.cursor = cursor;\n};\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar TreeError = /*#__PURE__*/function (_ParseError2) {\n  _inherits(TreeError, _ParseError2);\n\n  var _super83 = _createSuper(TreeError);\n\n  function TreeError(elementName, span, msg) {\n    var _this131;\n\n    _classCallCheck(this, TreeError);\n\n    _this131 = _super83.call(this, span, msg);\n    _this131.elementName = elementName;\n    return _this131;\n  }\n\n  _createClass(TreeError, null, [{\n    key: \"create\",\n    value: function create(elementName, span, msg) {\n      return new TreeError(elementName, span, msg);\n    }\n  }]);\n\n  return TreeError;\n}(ParseError);\n\nvar ParseTreeResult = function ParseTreeResult(rootNodes, errors) {\n  _classCallCheck(this, ParseTreeResult);\n\n  this.rootNodes = rootNodes;\n  this.errors = errors;\n};\n\nvar Parser = /*#__PURE__*/function () {\n  function Parser(getTagDefinition) {\n    _classCallCheck(this, Parser);\n\n    this.getTagDefinition = getTagDefinition;\n  }\n\n  _createClass(Parser, [{\n    key: \"parse\",\n    value: function parse(source, url, options) {\n      var tokenizeResult = tokenize(source, url, this.getTagDefinition, options);\n      var parser = new _TreeBuilder(tokenizeResult.tokens, this.getTagDefinition);\n      parser.build();\n      return new ParseTreeResult(parser.rootNodes, tokenizeResult.errors.concat(parser.errors));\n    }\n  }]);\n\n  return Parser;\n}();\n\nvar _TreeBuilder = /*#__PURE__*/function () {\n  function _TreeBuilder(tokens, getTagDefinition) {\n    _classCallCheck(this, _TreeBuilder);\n\n    this.tokens = tokens;\n    this.getTagDefinition = getTagDefinition;\n    this._index = -1;\n    this._elementStack = [];\n    this.rootNodes = [];\n    this.errors = [];\n\n    this._advance();\n  }\n\n  _createClass(_TreeBuilder, [{\n    key: \"build\",\n    value: function build() {\n      while (this._peek.type !== TokenType.EOF) {\n        if (this._peek.type === TokenType.TAG_OPEN_START) {\n          this._consumeStartTag(this._advance());\n        } else if (this._peek.type === TokenType.TAG_CLOSE) {\n          this._consumeEndTag(this._advance());\n        } else if (this._peek.type === TokenType.CDATA_START) {\n          this._closeVoidElement();\n\n          this._consumeCdata(this._advance());\n        } else if (this._peek.type === TokenType.COMMENT_START) {\n          this._closeVoidElement();\n\n          this._consumeComment(this._advance());\n        } else if (this._peek.type === TokenType.TEXT || this._peek.type === TokenType.RAW_TEXT || this._peek.type === TokenType.ESCAPABLE_RAW_TEXT) {\n          this._closeVoidElement();\n\n          this._consumeText(this._advance());\n        } else if (this._peek.type === TokenType.EXPANSION_FORM_START) {\n          this._consumeExpansion(this._advance());\n        } else {\n          // Skip all other tokens...\n          this._advance();\n        }\n      }\n    }\n  }, {\n    key: \"_advance\",\n    value: function _advance() {\n      var prev = this._peek;\n\n      if (this._index < this.tokens.length - 1) {\n        // Note: there is always an EOF token at the end\n        this._index++;\n      }\n\n      this._peek = this.tokens[this._index];\n      return prev;\n    }\n  }, {\n    key: \"_advanceIf\",\n    value: function _advanceIf(type) {\n      if (this._peek.type === type) {\n        return this._advance();\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_consumeCdata\",\n    value: function _consumeCdata(_startToken) {\n      this._consumeText(this._advance());\n\n      this._advanceIf(TokenType.CDATA_END);\n    }\n  }, {\n    key: \"_consumeComment\",\n    value: function _consumeComment(token) {\n      var text = this._advanceIf(TokenType.RAW_TEXT);\n\n      this._advanceIf(TokenType.COMMENT_END);\n\n      var value = text != null ? text.parts[0].trim() : null;\n\n      this._addToParent(new Comment(value, token.sourceSpan));\n    }\n  }, {\n    key: \"_consumeExpansion\",\n    value: function _consumeExpansion(token) {\n      var switchValue = this._advance();\n\n      var type = this._advance();\n\n      var cases = []; // read =\n\n      while (this._peek.type === TokenType.EXPANSION_CASE_VALUE) {\n        var expCase = this._parseExpansionCase();\n\n        if (!expCase) return; // error\n\n        cases.push(expCase);\n      } // read the final }\n\n\n      if (this._peek.type !== TokenType.EXPANSION_FORM_END) {\n        this.errors.push(TreeError.create(null, this._peek.sourceSpan, \"Invalid ICU message. Missing '}'.\"));\n        return;\n      }\n\n      var sourceSpan = new ParseSourceSpan(token.sourceSpan.start, this._peek.sourceSpan.end);\n\n      this._addToParent(new Expansion(switchValue.parts[0], type.parts[0], cases, sourceSpan, switchValue.sourceSpan));\n\n      this._advance();\n    }\n  }, {\n    key: \"_parseExpansionCase\",\n    value: function _parseExpansionCase() {\n      var value = this._advance(); // read {\n\n\n      if (this._peek.type !== TokenType.EXPANSION_CASE_EXP_START) {\n        this.errors.push(TreeError.create(null, this._peek.sourceSpan, \"Invalid ICU message. Missing '{'.\"));\n        return null;\n      } // read until }\n\n\n      var start = this._advance();\n\n      var exp = this._collectExpansionExpTokens(start);\n\n      if (!exp) return null;\n\n      var end = this._advance();\n\n      exp.push(new Token(TokenType.EOF, [], end.sourceSpan)); // parse everything in between { and }\n\n      var expansionCaseParser = new _TreeBuilder(exp, this.getTagDefinition);\n      expansionCaseParser.build();\n\n      if (expansionCaseParser.errors.length > 0) {\n        this.errors = this.errors.concat(expansionCaseParser.errors);\n        return null;\n      }\n\n      var sourceSpan = new ParseSourceSpan(value.sourceSpan.start, end.sourceSpan.end);\n      var expSourceSpan = new ParseSourceSpan(start.sourceSpan.start, end.sourceSpan.end);\n      return new ExpansionCase(value.parts[0], expansionCaseParser.rootNodes, sourceSpan, value.sourceSpan, expSourceSpan);\n    }\n  }, {\n    key: \"_collectExpansionExpTokens\",\n    value: function _collectExpansionExpTokens(start) {\n      var exp = [];\n      var expansionFormStack = [TokenType.EXPANSION_CASE_EXP_START];\n\n      while (true) {\n        if (this._peek.type === TokenType.EXPANSION_FORM_START || this._peek.type === TokenType.EXPANSION_CASE_EXP_START) {\n          expansionFormStack.push(this._peek.type);\n        }\n\n        if (this._peek.type === TokenType.EXPANSION_CASE_EXP_END) {\n          if (lastOnStack(expansionFormStack, TokenType.EXPANSION_CASE_EXP_START)) {\n            expansionFormStack.pop();\n            if (expansionFormStack.length == 0) return exp;\n          } else {\n            this.errors.push(TreeError.create(null, start.sourceSpan, \"Invalid ICU message. Missing '}'.\"));\n            return null;\n          }\n        }\n\n        if (this._peek.type === TokenType.EXPANSION_FORM_END) {\n          if (lastOnStack(expansionFormStack, TokenType.EXPANSION_FORM_START)) {\n            expansionFormStack.pop();\n          } else {\n            this.errors.push(TreeError.create(null, start.sourceSpan, \"Invalid ICU message. Missing '}'.\"));\n            return null;\n          }\n        }\n\n        if (this._peek.type === TokenType.EOF) {\n          this.errors.push(TreeError.create(null, start.sourceSpan, \"Invalid ICU message. Missing '}'.\"));\n          return null;\n        }\n\n        exp.push(this._advance());\n      }\n    }\n  }, {\n    key: \"_consumeText\",\n    value: function _consumeText(token) {\n      var text = token.parts[0];\n\n      if (text.length > 0 && text[0] == '\\n') {\n        var parent = this._getParentElement();\n\n        if (parent != null && parent.children.length == 0 && this.getTagDefinition(parent.name).ignoreFirstLf) {\n          text = text.substring(1);\n        }\n      }\n\n      if (text.length > 0) {\n        this._addToParent(new Text$3(text, token.sourceSpan));\n      }\n    }\n  }, {\n    key: \"_closeVoidElement\",\n    value: function _closeVoidElement() {\n      var el = this._getParentElement();\n\n      if (el && this.getTagDefinition(el.name).isVoid) {\n        this._elementStack.pop();\n      }\n    }\n  }, {\n    key: \"_consumeStartTag\",\n    value: function _consumeStartTag(startTagToken) {\n      var prefix = startTagToken.parts[0];\n      var name = startTagToken.parts[1];\n      var attrs = [];\n\n      while (this._peek.type === TokenType.ATTR_NAME) {\n        attrs.push(this._consumeAttr(this._advance()));\n      }\n\n      var fullName = this._getElementFullName(prefix, name, this._getParentElement());\n\n      var selfClosing = false; // Note: There could have been a tokenizer error\n      // so that we don't get a token for the end tag...\n\n      if (this._peek.type === TokenType.TAG_OPEN_END_VOID) {\n        this._advance();\n\n        selfClosing = true;\n        var tagDef = this.getTagDefinition(fullName);\n\n        if (!(tagDef.canSelfClose || getNsPrefix(fullName) !== null || tagDef.isVoid)) {\n          this.errors.push(TreeError.create(fullName, startTagToken.sourceSpan, \"Only void and foreign elements can be self closed \\\"\".concat(startTagToken.parts[1], \"\\\"\")));\n        }\n      } else if (this._peek.type === TokenType.TAG_OPEN_END) {\n        this._advance();\n\n        selfClosing = false;\n      }\n\n      var end = this._peek.sourceSpan.start;\n      var span = new ParseSourceSpan(startTagToken.sourceSpan.start, end);\n      var el = new Element$1(fullName, attrs, [], span, span, undefined);\n\n      this._pushElement(el);\n\n      if (selfClosing) {\n        this._popElement(fullName);\n\n        el.endSourceSpan = span;\n      }\n    }\n  }, {\n    key: \"_pushElement\",\n    value: function _pushElement(el) {\n      var parentEl = this._getParentElement();\n\n      if (parentEl && this.getTagDefinition(parentEl.name).isClosedByChild(el.name)) {\n        this._elementStack.pop();\n      }\n\n      this._addToParent(el);\n\n      this._elementStack.push(el);\n    }\n  }, {\n    key: \"_consumeEndTag\",\n    value: function _consumeEndTag(endTagToken) {\n      var fullName = this._getElementFullName(endTagToken.parts[0], endTagToken.parts[1], this._getParentElement());\n\n      if (this._getParentElement()) {\n        this._getParentElement().endSourceSpan = endTagToken.sourceSpan;\n      }\n\n      if (this.getTagDefinition(fullName).isVoid) {\n        this.errors.push(TreeError.create(fullName, endTagToken.sourceSpan, \"Void elements do not have end tags \\\"\".concat(endTagToken.parts[1], \"\\\"\")));\n      } else if (!this._popElement(fullName)) {\n        var errMsg = \"Unexpected closing tag \\\"\".concat(fullName, \"\\\". It may happen when the tag has already been closed by another tag. For more info see https://www.w3.org/TR/html5/syntax.html#closing-elements-that-have-implied-end-tags\");\n        this.errors.push(TreeError.create(fullName, endTagToken.sourceSpan, errMsg));\n      }\n    }\n  }, {\n    key: \"_popElement\",\n    value: function _popElement(fullName) {\n      for (var stackIndex = this._elementStack.length - 1; stackIndex >= 0; stackIndex--) {\n        var el = this._elementStack[stackIndex];\n\n        if (el.name == fullName) {\n          this._elementStack.splice(stackIndex, this._elementStack.length - stackIndex);\n\n          return true;\n        }\n\n        if (!this.getTagDefinition(el.name).closedByParent) {\n          return false;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_consumeAttr\",\n    value: function _consumeAttr(attrName) {\n      var fullName = mergeNsAndName(attrName.parts[0], attrName.parts[1]);\n      var end = attrName.sourceSpan.end;\n      var value = '';\n      var valueSpan = undefined;\n\n      if (this._peek.type === TokenType.ATTR_QUOTE) {\n        this._advance();\n      }\n\n      if (this._peek.type === TokenType.ATTR_VALUE) {\n        var valueToken = this._advance();\n\n        value = valueToken.parts[0];\n        end = valueToken.sourceSpan.end;\n        valueSpan = valueToken.sourceSpan;\n      }\n\n      if (this._peek.type === TokenType.ATTR_QUOTE) {\n        var quoteToken = this._advance();\n\n        end = quoteToken.sourceSpan.end;\n      }\n\n      return new Attribute(fullName, value, new ParseSourceSpan(attrName.sourceSpan.start, end), valueSpan);\n    }\n  }, {\n    key: \"_getParentElement\",\n    value: function _getParentElement() {\n      return this._elementStack.length > 0 ? this._elementStack[this._elementStack.length - 1] : null;\n    }\n    /**\n     * Returns the parent in the DOM and the container.\n     *\n     * `<ng-container>` elements are skipped as they are not rendered as DOM element.\n     */\n\n  }, {\n    key: \"_getParentElementSkippingContainers\",\n    value: function _getParentElementSkippingContainers() {\n      var container = null;\n\n      for (var i = this._elementStack.length - 1; i >= 0; i--) {\n        if (!isNgContainer(this._elementStack[i].name)) {\n          return {\n            parent: this._elementStack[i],\n            container: container\n          };\n        }\n\n        container = this._elementStack[i];\n      }\n\n      return {\n        parent: null,\n        container: container\n      };\n    }\n  }, {\n    key: \"_addToParent\",\n    value: function _addToParent(node) {\n      var parent = this._getParentElement();\n\n      if (parent != null) {\n        parent.children.push(node);\n      } else {\n        this.rootNodes.push(node);\n      }\n    }\n    /**\n     * Insert a node between the parent and the container.\n     * When no container is given, the node is appended as a child of the parent.\n     * Also updates the element stack accordingly.\n     *\n     * @internal\n     */\n\n  }, {\n    key: \"_insertBeforeContainer\",\n    value: function _insertBeforeContainer(parent, container, node) {\n      if (!container) {\n        this._addToParent(node);\n\n        this._elementStack.push(node);\n      } else {\n        if (parent) {\n          // replace the container with the new node in the children\n          var index = parent.children.indexOf(container);\n          parent.children[index] = node;\n        } else {\n          this.rootNodes.push(node);\n        }\n\n        node.children.push(container);\n\n        this._elementStack.splice(this._elementStack.indexOf(container), 0, node);\n      }\n    }\n  }, {\n    key: \"_getElementFullName\",\n    value: function _getElementFullName(prefix, localName, parentElement) {\n      if (prefix === '') {\n        prefix = this.getTagDefinition(localName).implicitNamespacePrefix || '';\n\n        if (prefix === '' && parentElement != null) {\n          prefix = getNsPrefix(parentElement.name);\n        }\n      }\n\n      return mergeNsAndName(prefix, localName);\n    }\n  }]);\n\n  return _TreeBuilder;\n}();\n\nfunction lastOnStack(stack, element) {\n  return stack.length > 0 && stack[stack.length - 1] === element;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar HtmlParser = /*#__PURE__*/function (_Parser) {\n  _inherits(HtmlParser, _Parser);\n\n  var _super84 = _createSuper(HtmlParser);\n\n  function HtmlParser() {\n    _classCallCheck(this, HtmlParser);\n\n    return _super84.call(this, getHtmlTagDefinition);\n  }\n\n  _createClass(HtmlParser, [{\n    key: \"parse\",\n    value: function parse(source, url, options) {\n      return _get(_getPrototypeOf(HtmlParser.prototype), \"parse\", this).call(this, source, url, options);\n    }\n  }]);\n\n  return HtmlParser;\n}(Parser);\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar PRESERVE_WS_ATTR_NAME = 'ngPreserveWhitespaces';\nvar SKIP_WS_TRIM_TAGS = new Set(['pre', 'template', 'textarea', 'script', 'style']); // Equivalent to \\s with \\u00a0 (non-breaking space) excluded.\n// Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\n\nvar WS_CHARS = \" \\f\\n\\r\\t\\x0B\\u1680\\u180E\\u2000-\\u200A\\u2028\\u2029\\u202F\\u205F\\u3000\\uFEFF\";\nvar NO_WS_REGEXP = new RegExp(\"[^\".concat(WS_CHARS, \"]\"));\nvar WS_REPLACE_REGEXP = new RegExp(\"[\".concat(WS_CHARS, \"]{2,}\"), 'g');\n\nfunction hasPreserveWhitespacesAttr(attrs) {\n  return attrs.some(function (attr) {\n    return attr.name === PRESERVE_WS_ATTR_NAME;\n  });\n}\n/**\n * Angular Dart introduced &ngsp; as a placeholder for non-removable space, see:\n * https://github.com/dart-lang/angular/blob/0bb611387d29d65b5af7f9d2515ab571fd3fbee4/_tests/test/compiler/preserve_whitespace_test.dart#L25-L32\n * In Angular Dart &ngsp; is converted to the 0xE500 PUA (Private Use Areas) unicode character\n * and later on replaced by a space. We are re-implementing the same idea here.\n */\n\n\nfunction replaceNgsp(value) {\n  // lexer is replacing the &ngsp; pseudo-entity with NGSP_UNICODE\n  return value.replace(new RegExp(NGSP_UNICODE, 'g'), ' ');\n}\n/**\n * This visitor can walk HTML parse tree and remove / trim text nodes using the following rules:\n * - consider spaces, tabs and new lines as whitespace characters;\n * - drop text nodes consisting of whitespace characters only;\n * - for all other text nodes replace consecutive whitespace characters with one space;\n * - convert &ngsp; pseudo-entity to a single space;\n *\n * Removal and trimming of whitespaces have positive performance impact (less code to generate\n * while compiling templates, faster view creation). At the same time it can be \"destructive\"\n * in some cases (whitespaces can influence layout). Because of the potential of breaking layout\n * this visitor is not activated by default in Angular 5 and people need to explicitly opt-in for\n * whitespace removal. The default option for whitespace removal will be revisited in Angular 6\n * and might be changed to \"on\" by default.\n */\n\n\nvar WhitespaceVisitor = /*#__PURE__*/function () {\n  function WhitespaceVisitor() {\n    _classCallCheck(this, WhitespaceVisitor);\n  }\n\n  _createClass(WhitespaceVisitor, [{\n    key: \"visitElement\",\n    value: function visitElement(element, context) {\n      if (SKIP_WS_TRIM_TAGS.has(element.name) || hasPreserveWhitespacesAttr(element.attrs)) {\n        // don't descent into elements where we need to preserve whitespaces\n        // but still visit all attributes to eliminate one used as a market to preserve WS\n        return new Element$1(element.name, visitAll$1(this, element.attrs), element.children, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);\n      }\n\n      return new Element$1(element.name, element.attrs, visitAllWithSiblings(this, element.children), element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);\n    }\n  }, {\n    key: \"visitAttribute\",\n    value: function visitAttribute(attribute, context) {\n      return attribute.name !== PRESERVE_WS_ATTR_NAME ? attribute : null;\n    }\n  }, {\n    key: \"visitText\",\n    value: function visitText(text, context) {\n      var isNotBlank = text.value.match(NO_WS_REGEXP);\n      var hasExpansionSibling = context && (context.prev instanceof Expansion || context.next instanceof Expansion);\n\n      if (isNotBlank || hasExpansionSibling) {\n        return new Text$3(replaceNgsp(text.value).replace(WS_REPLACE_REGEXP, ' '), text.sourceSpan, text.i18n);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"visitComment\",\n    value: function visitComment(comment, context) {\n      return comment;\n    }\n  }, {\n    key: \"visitExpansion\",\n    value: function visitExpansion(expansion, context) {\n      return expansion;\n    }\n  }, {\n    key: \"visitExpansionCase\",\n    value: function visitExpansionCase(expansionCase, context) {\n      return expansionCase;\n    }\n  }]);\n\n  return WhitespaceVisitor;\n}();\n\nfunction removeWhitespaces(htmlAstWithErrors) {\n  return new ParseTreeResult(visitAll$1(new WhitespaceVisitor(), htmlAstWithErrors.rootNodes), htmlAstWithErrors.errors);\n}\n\nfunction visitAllWithSiblings(visitor, nodes) {\n  var result = [];\n  nodes.forEach(function (ast, i) {\n    var context = {\n      prev: nodes[i - 1],\n      next: nodes[i + 1]\n    };\n    var astResult = ast.visit(visitor, context);\n\n    if (astResult) {\n      result.push(astResult);\n    }\n  });\n  return result;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// http://cldr.unicode.org/index/cldr-spec/plural-rules\n\n\nvar PLURAL_CASES = ['zero', 'one', 'two', 'few', 'many', 'other'];\n/**\n * Expands special forms into elements.\n *\n * For example,\n *\n * ```\n * { messages.length, plural,\n *   =0 {zero}\n *   =1 {one}\n *   other {more than one}\n * }\n * ```\n *\n * will be expanded into\n *\n * ```\n * <ng-container [ngPlural]=\"messages.length\">\n *   <ng-template ngPluralCase=\"=0\">zero</ng-template>\n *   <ng-template ngPluralCase=\"=1\">one</ng-template>\n *   <ng-template ngPluralCase=\"other\">more than one</ng-template>\n * </ng-container>\n * ```\n */\n\nfunction expandNodes(nodes) {\n  var expander = new _Expander();\n  return new ExpansionResult(visitAll$1(expander, nodes), expander.isExpanded, expander.errors);\n}\n\nvar ExpansionResult = function ExpansionResult(nodes, expanded, errors) {\n  _classCallCheck(this, ExpansionResult);\n\n  this.nodes = nodes;\n  this.expanded = expanded;\n  this.errors = errors;\n};\n\nvar ExpansionError = /*#__PURE__*/function (_ParseError3) {\n  _inherits(ExpansionError, _ParseError3);\n\n  var _super85 = _createSuper(ExpansionError);\n\n  function ExpansionError(span, errorMsg) {\n    _classCallCheck(this, ExpansionError);\n\n    return _super85.call(this, span, errorMsg);\n  }\n\n  return ExpansionError;\n}(ParseError);\n/**\n * Expand expansion forms (plural, select) to directives\n *\n * @internal\n */\n\n\nvar _Expander = /*#__PURE__*/function () {\n  function _Expander() {\n    _classCallCheck(this, _Expander);\n\n    this.isExpanded = false;\n    this.errors = [];\n  }\n\n  _createClass(_Expander, [{\n    key: \"visitElement\",\n    value: function visitElement(element, context) {\n      return new Element$1(element.name, element.attrs, visitAll$1(this, element.children), element.sourceSpan, element.startSourceSpan, element.endSourceSpan);\n    }\n  }, {\n    key: \"visitAttribute\",\n    value: function visitAttribute(attribute, context) {\n      return attribute;\n    }\n  }, {\n    key: \"visitText\",\n    value: function visitText(text, context) {\n      return text;\n    }\n  }, {\n    key: \"visitComment\",\n    value: function visitComment(comment, context) {\n      return comment;\n    }\n  }, {\n    key: \"visitExpansion\",\n    value: function visitExpansion(icu, context) {\n      this.isExpanded = true;\n      return icu.type == 'plural' ? _expandPluralForm(icu, this.errors) : _expandDefaultForm(icu, this.errors);\n    }\n  }, {\n    key: \"visitExpansionCase\",\n    value: function visitExpansionCase(icuCase, context) {\n      throw new Error('Should not be reached');\n    }\n  }]);\n\n  return _Expander;\n}(); // Plural forms are expanded to `NgPlural` and `NgPluralCase`s\n\n\nfunction _expandPluralForm(ast, errors) {\n  var children = ast.cases.map(function (c) {\n    if (PLURAL_CASES.indexOf(c.value) == -1 && !c.value.match(/^=\\d+$/)) {\n      errors.push(new ExpansionError(c.valueSourceSpan, \"Plural cases should be \\\"=<number>\\\" or one of \".concat(PLURAL_CASES.join(', '))));\n    }\n\n    var expansionResult = expandNodes(c.expression);\n    errors.push.apply(errors, _toConsumableArray(expansionResult.errors));\n    return new Element$1(\"ng-template\", [new Attribute('ngPluralCase', \"\".concat(c.value), c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);\n  });\n  var switchAttr = new Attribute('[ngPlural]', ast.switchValue, ast.switchValueSourceSpan);\n  return new Element$1('ng-container', [switchAttr], children, ast.sourceSpan, ast.sourceSpan, ast.sourceSpan);\n} // ICU messages (excluding plural form) are expanded to `NgSwitch`  and `NgSwitchCase`s\n\n\nfunction _expandDefaultForm(ast, errors) {\n  var children = ast.cases.map(function (c) {\n    var expansionResult = expandNodes(c.expression);\n    errors.push.apply(errors, _toConsumableArray(expansionResult.errors));\n\n    if (c.value === 'other') {\n      // other is the default case when no values match\n      return new Element$1(\"ng-template\", [new Attribute('ngSwitchDefault', '', c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);\n    }\n\n    return new Element$1(\"ng-template\", [new Attribute('ngSwitchCase', \"\".concat(c.value), c.valueSourceSpan)], expansionResult.nodes, c.sourceSpan, c.sourceSpan, c.sourceSpan);\n  });\n  var switchAttr = new Attribute('[ngSwitch]', ast.switchValue, ast.switchValueSourceSpan);\n  return new Element$1('ng-container', [switchAttr], children, ast.sourceSpan, ast.sourceSpan, ast.sourceSpan);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * A segment of text within the template.\n */\n\n\nvar TextAst = /*#__PURE__*/function () {\n  function TextAst(value, ngContentIndex, sourceSpan) {\n    _classCallCheck(this, TextAst);\n\n    this.value = value;\n    this.ngContentIndex = ngContentIndex;\n    this.sourceSpan = sourceSpan;\n  }\n\n  _createClass(TextAst, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      return visitor.visitText(this, context);\n    }\n  }]);\n\n  return TextAst;\n}();\n/**\n * A bound expression within the text of a template.\n */\n\n\nvar BoundTextAst = /*#__PURE__*/function () {\n  function BoundTextAst(value, ngContentIndex, sourceSpan) {\n    _classCallCheck(this, BoundTextAst);\n\n    this.value = value;\n    this.ngContentIndex = ngContentIndex;\n    this.sourceSpan = sourceSpan;\n  }\n\n  _createClass(BoundTextAst, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      return visitor.visitBoundText(this, context);\n    }\n  }]);\n\n  return BoundTextAst;\n}();\n/**\n * A plain attribute on an element.\n */\n\n\nvar AttrAst = /*#__PURE__*/function () {\n  function AttrAst(name, value, sourceSpan) {\n    _classCallCheck(this, AttrAst);\n\n    this.name = name;\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n  }\n\n  _createClass(AttrAst, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      return visitor.visitAttr(this, context);\n    }\n  }]);\n\n  return AttrAst;\n}();\n\nvar BoundPropertyMapping = (_BoundPropertyMapping = {}, _defineProperty(_BoundPropertyMapping, 4\n/* Animation */\n, 4), _defineProperty(_BoundPropertyMapping, 1\n/* Attribute */\n,\n/* Animation */\n1), _defineProperty(_BoundPropertyMapping, 2\n/* Class */\n,\n/* Attribute */\n2), _defineProperty(_BoundPropertyMapping, 0\n/* Property */\n,\n/* Class */\n0), _defineProperty(_BoundPropertyMapping, 3\n/* Style */\n,\n/* Property */\n3), _BoundPropertyMapping);\n/**\n * A binding for an element property (e.g. `[property]=\"expression\"`) or an animation trigger (e.g.\n * `[@trigger]=\"stateExp\"`)\n */\n\nvar BoundElementPropertyAst = /*#__PURE__*/function () {\n  function BoundElementPropertyAst(name, type, securityContext, value, unit, sourceSpan) {\n    _classCallCheck(this, BoundElementPropertyAst);\n\n    this.name = name;\n    this.type = type;\n    this.securityContext = securityContext;\n    this.value = value;\n    this.unit = unit;\n    this.sourceSpan = sourceSpan;\n    this.isAnimation = this.type === 4\n    /* Animation */\n    ;\n  }\n\n  _createClass(BoundElementPropertyAst, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      return visitor.visitElementProperty(this, context);\n    }\n  }], [{\n    key: \"fromBoundProperty\",\n    value: function fromBoundProperty(prop) {\n      var type = BoundPropertyMapping[prop.type];\n      return new BoundElementPropertyAst(prop.name, type, prop.securityContext, prop.value, prop.unit, prop.sourceSpan);\n    }\n  }]);\n\n  return BoundElementPropertyAst;\n}();\n/**\n * A binding for an element event (e.g. `(event)=\"handler()\"`) or an animation trigger event (e.g.\n * `(@trigger.phase)=\"callback($event)\"`).\n */\n\n\nvar BoundEventAst = /*#__PURE__*/function () {\n  function BoundEventAst(name, target, phase, handler, sourceSpan, handlerSpan) {\n    _classCallCheck(this, BoundEventAst);\n\n    this.name = name;\n    this.target = target;\n    this.phase = phase;\n    this.handler = handler;\n    this.sourceSpan = sourceSpan;\n    this.handlerSpan = handlerSpan;\n    this.fullName = BoundEventAst.calcFullName(this.name, this.target, this.phase);\n    this.isAnimation = !!this.phase;\n  }\n\n  _createClass(BoundEventAst, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      return visitor.visitEvent(this, context);\n    }\n  }], [{\n    key: \"calcFullName\",\n    value: function calcFullName(name, target, phase) {\n      if (target) {\n        return \"\".concat(target, \":\").concat(name);\n      }\n\n      if (phase) {\n        return \"@\".concat(name, \".\").concat(phase);\n      }\n\n      return name;\n    }\n  }, {\n    key: \"fromParsedEvent\",\n    value: function fromParsedEvent(event) {\n      var target = event.type === 0\n      /* Regular */\n      ? event.targetOrPhase : null;\n      var phase = event.type === 1\n      /* Animation */\n      ? event.targetOrPhase : null;\n      return new BoundEventAst(event.name, target, phase, event.handler, event.sourceSpan, event.handlerSpan);\n    }\n  }]);\n\n  return BoundEventAst;\n}();\n/**\n * A reference declaration on an element (e.g. `let someName=\"expression\"`).\n */\n\n\nvar ReferenceAst = /*#__PURE__*/function () {\n  function ReferenceAst(name, value, originalValue, sourceSpan) {\n    _classCallCheck(this, ReferenceAst);\n\n    this.name = name;\n    this.value = value;\n    this.originalValue = originalValue;\n    this.sourceSpan = sourceSpan;\n  }\n\n  _createClass(ReferenceAst, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      return visitor.visitReference(this, context);\n    }\n  }]);\n\n  return ReferenceAst;\n}();\n/**\n * A variable declaration on a <ng-template> (e.g. `var-someName=\"someLocalName\"`).\n */\n\n\nvar VariableAst = /*#__PURE__*/function () {\n  function VariableAst(name, value, sourceSpan, valueSpan) {\n    _classCallCheck(this, VariableAst);\n\n    this.name = name;\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n    this.valueSpan = valueSpan;\n  }\n\n  _createClass(VariableAst, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      return visitor.visitVariable(this, context);\n    }\n  }], [{\n    key: \"fromParsedVariable\",\n    value: function fromParsedVariable(v) {\n      return new VariableAst(v.name, v.value, v.sourceSpan, v.valueSpan);\n    }\n  }]);\n\n  return VariableAst;\n}();\n/**\n * An element declaration in a template.\n */\n\n\nvar ElementAst = /*#__PURE__*/function () {\n  function ElementAst(name, attrs, inputs, outputs, references, directives, providers, hasViewContainer, queryMatches, children, ngContentIndex, sourceSpan, endSourceSpan) {\n    _classCallCheck(this, ElementAst);\n\n    this.name = name;\n    this.attrs = attrs;\n    this.inputs = inputs;\n    this.outputs = outputs;\n    this.references = references;\n    this.directives = directives;\n    this.providers = providers;\n    this.hasViewContainer = hasViewContainer;\n    this.queryMatches = queryMatches;\n    this.children = children;\n    this.ngContentIndex = ngContentIndex;\n    this.sourceSpan = sourceSpan;\n    this.endSourceSpan = endSourceSpan;\n  }\n\n  _createClass(ElementAst, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      return visitor.visitElement(this, context);\n    }\n  }]);\n\n  return ElementAst;\n}();\n/**\n * A `<ng-template>` element included in an Angular template.\n */\n\n\nvar EmbeddedTemplateAst = /*#__PURE__*/function () {\n  function EmbeddedTemplateAst(attrs, outputs, references, variables, directives, providers, hasViewContainer, queryMatches, children, ngContentIndex, sourceSpan) {\n    _classCallCheck(this, EmbeddedTemplateAst);\n\n    this.attrs = attrs;\n    this.outputs = outputs;\n    this.references = references;\n    this.variables = variables;\n    this.directives = directives;\n    this.providers = providers;\n    this.hasViewContainer = hasViewContainer;\n    this.queryMatches = queryMatches;\n    this.children = children;\n    this.ngContentIndex = ngContentIndex;\n    this.sourceSpan = sourceSpan;\n  }\n\n  _createClass(EmbeddedTemplateAst, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      return visitor.visitEmbeddedTemplate(this, context);\n    }\n  }]);\n\n  return EmbeddedTemplateAst;\n}();\n/**\n * A directive property with a bound value (e.g. `*ngIf=\"condition\").\n */\n\n\nvar BoundDirectivePropertyAst = /*#__PURE__*/function () {\n  function BoundDirectivePropertyAst(directiveName, templateName, value, sourceSpan) {\n    _classCallCheck(this, BoundDirectivePropertyAst);\n\n    this.directiveName = directiveName;\n    this.templateName = templateName;\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n  }\n\n  _createClass(BoundDirectivePropertyAst, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      return visitor.visitDirectiveProperty(this, context);\n    }\n  }]);\n\n  return BoundDirectivePropertyAst;\n}();\n/**\n * A directive declared on an element.\n */\n\n\nvar DirectiveAst = /*#__PURE__*/function () {\n  function DirectiveAst(directive, inputs, hostProperties, hostEvents, contentQueryStartId, sourceSpan) {\n    _classCallCheck(this, DirectiveAst);\n\n    this.directive = directive;\n    this.inputs = inputs;\n    this.hostProperties = hostProperties;\n    this.hostEvents = hostEvents;\n    this.contentQueryStartId = contentQueryStartId;\n    this.sourceSpan = sourceSpan;\n  }\n\n  _createClass(DirectiveAst, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      return visitor.visitDirective(this, context);\n    }\n  }]);\n\n  return DirectiveAst;\n}();\n/**\n * A provider declared on an element\n */\n\n\nvar ProviderAst = /*#__PURE__*/function () {\n  function ProviderAst(token, multiProvider, eager, providers, providerType, lifecycleHooks, sourceSpan, isModule) {\n    _classCallCheck(this, ProviderAst);\n\n    this.token = token;\n    this.multiProvider = multiProvider;\n    this.eager = eager;\n    this.providers = providers;\n    this.providerType = providerType;\n    this.lifecycleHooks = lifecycleHooks;\n    this.sourceSpan = sourceSpan;\n    this.isModule = isModule;\n  }\n\n  _createClass(ProviderAst, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      // No visit method in the visitor for now...\n      return null;\n    }\n  }]);\n\n  return ProviderAst;\n}();\n\nvar ProviderAstType;\n\n(function (ProviderAstType) {\n  ProviderAstType[ProviderAstType[\"PublicService\"] = 0] = \"PublicService\";\n  ProviderAstType[ProviderAstType[\"PrivateService\"] = 1] = \"PrivateService\";\n  ProviderAstType[ProviderAstType[\"Component\"] = 2] = \"Component\";\n  ProviderAstType[ProviderAstType[\"Directive\"] = 3] = \"Directive\";\n  ProviderAstType[ProviderAstType[\"Builtin\"] = 4] = \"Builtin\";\n})(ProviderAstType || (ProviderAstType = {}));\n/**\n * Position where content is to be projected (instance of `<ng-content>` in a template).\n */\n\n\nvar NgContentAst = /*#__PURE__*/function () {\n  function NgContentAst(index, ngContentIndex, sourceSpan) {\n    _classCallCheck(this, NgContentAst);\n\n    this.index = index;\n    this.ngContentIndex = ngContentIndex;\n    this.sourceSpan = sourceSpan;\n  }\n\n  _createClass(NgContentAst, [{\n    key: \"visit\",\n    value: function visit(visitor, context) {\n      return visitor.visitNgContent(this, context);\n    }\n  }]);\n\n  return NgContentAst;\n}();\n/**\n * A visitor that accepts each node but doesn't do anything. It is intended to be used\n * as the base class for a visitor that is only interested in a subset of the node types.\n */\n\n\nvar NullTemplateVisitor = /*#__PURE__*/function () {\n  function NullTemplateVisitor() {\n    _classCallCheck(this, NullTemplateVisitor);\n  }\n\n  _createClass(NullTemplateVisitor, [{\n    key: \"visitNgContent\",\n    value: function visitNgContent(ast, context) {}\n  }, {\n    key: \"visitEmbeddedTemplate\",\n    value: function visitEmbeddedTemplate(ast, context) {}\n  }, {\n    key: \"visitElement\",\n    value: function visitElement(ast, context) {}\n  }, {\n    key: \"visitReference\",\n    value: function visitReference(ast, context) {}\n  }, {\n    key: \"visitVariable\",\n    value: function visitVariable(ast, context) {}\n  }, {\n    key: \"visitEvent\",\n    value: function visitEvent(ast, context) {}\n  }, {\n    key: \"visitElementProperty\",\n    value: function visitElementProperty(ast, context) {}\n  }, {\n    key: \"visitAttr\",\n    value: function visitAttr(ast, context) {}\n  }, {\n    key: \"visitBoundText\",\n    value: function visitBoundText(ast, context) {}\n  }, {\n    key: \"visitText\",\n    value: function visitText(ast, context) {}\n  }, {\n    key: \"visitDirective\",\n    value: function visitDirective(ast, context) {}\n  }, {\n    key: \"visitDirectiveProperty\",\n    value: function visitDirectiveProperty(ast, context) {}\n  }]);\n\n  return NullTemplateVisitor;\n}();\n/**\n * Base class that can be used to build a visitor that visits each node\n * in an template ast recursively.\n */\n\n\nvar RecursiveTemplateAstVisitor = /*#__PURE__*/function (_NullTemplateVisitor) {\n  _inherits(RecursiveTemplateAstVisitor, _NullTemplateVisitor);\n\n  var _super86 = _createSuper(RecursiveTemplateAstVisitor);\n\n  function RecursiveTemplateAstVisitor() {\n    _classCallCheck(this, RecursiveTemplateAstVisitor);\n\n    return _super86.call(this);\n  } // Nodes with children\n\n\n  _createClass(RecursiveTemplateAstVisitor, [{\n    key: \"visitEmbeddedTemplate\",\n    value: function visitEmbeddedTemplate(ast, context) {\n      return this.visitChildren(context, function (visit) {\n        visit(ast.attrs);\n        visit(ast.references);\n        visit(ast.variables);\n        visit(ast.directives);\n        visit(ast.providers);\n        visit(ast.children);\n      });\n    }\n  }, {\n    key: \"visitElement\",\n    value: function visitElement(ast, context) {\n      return this.visitChildren(context, function (visit) {\n        visit(ast.attrs);\n        visit(ast.inputs);\n        visit(ast.outputs);\n        visit(ast.references);\n        visit(ast.directives);\n        visit(ast.providers);\n        visit(ast.children);\n      });\n    }\n  }, {\n    key: \"visitDirective\",\n    value: function visitDirective(ast, context) {\n      return this.visitChildren(context, function (visit) {\n        visit(ast.inputs);\n        visit(ast.hostProperties);\n        visit(ast.hostEvents);\n      });\n    }\n  }, {\n    key: \"visitChildren\",\n    value: function visitChildren(context, cb) {\n      var results = [];\n      var t = this;\n\n      function visit(children) {\n        if (children && children.length) results.push(templateVisitAll(t, children, context));\n      }\n\n      cb(visit);\n      return Array.prototype.concat.apply([], results);\n    }\n  }]);\n\n  return RecursiveTemplateAstVisitor;\n}(NullTemplateVisitor);\n/**\n * Visit every node in a list of {@link TemplateAst}s with the given {@link TemplateAstVisitor}.\n */\n\n\nfunction templateVisitAll(visitor, asts) {\n  var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var result = [];\n  var visit = visitor.visit ? function (ast) {\n    return visitor.visit(ast, context) || ast.visit(visitor, context);\n  } : function (ast) {\n    return ast.visit(visitor, context);\n  };\n  asts.forEach(function (ast) {\n    var astResult = visit(ast);\n\n    if (astResult) {\n      result.push(astResult);\n    }\n  });\n  return result;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar ProviderError = /*#__PURE__*/function (_ParseError4) {\n  _inherits(ProviderError, _ParseError4);\n\n  var _super87 = _createSuper(ProviderError);\n\n  function ProviderError(message, span) {\n    _classCallCheck(this, ProviderError);\n\n    return _super87.call(this, span, message);\n  }\n\n  return ProviderError;\n}(ParseError);\n\nvar ProviderViewContext = function ProviderViewContext(reflector, component) {\n  var _this132 = this;\n\n  _classCallCheck(this, ProviderViewContext);\n\n  this.reflector = reflector;\n  this.component = component;\n  this.errors = [];\n  this.viewQueries = _getViewQueries(component);\n  this.viewProviders = new Map();\n  component.viewProviders.forEach(function (provider) {\n    if (_this132.viewProviders.get(tokenReference(provider.token)) == null) {\n      _this132.viewProviders.set(tokenReference(provider.token), true);\n    }\n  });\n};\n\nvar ProviderElementContext = /*#__PURE__*/function () {\n  function ProviderElementContext(viewContext, _parent, _isViewRoot, _directiveAsts, attrs, refs, isTemplate, contentQueryStartId, _sourceSpan) {\n    var _this133 = this;\n\n    _classCallCheck(this, ProviderElementContext);\n\n    this.viewContext = viewContext;\n    this._parent = _parent;\n    this._isViewRoot = _isViewRoot;\n    this._directiveAsts = _directiveAsts;\n    this._sourceSpan = _sourceSpan;\n    this._transformedProviders = new Map();\n    this._seenProviders = new Map();\n    this._queriedTokens = new Map();\n    this.transformedHasViewContainer = false;\n    this._attrs = {};\n    attrs.forEach(function (attrAst) {\n      return _this133._attrs[attrAst.name] = attrAst.value;\n    });\n\n    var directivesMeta = _directiveAsts.map(function (directiveAst) {\n      return directiveAst.directive;\n    });\n\n    this._allProviders = _resolveProvidersFromDirectives(directivesMeta, _sourceSpan, viewContext.errors);\n    this._contentQueries = _getContentQueries(contentQueryStartId, directivesMeta);\n    Array.from(this._allProviders.values()).forEach(function (provider) {\n      _this133._addQueryReadsTo(provider.token, provider.token, _this133._queriedTokens);\n    });\n\n    if (isTemplate) {\n      var templateRefId = createTokenForExternalReference(this.viewContext.reflector, Identifiers.TemplateRef);\n\n      this._addQueryReadsTo(templateRefId, templateRefId, this._queriedTokens);\n    }\n\n    refs.forEach(function (refAst) {\n      var defaultQueryValue = refAst.value || createTokenForExternalReference(_this133.viewContext.reflector, Identifiers.ElementRef);\n\n      _this133._addQueryReadsTo({\n        value: refAst.name\n      }, defaultQueryValue, _this133._queriedTokens);\n    });\n\n    if (this._queriedTokens.get(this.viewContext.reflector.resolveExternalReference(Identifiers.ViewContainerRef))) {\n      this.transformedHasViewContainer = true;\n    } // create the providers that we know are eager first\n\n\n    Array.from(this._allProviders.values()).forEach(function (provider) {\n      var eager = provider.eager || _this133._queriedTokens.get(tokenReference(provider.token));\n\n      if (eager) {\n        _this133._getOrCreateLocalProvider(provider.providerType, provider.token, true);\n      }\n    });\n  }\n\n  _createClass(ProviderElementContext, [{\n    key: \"afterElement\",\n    value: function afterElement() {\n      var _this134 = this;\n\n      // collect lazy providers\n      Array.from(this._allProviders.values()).forEach(function (provider) {\n        _this134._getOrCreateLocalProvider(provider.providerType, provider.token, false);\n      });\n    }\n  }, {\n    key: \"_addQueryReadsTo\",\n    value: function _addQueryReadsTo(token, defaultValue, queryReadTokens) {\n      this._getQueriesFor(token).forEach(function (query) {\n        var queryValue = query.meta.read || defaultValue;\n        var tokenRef = tokenReference(queryValue);\n        var queryMatches = queryReadTokens.get(tokenRef);\n\n        if (!queryMatches) {\n          queryMatches = [];\n          queryReadTokens.set(tokenRef, queryMatches);\n        }\n\n        queryMatches.push({\n          queryId: query.queryId,\n          value: queryValue\n        });\n      });\n    }\n  }, {\n    key: \"_getQueriesFor\",\n    value: function _getQueriesFor(token) {\n      var result = [];\n      var currentEl = this;\n      var distance = 0;\n      var queries;\n\n      while (currentEl !== null) {\n        queries = currentEl._contentQueries.get(tokenReference(token));\n\n        if (queries) {\n          result.push.apply(result, _toConsumableArray(queries.filter(function (query) {\n            return query.meta.descendants || distance <= 1;\n          })));\n        }\n\n        if (currentEl._directiveAsts.length > 0) {\n          distance++;\n        }\n\n        currentEl = currentEl._parent;\n      }\n\n      queries = this.viewContext.viewQueries.get(tokenReference(token));\n\n      if (queries) {\n        result.push.apply(result, _toConsumableArray(queries));\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_getOrCreateLocalProvider\",\n    value: function _getOrCreateLocalProvider(requestingProviderType, token, eager) {\n      var _this135 = this;\n\n      var resolvedProvider = this._allProviders.get(tokenReference(token));\n\n      if (!resolvedProvider || (requestingProviderType === ProviderAstType.Directive || requestingProviderType === ProviderAstType.PublicService) && resolvedProvider.providerType === ProviderAstType.PrivateService || (requestingProviderType === ProviderAstType.PrivateService || requestingProviderType === ProviderAstType.PublicService) && resolvedProvider.providerType === ProviderAstType.Builtin) {\n        return null;\n      }\n\n      var transformedProviderAst = this._transformedProviders.get(tokenReference(token));\n\n      if (transformedProviderAst) {\n        return transformedProviderAst;\n      }\n\n      if (this._seenProviders.get(tokenReference(token)) != null) {\n        this.viewContext.errors.push(new ProviderError(\"Cannot instantiate cyclic dependency! \".concat(tokenName(token)), this._sourceSpan));\n        return null;\n      }\n\n      this._seenProviders.set(tokenReference(token), true);\n\n      var transformedProviders = resolvedProvider.providers.map(function (provider) {\n        var transformedUseValue = provider.useValue;\n        var transformedUseExisting = provider.useExisting;\n        var transformedDeps = undefined;\n\n        if (provider.useExisting != null) {\n          var existingDiDep = _this135._getDependency(resolvedProvider.providerType, {\n            token: provider.useExisting\n          }, eager);\n\n          if (existingDiDep.token != null) {\n            transformedUseExisting = existingDiDep.token;\n          } else {\n            transformedUseExisting = null;\n            transformedUseValue = existingDiDep.value;\n          }\n        } else if (provider.useFactory) {\n          var deps = provider.deps || provider.useFactory.diDeps;\n          transformedDeps = deps.map(function (dep) {\n            return _this135._getDependency(resolvedProvider.providerType, dep, eager);\n          });\n        } else if (provider.useClass) {\n          var _deps = provider.deps || provider.useClass.diDeps;\n\n          transformedDeps = _deps.map(function (dep) {\n            return _this135._getDependency(resolvedProvider.providerType, dep, eager);\n          });\n        }\n\n        return _transformProvider(provider, {\n          useExisting: transformedUseExisting,\n          useValue: transformedUseValue,\n          deps: transformedDeps\n        });\n      });\n      transformedProviderAst = _transformProviderAst(resolvedProvider, {\n        eager: eager,\n        providers: transformedProviders\n      });\n\n      this._transformedProviders.set(tokenReference(token), transformedProviderAst);\n\n      return transformedProviderAst;\n    }\n  }, {\n    key: \"_getLocalDependency\",\n    value: function _getLocalDependency(requestingProviderType, dep) {\n      var eager = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      if (dep.isAttribute) {\n        var attrValue = this._attrs[dep.token.value];\n        return {\n          isValue: true,\n          value: attrValue == null ? null : attrValue\n        };\n      }\n\n      if (dep.token != null) {\n        // access builtints\n        if (requestingProviderType === ProviderAstType.Directive || requestingProviderType === ProviderAstType.Component) {\n          if (tokenReference(dep.token) === this.viewContext.reflector.resolveExternalReference(Identifiers.Renderer) || tokenReference(dep.token) === this.viewContext.reflector.resolveExternalReference(Identifiers.ElementRef) || tokenReference(dep.token) === this.viewContext.reflector.resolveExternalReference(Identifiers.ChangeDetectorRef) || tokenReference(dep.token) === this.viewContext.reflector.resolveExternalReference(Identifiers.TemplateRef)) {\n            return dep;\n          }\n\n          if (tokenReference(dep.token) === this.viewContext.reflector.resolveExternalReference(Identifiers.ViewContainerRef)) {\n            this.transformedHasViewContainer = true;\n          }\n        } // access the injector\n\n\n        if (tokenReference(dep.token) === this.viewContext.reflector.resolveExternalReference(Identifiers.Injector)) {\n          return dep;\n        } // access providers\n\n\n        if (this._getOrCreateLocalProvider(requestingProviderType, dep.token, eager) != null) {\n          return dep;\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_getDependency\",\n    value: function _getDependency(requestingProviderType, dep) {\n      var eager = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var currElement = this;\n      var currEager = eager;\n      var result = null;\n\n      if (!dep.isSkipSelf) {\n        result = this._getLocalDependency(requestingProviderType, dep, eager);\n      }\n\n      if (dep.isSelf) {\n        if (!result && dep.isOptional) {\n          result = {\n            isValue: true,\n            value: null\n          };\n        }\n      } else {\n        // check parent elements\n        while (!result && currElement._parent) {\n          var prevElement = currElement;\n          currElement = currElement._parent;\n\n          if (prevElement._isViewRoot) {\n            currEager = false;\n          }\n\n          result = currElement._getLocalDependency(ProviderAstType.PublicService, dep, currEager);\n        } // check @Host restriction\n\n\n        if (!result) {\n          if (!dep.isHost || this.viewContext.component.isHost || this.viewContext.component.type.reference === tokenReference(dep.token) || this.viewContext.viewProviders.get(tokenReference(dep.token)) != null) {\n            result = dep;\n          } else {\n            result = dep.isOptional ? {\n              isValue: true,\n              value: null\n            } : null;\n          }\n        }\n      }\n\n      if (!result) {\n        this.viewContext.errors.push(new ProviderError(\"No provider for \".concat(tokenName(dep.token)), this._sourceSpan));\n      }\n\n      return result;\n    }\n  }, {\n    key: \"transformProviders\",\n    get: function get() {\n      // Note: Maps keep their insertion order.\n      var lazyProviders = [];\n      var eagerProviders = [];\n\n      this._transformedProviders.forEach(function (provider) {\n        if (provider.eager) {\n          eagerProviders.push(provider);\n        } else {\n          lazyProviders.push(provider);\n        }\n      });\n\n      return lazyProviders.concat(eagerProviders);\n    }\n  }, {\n    key: \"transformedDirectiveAsts\",\n    get: function get() {\n      var sortedProviderTypes = this.transformProviders.map(function (provider) {\n        return provider.token.identifier;\n      });\n\n      var sortedDirectives = this._directiveAsts.slice();\n\n      sortedDirectives.sort(function (dir1, dir2) {\n        return sortedProviderTypes.indexOf(dir1.directive.type) - sortedProviderTypes.indexOf(dir2.directive.type);\n      });\n      return sortedDirectives;\n    }\n  }, {\n    key: \"queryMatches\",\n    get: function get() {\n      var allMatches = [];\n\n      this._queriedTokens.forEach(function (matches) {\n        allMatches.push.apply(allMatches, _toConsumableArray(matches));\n      });\n\n      return allMatches;\n    }\n  }]);\n\n  return ProviderElementContext;\n}();\n\nvar NgModuleProviderAnalyzer = /*#__PURE__*/function () {\n  function NgModuleProviderAnalyzer(reflector, ngModule, extraProviders, sourceSpan) {\n    var _this136 = this;\n\n    _classCallCheck(this, NgModuleProviderAnalyzer);\n\n    this.reflector = reflector;\n    this._transformedProviders = new Map();\n    this._seenProviders = new Map();\n    this._errors = [];\n    this._allProviders = new Map();\n    ngModule.transitiveModule.modules.forEach(function (ngModuleType) {\n      var ngModuleProvider = {\n        token: {\n          identifier: ngModuleType\n        },\n        useClass: ngModuleType\n      };\n\n      _resolveProviders([ngModuleProvider], ProviderAstType.PublicService, true, sourceSpan, _this136._errors, _this136._allProviders,\n      /* isModule */\n      true);\n    });\n\n    _resolveProviders(ngModule.transitiveModule.providers.map(function (entry) {\n      return entry.provider;\n    }).concat(extraProviders), ProviderAstType.PublicService, false, sourceSpan, this._errors, this._allProviders,\n    /* isModule */\n    false);\n  }\n\n  _createClass(NgModuleProviderAnalyzer, [{\n    key: \"parse\",\n    value: function parse() {\n      var _this137 = this;\n\n      Array.from(this._allProviders.values()).forEach(function (provider) {\n        _this137._getOrCreateLocalProvider(provider.token, provider.eager);\n      });\n\n      if (this._errors.length > 0) {\n        var errorString = this._errors.join('\\n');\n\n        throw new Error(\"Provider parse errors:\\n\".concat(errorString));\n      } // Note: Maps keep their insertion order.\n\n\n      var lazyProviders = [];\n      var eagerProviders = [];\n\n      this._transformedProviders.forEach(function (provider) {\n        if (provider.eager) {\n          eagerProviders.push(provider);\n        } else {\n          lazyProviders.push(provider);\n        }\n      });\n\n      return lazyProviders.concat(eagerProviders);\n    }\n  }, {\n    key: \"_getOrCreateLocalProvider\",\n    value: function _getOrCreateLocalProvider(token, eager) {\n      var _this138 = this;\n\n      var resolvedProvider = this._allProviders.get(tokenReference(token));\n\n      if (!resolvedProvider) {\n        return null;\n      }\n\n      var transformedProviderAst = this._transformedProviders.get(tokenReference(token));\n\n      if (transformedProviderAst) {\n        return transformedProviderAst;\n      }\n\n      if (this._seenProviders.get(tokenReference(token)) != null) {\n        this._errors.push(new ProviderError(\"Cannot instantiate cyclic dependency! \".concat(tokenName(token)), resolvedProvider.sourceSpan));\n\n        return null;\n      }\n\n      this._seenProviders.set(tokenReference(token), true);\n\n      var transformedProviders = resolvedProvider.providers.map(function (provider) {\n        var transformedUseValue = provider.useValue;\n        var transformedUseExisting = provider.useExisting;\n        var transformedDeps = undefined;\n\n        if (provider.useExisting != null) {\n          var existingDiDep = _this138._getDependency({\n            token: provider.useExisting\n          }, eager, resolvedProvider.sourceSpan);\n\n          if (existingDiDep.token != null) {\n            transformedUseExisting = existingDiDep.token;\n          } else {\n            transformedUseExisting = null;\n            transformedUseValue = existingDiDep.value;\n          }\n        } else if (provider.useFactory) {\n          var deps = provider.deps || provider.useFactory.diDeps;\n          transformedDeps = deps.map(function (dep) {\n            return _this138._getDependency(dep, eager, resolvedProvider.sourceSpan);\n          });\n        } else if (provider.useClass) {\n          var _deps2 = provider.deps || provider.useClass.diDeps;\n\n          transformedDeps = _deps2.map(function (dep) {\n            return _this138._getDependency(dep, eager, resolvedProvider.sourceSpan);\n          });\n        }\n\n        return _transformProvider(provider, {\n          useExisting: transformedUseExisting,\n          useValue: transformedUseValue,\n          deps: transformedDeps\n        });\n      });\n      transformedProviderAst = _transformProviderAst(resolvedProvider, {\n        eager: eager,\n        providers: transformedProviders\n      });\n\n      this._transformedProviders.set(tokenReference(token), transformedProviderAst);\n\n      return transformedProviderAst;\n    }\n  }, {\n    key: \"_getDependency\",\n    value: function _getDependency(dep) {\n      var eager = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var requestorSourceSpan = arguments.length > 2 ? arguments[2] : undefined;\n      var foundLocal = false;\n\n      if (!dep.isSkipSelf && dep.token != null) {\n        // access the injector\n        if (tokenReference(dep.token) === this.reflector.resolveExternalReference(Identifiers.Injector) || tokenReference(dep.token) === this.reflector.resolveExternalReference(Identifiers.ComponentFactoryResolver)) {\n          foundLocal = true; // access providers\n        } else if (this._getOrCreateLocalProvider(dep.token, eager) != null) {\n          foundLocal = true;\n        }\n      }\n\n      return dep;\n    }\n  }]);\n\n  return NgModuleProviderAnalyzer;\n}();\n\nfunction _transformProvider(provider, _ref11) {\n  var useExisting = _ref11.useExisting,\n      useValue = _ref11.useValue,\n      deps = _ref11.deps;\n  return {\n    token: provider.token,\n    useClass: provider.useClass,\n    useExisting: useExisting,\n    useFactory: provider.useFactory,\n    useValue: useValue,\n    deps: deps,\n    multi: provider.multi\n  };\n}\n\nfunction _transformProviderAst(provider, _ref12) {\n  var eager = _ref12.eager,\n      providers = _ref12.providers;\n  return new ProviderAst(provider.token, provider.multiProvider, provider.eager || eager, providers, provider.providerType, provider.lifecycleHooks, provider.sourceSpan, provider.isModule);\n}\n\nfunction _resolveProvidersFromDirectives(directives, sourceSpan, targetErrors) {\n  var providersByToken = new Map();\n  directives.forEach(function (directive) {\n    var dirProvider = {\n      token: {\n        identifier: directive.type\n      },\n      useClass: directive.type\n    };\n\n    _resolveProviders([dirProvider], directive.isComponent ? ProviderAstType.Component : ProviderAstType.Directive, true, sourceSpan, targetErrors, providersByToken,\n    /* isModule */\n    false);\n  }); // Note: directives need to be able to overwrite providers of a component!\n\n  var directivesWithComponentFirst = directives.filter(function (dir) {\n    return dir.isComponent;\n  }).concat(directives.filter(function (dir) {\n    return !dir.isComponent;\n  }));\n  directivesWithComponentFirst.forEach(function (directive) {\n    _resolveProviders(directive.providers, ProviderAstType.PublicService, false, sourceSpan, targetErrors, providersByToken,\n    /* isModule */\n    false);\n\n    _resolveProviders(directive.viewProviders, ProviderAstType.PrivateService, false, sourceSpan, targetErrors, providersByToken,\n    /* isModule */\n    false);\n  });\n  return providersByToken;\n}\n\nfunction _resolveProviders(providers, providerType, eager, sourceSpan, targetErrors, targetProvidersByToken, isModule) {\n  providers.forEach(function (provider) {\n    var resolvedProvider = targetProvidersByToken.get(tokenReference(provider.token));\n\n    if (resolvedProvider != null && !!resolvedProvider.multiProvider !== !!provider.multi) {\n      targetErrors.push(new ProviderError(\"Mixing multi and non multi provider is not possible for token \".concat(tokenName(resolvedProvider.token)), sourceSpan));\n    }\n\n    if (!resolvedProvider) {\n      var lifecycleHooks = provider.token.identifier && provider.token.identifier.lifecycleHooks ? provider.token.identifier.lifecycleHooks : [];\n      var isUseValue = !(provider.useClass || provider.useExisting || provider.useFactory);\n      resolvedProvider = new ProviderAst(provider.token, !!provider.multi, eager || isUseValue, [provider], providerType, lifecycleHooks, sourceSpan, isModule);\n      targetProvidersByToken.set(tokenReference(provider.token), resolvedProvider);\n    } else {\n      if (!provider.multi) {\n        resolvedProvider.providers.length = 0;\n      }\n\n      resolvedProvider.providers.push(provider);\n    }\n  });\n}\n\nfunction _getViewQueries(component) {\n  // Note: queries start with id 1 so we can use the number in a Bloom filter!\n  var viewQueryId = 1;\n  var viewQueries = new Map();\n\n  if (component.viewQueries) {\n    component.viewQueries.forEach(function (query) {\n      return _addQueryToTokenMap(viewQueries, {\n        meta: query,\n        queryId: viewQueryId++\n      });\n    });\n  }\n\n  return viewQueries;\n}\n\nfunction _getContentQueries(contentQueryStartId, directives) {\n  var contentQueryId = contentQueryStartId;\n  var contentQueries = new Map();\n  directives.forEach(function (directive, directiveIndex) {\n    if (directive.queries) {\n      directive.queries.forEach(function (query) {\n        return _addQueryToTokenMap(contentQueries, {\n          meta: query,\n          queryId: contentQueryId++\n        });\n      });\n    }\n  });\n  return contentQueries;\n}\n\nfunction _addQueryToTokenMap(map, query) {\n  query.meta.selectors.forEach(function (token) {\n    var entry = map.get(tokenReference(token));\n\n    if (!entry) {\n      entry = [];\n      map.set(tokenReference(token), entry);\n    }\n\n    entry.push(query);\n  });\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar StyleWithImports = function StyleWithImports(style, styleUrls) {\n  _classCallCheck(this, StyleWithImports);\n\n  this.style = style;\n  this.styleUrls = styleUrls;\n};\n\nfunction isStyleUrlResolvable(url) {\n  if (url == null || url.length === 0 || url[0] == '/') return false;\n  var schemeMatch = url.match(URL_WITH_SCHEMA_REGEXP);\n  return schemeMatch === null || schemeMatch[1] == 'package' || schemeMatch[1] == 'asset';\n}\n/**\n * Rewrites stylesheets by resolving and removing the @import urls that\n * are either relative or don't have a `package:` scheme\n */\n\n\nfunction extractStyleUrls(resolver, baseUrl, cssText) {\n  var foundUrls = [];\n  var modifiedCssText = cssText.replace(CSS_STRIPPABLE_COMMENT_REGEXP, '').replace(CSS_IMPORT_REGEXP, function () {\n    var url = (arguments.length <= 1 ? undefined : arguments[1]) || (arguments.length <= 2 ? undefined : arguments[2]);\n\n    if (!isStyleUrlResolvable(url)) {\n      // Do not attempt to resolve non-package absolute URLs with URI\n      // scheme\n      return arguments.length <= 0 ? undefined : arguments[0];\n    }\n\n    foundUrls.push(resolver.resolve(baseUrl, url));\n    return '';\n  });\n  return new StyleWithImports(modifiedCssText, foundUrls);\n}\n\nvar CSS_IMPORT_REGEXP = /@import\\s+(?:url\\()?\\s*(?:(?:['\"]([^'\"]*))|([^;\\)\\s]*))[^;]*;?/g;\nvar CSS_STRIPPABLE_COMMENT_REGEXP = /\\/\\*(?!#\\s*(?:sourceURL|sourceMappingURL)=)[\\s\\S]+?\\*\\//g;\nvar URL_WITH_SCHEMA_REGEXP = /^([^:/?#]+):/;\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nvar PROPERTY_PARTS_SEPARATOR = '.';\nvar ATTRIBUTE_PREFIX = 'attr';\nvar CLASS_PREFIX = 'class';\nvar STYLE_PREFIX = 'style';\nvar TEMPLATE_ATTR_PREFIX = '*';\nvar ANIMATE_PROP_PREFIX = 'animate-';\n/**\n * Parses bindings in templates and in the directive host area.\n */\n\nvar BindingParser = /*#__PURE__*/function () {\n  function BindingParser(_exprParser, _interpolationConfig, _schemaRegistry, pipes, errors) {\n    _classCallCheck(this, BindingParser);\n\n    this._exprParser = _exprParser;\n    this._interpolationConfig = _interpolationConfig;\n    this._schemaRegistry = _schemaRegistry;\n    this.errors = errors;\n    this.pipesByName = null;\n    this._usedPipes = new Map(); // When the `pipes` parameter is `null`, do not check for used pipes\n    // This is used in IVY when we might not know the available pipes at compile time\n\n    if (pipes) {\n      var pipesByName = new Map();\n      pipes.forEach(function (pipe) {\n        return pipesByName.set(pipe.name, pipe);\n      });\n      this.pipesByName = pipesByName;\n    }\n  }\n\n  _createClass(BindingParser, [{\n    key: \"getUsedPipes\",\n    value: function getUsedPipes() {\n      return Array.from(this._usedPipes.values());\n    }\n  }, {\n    key: \"createBoundHostProperties\",\n    value: function createBoundHostProperties(dirMeta, sourceSpan) {\n      var _this139 = this;\n\n      if (dirMeta.hostProperties) {\n        var boundProps = [];\n        Object.keys(dirMeta.hostProperties).forEach(function (propName) {\n          var expression = dirMeta.hostProperties[propName];\n\n          if (typeof expression === 'string') {\n            _this139.parsePropertyBinding(propName, expression, true, sourceSpan, sourceSpan.start.offset, undefined, [], boundProps);\n          } else {\n            _this139._reportError(\"Value of the host property binding \\\"\".concat(propName, \"\\\" needs to be a string representing an expression but got \\\"\").concat(expression, \"\\\" (\").concat(typeof expression, \")\"), sourceSpan);\n          }\n        });\n        return boundProps;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"createDirectiveHostPropertyAsts\",\n    value: function createDirectiveHostPropertyAsts(dirMeta, elementSelector, sourceSpan) {\n      var _this140 = this;\n\n      var boundProps = this.createBoundHostProperties(dirMeta, sourceSpan);\n      return boundProps && boundProps.map(function (prop) {\n        return _this140.createBoundElementProperty(elementSelector, prop);\n      });\n    }\n  }, {\n    key: \"createDirectiveHostEventAsts\",\n    value: function createDirectiveHostEventAsts(dirMeta, sourceSpan) {\n      var _this141 = this;\n\n      if (dirMeta.hostListeners) {\n        var targetEvents = [];\n        Object.keys(dirMeta.hostListeners).forEach(function (propName) {\n          var expression = dirMeta.hostListeners[propName];\n\n          if (typeof expression === 'string') {\n            // TODO: pass a more accurate handlerSpan for this event.\n            _this141.parseEvent(propName, expression, sourceSpan, sourceSpan, [], targetEvents);\n          } else {\n            _this141._reportError(\"Value of the host listener \\\"\".concat(propName, \"\\\" needs to be a string representing an expression but got \\\"\").concat(expression, \"\\\" (\").concat(typeof expression, \")\"), sourceSpan);\n          }\n        });\n        return targetEvents;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"parseInterpolation\",\n    value: function parseInterpolation(value, sourceSpan) {\n      var sourceInfo = sourceSpan.start.toString();\n\n      try {\n        var ast = this._exprParser.parseInterpolation(value, sourceInfo, sourceSpan.start.offset, this._interpolationConfig);\n\n        if (ast) this._reportExpressionParserErrors(ast.errors, sourceSpan);\n\n        this._checkPipes(ast, sourceSpan);\n\n        return ast;\n      } catch (e) {\n        this._reportError(\"\".concat(e), sourceSpan);\n\n        return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, sourceSpan.start.offset);\n      }\n    }\n    /**\n     * Parses the bindings in a microsyntax expression, and converts them to\n     * `ParsedProperty` or `ParsedVariable`.\n     *\n     * @param tplKey template binding name\n     * @param tplValue template binding value\n     * @param sourceSpan span of template binding relative to entire the template\n     * @param absoluteValueOffset start of the tplValue relative to the entire template\n     * @param targetMatchableAttrs potential attributes to match in the template\n     * @param targetProps target property bindings in the template\n     * @param targetVars target variables in the template\n     */\n\n  }, {\n    key: \"parseInlineTemplateBinding\",\n    value: function parseInlineTemplateBinding(tplKey, tplValue, sourceSpan, absoluteValueOffset, targetMatchableAttrs, targetProps, targetVars) {\n      var absoluteKeyOffset = sourceSpan.start.offset + TEMPLATE_ATTR_PREFIX.length;\n\n      var bindings = this._parseTemplateBindings(tplKey, tplValue, sourceSpan, absoluteKeyOffset, absoluteValueOffset);\n\n      var _iterator7 = _createForOfIteratorHelper(bindings),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var binding = _step7.value;\n          // sourceSpan is for the entire HTML attribute. bindingSpan is for a particular\n          // binding within the microsyntax expression so it's more narrow than sourceSpan.\n          var bindingSpan = moveParseSourceSpan(sourceSpan, binding.sourceSpan);\n          var key = binding.key.source;\n          var keySpan = moveParseSourceSpan(sourceSpan, binding.key.span);\n\n          if (binding instanceof VariableBinding) {\n            var value = binding.value ? binding.value.source : '$implicit';\n            var valueSpan = binding.value ? moveParseSourceSpan(sourceSpan, binding.value.span) : undefined;\n            targetVars.push(new ParsedVariable(key, value, bindingSpan, keySpan, valueSpan));\n          } else if (binding.value) {\n            var _valueSpan = moveParseSourceSpan(sourceSpan, binding.value.ast.sourceSpan);\n\n            this._parsePropertyAst(key, binding.value, sourceSpan, _valueSpan, targetMatchableAttrs, targetProps);\n          } else {\n            targetMatchableAttrs.push([key, '']);\n            this.parseLiteralAttr(key, null, sourceSpan, absoluteValueOffset, undefined, targetMatchableAttrs, targetProps);\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n    }\n    /**\n     * Parses the bindings in a microsyntax expression, e.g.\n     * ```\n     *    <tag *tplKey=\"let value1 = prop; let value2 = localVar\">\n     * ```\n     *\n     * @param tplKey template binding name\n     * @param tplValue template binding value\n     * @param sourceSpan span of template binding relative to entire the template\n     * @param absoluteKeyOffset start of the `tplKey`\n     * @param absoluteValueOffset start of the `tplValue`\n     */\n\n  }, {\n    key: \"_parseTemplateBindings\",\n    value: function _parseTemplateBindings(tplKey, tplValue, sourceSpan, absoluteKeyOffset, absoluteValueOffset) {\n      var _this142 = this;\n\n      var sourceInfo = sourceSpan.start.toString();\n\n      try {\n        var bindingsResult = this._exprParser.parseTemplateBindings(tplKey, tplValue, sourceInfo, absoluteKeyOffset, absoluteValueOffset);\n\n        this._reportExpressionParserErrors(bindingsResult.errors, sourceSpan);\n\n        bindingsResult.templateBindings.forEach(function (binding) {\n          if (binding.value instanceof ASTWithSource) {\n            _this142._checkPipes(binding.value, sourceSpan);\n          }\n        });\n        bindingsResult.warnings.forEach(function (warning) {\n          _this142._reportError(warning, sourceSpan, ParseErrorLevel.WARNING);\n        });\n        return bindingsResult.templateBindings;\n      } catch (e) {\n        this._reportError(\"\".concat(e), sourceSpan);\n\n        return [];\n      }\n    }\n  }, {\n    key: \"parseLiteralAttr\",\n    value: function parseLiteralAttr(name, value, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, targetProps) {\n      if (isAnimationLabel(name)) {\n        name = name.substring(1);\n\n        if (value) {\n          this._reportError(\"Assigning animation triggers via @prop=\\\"exp\\\" attributes with an expression is invalid.\" + \" Use property bindings (e.g. [@prop]=\\\"exp\\\") or use an attribute without a value (e.g. @prop) instead.\", sourceSpan, ParseErrorLevel.ERROR);\n        }\n\n        this._parseAnimation(name, value, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, targetProps);\n      } else {\n        targetProps.push(new ParsedProperty(name, this._exprParser.wrapLiteralPrimitive(value, '', absoluteOffset), ParsedPropertyType.LITERAL_ATTR, sourceSpan, valueSpan));\n      }\n    }\n  }, {\n    key: \"parsePropertyBinding\",\n    value: function parsePropertyBinding(name, expression, isHost, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, targetProps) {\n      if (name.length === 0) {\n        this._reportError(\"Property name is missing in binding\", sourceSpan);\n      }\n\n      var isAnimationProp = false;\n\n      if (name.startsWith(ANIMATE_PROP_PREFIX)) {\n        isAnimationProp = true;\n        name = name.substring(ANIMATE_PROP_PREFIX.length);\n      } else if (isAnimationLabel(name)) {\n        isAnimationProp = true;\n        name = name.substring(1);\n      }\n\n      if (isAnimationProp) {\n        this._parseAnimation(name, expression, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, targetProps);\n      } else {\n        this._parsePropertyAst(name, this._parseBinding(expression, isHost, valueSpan || sourceSpan, absoluteOffset), sourceSpan, valueSpan, targetMatchableAttrs, targetProps);\n      }\n    }\n  }, {\n    key: \"parsePropertyInterpolation\",\n    value: function parsePropertyInterpolation(name, value, sourceSpan, valueSpan, targetMatchableAttrs, targetProps) {\n      var expr = this.parseInterpolation(value, valueSpan || sourceSpan);\n\n      if (expr) {\n        this._parsePropertyAst(name, expr, sourceSpan, valueSpan, targetMatchableAttrs, targetProps);\n\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_parsePropertyAst\",\n    value: function _parsePropertyAst(name, ast, sourceSpan, valueSpan, targetMatchableAttrs, targetProps) {\n      targetMatchableAttrs.push([name, ast.source]);\n      targetProps.push(new ParsedProperty(name, ast, ParsedPropertyType.DEFAULT, sourceSpan, valueSpan));\n    }\n  }, {\n    key: \"_parseAnimation\",\n    value: function _parseAnimation(name, expression, sourceSpan, absoluteOffset, valueSpan, targetMatchableAttrs, targetProps) {\n      if (name.length === 0) {\n        this._reportError('Animation trigger is missing', sourceSpan);\n      } // This will occur when a @trigger is not paired with an expression.\n      // For animations it is valid to not have an expression since */void\n      // states will be applied by angular when the element is attached/detached\n\n\n      var ast = this._parseBinding(expression || 'undefined', false, valueSpan || sourceSpan, absoluteOffset);\n\n      targetMatchableAttrs.push([name, ast.source]);\n      targetProps.push(new ParsedProperty(name, ast, ParsedPropertyType.ANIMATION, sourceSpan, valueSpan));\n    }\n  }, {\n    key: \"_parseBinding\",\n    value: function _parseBinding(value, isHostBinding, sourceSpan, absoluteOffset) {\n      var sourceInfo = (sourceSpan && sourceSpan.start || '(unknown)').toString();\n\n      try {\n        var ast = isHostBinding ? this._exprParser.parseSimpleBinding(value, sourceInfo, absoluteOffset, this._interpolationConfig) : this._exprParser.parseBinding(value, sourceInfo, absoluteOffset, this._interpolationConfig);\n        if (ast) this._reportExpressionParserErrors(ast.errors, sourceSpan);\n\n        this._checkPipes(ast, sourceSpan);\n\n        return ast;\n      } catch (e) {\n        this._reportError(\"\".concat(e), sourceSpan);\n\n        return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n      }\n    }\n  }, {\n    key: \"createBoundElementProperty\",\n    value: function createBoundElementProperty(elementSelector, boundProp) {\n      var skipValidation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var mapPropertyName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n      if (boundProp.isAnimation) {\n        return new BoundElementProperty(boundProp.name, 4\n        /* Animation */\n        , SecurityContext.NONE, boundProp.expression, null, boundProp.sourceSpan, boundProp.valueSpan);\n      }\n\n      var unit = null;\n      var bindingType = undefined;\n      var boundPropertyName = null;\n      var parts = boundProp.name.split(PROPERTY_PARTS_SEPARATOR);\n      var securityContexts = undefined; // Check for special cases (prefix style, attr, class)\n\n      if (parts.length > 1) {\n        if (parts[0] == ATTRIBUTE_PREFIX) {\n          boundPropertyName = parts.slice(1).join(PROPERTY_PARTS_SEPARATOR);\n\n          if (!skipValidation) {\n            this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, true);\n          }\n\n          securityContexts = _calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, boundPropertyName, true);\n          var nsSeparatorIdx = boundPropertyName.indexOf(':');\n\n          if (nsSeparatorIdx > -1) {\n            var ns = boundPropertyName.substring(0, nsSeparatorIdx);\n            var name = boundPropertyName.substring(nsSeparatorIdx + 1);\n            boundPropertyName = mergeNsAndName(ns, name);\n          }\n\n          bindingType = 1\n          /* Attribute */\n          ;\n        } else if (parts[0] == CLASS_PREFIX) {\n          boundPropertyName = parts[1];\n          bindingType = 2\n          /* Class */\n          ;\n          securityContexts = [SecurityContext.NONE];\n        } else if (parts[0] == STYLE_PREFIX) {\n          unit = parts.length > 2 ? parts[2] : null;\n          boundPropertyName = parts[1];\n          bindingType = 3\n          /* Style */\n          ;\n          securityContexts = [SecurityContext.STYLE];\n        }\n      } // If not a special case, use the full property name\n\n\n      if (boundPropertyName === null) {\n        var mappedPropName = this._schemaRegistry.getMappedPropName(boundProp.name);\n\n        boundPropertyName = mapPropertyName ? mappedPropName : boundProp.name;\n        securityContexts = _calcPossibleSecurityContexts(this._schemaRegistry, elementSelector, mappedPropName, false);\n        bindingType = 0\n        /* Property */\n        ;\n\n        if (!skipValidation) {\n          this._validatePropertyOrAttributeName(mappedPropName, boundProp.sourceSpan, false);\n        }\n      }\n\n      return new BoundElementProperty(boundPropertyName, bindingType, securityContexts[0], boundProp.expression, unit, boundProp.sourceSpan, boundProp.valueSpan);\n    }\n  }, {\n    key: \"parseEvent\",\n    value: function parseEvent(name, expression, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents) {\n      if (name.length === 0) {\n        this._reportError(\"Event name is missing in binding\", sourceSpan);\n      }\n\n      if (isAnimationLabel(name)) {\n        name = name.substr(1);\n\n        this._parseAnimationEvent(name, expression, sourceSpan, handlerSpan, targetEvents);\n      } else {\n        this._parseRegularEvent(name, expression, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents);\n      }\n    }\n  }, {\n    key: \"calcPossibleSecurityContexts\",\n    value: function calcPossibleSecurityContexts(selector, propName, isAttribute) {\n      var prop = this._schemaRegistry.getMappedPropName(propName);\n\n      return _calcPossibleSecurityContexts(this._schemaRegistry, selector, prop, isAttribute);\n    }\n  }, {\n    key: \"_parseAnimationEvent\",\n    value: function _parseAnimationEvent(name, expression, sourceSpan, handlerSpan, targetEvents) {\n      var matches = splitAtPeriod(name, [name, '']);\n      var eventName = matches[0];\n      var phase = matches[1].toLowerCase();\n\n      if (phase) {\n        switch (phase) {\n          case 'start':\n          case 'done':\n            var ast = this._parseAction(expression, handlerSpan);\n\n            targetEvents.push(new ParsedEvent(eventName, phase, 1\n            /* Animation */\n            , ast, sourceSpan, handlerSpan));\n            break;\n\n          default:\n            this._reportError(\"The provided animation output phase value \\\"\".concat(phase, \"\\\" for \\\"@\").concat(eventName, \"\\\" is not supported (use start or done)\"), sourceSpan);\n\n            break;\n        }\n      } else {\n        this._reportError(\"The animation trigger output event (@\".concat(eventName, \") is missing its phase value name (start or done are currently supported)\"), sourceSpan);\n      }\n    }\n  }, {\n    key: \"_parseRegularEvent\",\n    value: function _parseRegularEvent(name, expression, sourceSpan, handlerSpan, targetMatchableAttrs, targetEvents) {\n      // long format: 'target: eventName'\n      var _splitAtColon3 = splitAtColon(name, [null, name]),\n          _splitAtColon4 = _slicedToArray(_splitAtColon3, 2),\n          target = _splitAtColon4[0],\n          eventName = _splitAtColon4[1];\n\n      var ast = this._parseAction(expression, handlerSpan);\n\n      targetMatchableAttrs.push([name, ast.source]);\n      targetEvents.push(new ParsedEvent(eventName, target, 0\n      /* Regular */\n      , ast, sourceSpan, handlerSpan)); // Don't detect directives for event names for now,\n      // so don't add the event name to the matchableAttrs\n    }\n  }, {\n    key: \"_parseAction\",\n    value: function _parseAction(value, sourceSpan) {\n      var sourceInfo = (sourceSpan && sourceSpan.start || '(unknown').toString();\n      var absoluteOffset = sourceSpan && sourceSpan.start ? sourceSpan.start.offset : 0;\n\n      try {\n        var ast = this._exprParser.parseAction(value, sourceInfo, absoluteOffset, this._interpolationConfig);\n\n        if (ast) {\n          this._reportExpressionParserErrors(ast.errors, sourceSpan);\n        }\n\n        if (!ast || ast.ast instanceof EmptyExpr) {\n          this._reportError(\"Empty expressions are not allowed\", sourceSpan);\n\n          return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n        }\n\n        this._checkPipes(ast, sourceSpan);\n\n        return ast;\n      } catch (e) {\n        this._reportError(\"\".concat(e), sourceSpan);\n\n        return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo, absoluteOffset);\n      }\n    }\n  }, {\n    key: \"_reportError\",\n    value: function _reportError(message, sourceSpan) {\n      var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ParseErrorLevel.ERROR;\n      this.errors.push(new ParseError(sourceSpan, message, level));\n    }\n  }, {\n    key: \"_reportExpressionParserErrors\",\n    value: function _reportExpressionParserErrors(errors, sourceSpan) {\n      var _iterator8 = _createForOfIteratorHelper(errors),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var _error = _step8.value;\n\n          this._reportError(_error.message, sourceSpan);\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n    } // Make sure all the used pipes are known in `this.pipesByName`\n\n  }, {\n    key: \"_checkPipes\",\n    value: function _checkPipes(ast, sourceSpan) {\n      var _this143 = this;\n\n      if (ast && this.pipesByName) {\n        var collector = new PipeCollector();\n        ast.visit(collector);\n        collector.pipes.forEach(function (ast, pipeName) {\n          var pipeMeta = _this143.pipesByName.get(pipeName);\n\n          if (!pipeMeta) {\n            _this143._reportError(\"The pipe '\".concat(pipeName, \"' could not be found\"), new ParseSourceSpan(sourceSpan.start.moveBy(ast.span.start), sourceSpan.start.moveBy(ast.span.end)));\n          } else {\n            _this143._usedPipes.set(pipeName, pipeMeta);\n          }\n        });\n      }\n    }\n    /**\n     * @param propName the name of the property / attribute\n     * @param sourceSpan\n     * @param isAttr true when binding to an attribute\n     */\n\n  }, {\n    key: \"_validatePropertyOrAttributeName\",\n    value: function _validatePropertyOrAttributeName(propName, sourceSpan, isAttr) {\n      var report = isAttr ? this._schemaRegistry.validateAttribute(propName) : this._schemaRegistry.validateProperty(propName);\n\n      if (report.error) {\n        this._reportError(report.msg, sourceSpan, ParseErrorLevel.ERROR);\n      }\n    }\n  }, {\n    key: \"interpolationConfig\",\n    get: function get() {\n      return this._interpolationConfig;\n    }\n  }]);\n\n  return BindingParser;\n}();\n\nvar PipeCollector = /*#__PURE__*/function (_RecursiveAstVisitor$) {\n  _inherits(PipeCollector, _RecursiveAstVisitor$);\n\n  var _super88 = _createSuper(PipeCollector);\n\n  function PipeCollector() {\n    var _this144;\n\n    _classCallCheck(this, PipeCollector);\n\n    _this144 = _super88.apply(this, arguments);\n    _this144.pipes = new Map();\n    return _this144;\n  }\n\n  _createClass(PipeCollector, [{\n    key: \"visitPipe\",\n    value: function visitPipe(ast, context) {\n      this.pipes.set(ast.name, ast);\n      ast.exp.visit(this);\n      this.visitAll(ast.args, context);\n      return null;\n    }\n  }]);\n\n  return PipeCollector;\n}(RecursiveAstVisitor$1);\n\nfunction isAnimationLabel(name) {\n  return name[0] == '@';\n}\n\nfunction _calcPossibleSecurityContexts(registry, selector, propName, isAttribute) {\n  var ctxs = [];\n  CssSelector.parse(selector).forEach(function (selector) {\n    var elementNames = selector.element ? [selector.element] : registry.allKnownElementNames();\n    var notElementNames = new Set(selector.notSelectors.filter(function (selector) {\n      return selector.isElementSelector();\n    }).map(function (selector) {\n      return selector.element;\n    }));\n    var possibleElementNames = elementNames.filter(function (elementName) {\n      return !notElementNames.has(elementName);\n    });\n    ctxs.push.apply(ctxs, _toConsumableArray(possibleElementNames.map(function (elementName) {\n      return registry.securityContext(elementName, propName, isAttribute);\n    })));\n  });\n  return ctxs.length === 0 ? [SecurityContext.NONE] : Array.from(new Set(ctxs)).sort();\n}\n/**\n * Compute a new ParseSourceSpan based off an original `sourceSpan` by using\n * absolute offsets from the specified `absoluteSpan`.\n *\n * @param sourceSpan original source span\n * @param absoluteSpan absolute source span to move to\n */\n\n\nfunction moveParseSourceSpan(sourceSpan, absoluteSpan) {\n  // The difference of two absolute offsets provide the relative offset\n  var startDiff = absoluteSpan.start - sourceSpan.start.offset;\n  var endDiff = absoluteSpan.end - sourceSpan.end.offset;\n  return new ParseSourceSpan(sourceSpan.start.moveBy(startDiff), sourceSpan.end.moveBy(endDiff));\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar NG_CONTENT_SELECT_ATTR = 'select';\nvar LINK_ELEMENT = 'link';\nvar LINK_STYLE_REL_ATTR = 'rel';\nvar LINK_STYLE_HREF_ATTR = 'href';\nvar LINK_STYLE_REL_VALUE = 'stylesheet';\nvar STYLE_ELEMENT = 'style';\nvar SCRIPT_ELEMENT = 'script';\nvar NG_NON_BINDABLE_ATTR = 'ngNonBindable';\nvar NG_PROJECT_AS = 'ngProjectAs';\n\nfunction preparseElement(ast) {\n  var selectAttr = null;\n  var hrefAttr = null;\n  var relAttr = null;\n  var nonBindable = false;\n  var projectAs = '';\n  ast.attrs.forEach(function (attr) {\n    var lcAttrName = attr.name.toLowerCase();\n\n    if (lcAttrName == NG_CONTENT_SELECT_ATTR) {\n      selectAttr = attr.value;\n    } else if (lcAttrName == LINK_STYLE_HREF_ATTR) {\n      hrefAttr = attr.value;\n    } else if (lcAttrName == LINK_STYLE_REL_ATTR) {\n      relAttr = attr.value;\n    } else if (attr.name == NG_NON_BINDABLE_ATTR) {\n      nonBindable = true;\n    } else if (attr.name == NG_PROJECT_AS) {\n      if (attr.value.length > 0) {\n        projectAs = attr.value;\n      }\n    }\n  });\n  selectAttr = normalizeNgContentSelect(selectAttr);\n  var nodeName = ast.name.toLowerCase();\n  var type = PreparsedElementType.OTHER;\n\n  if (isNgContent(nodeName)) {\n    type = PreparsedElementType.NG_CONTENT;\n  } else if (nodeName == STYLE_ELEMENT) {\n    type = PreparsedElementType.STYLE;\n  } else if (nodeName == SCRIPT_ELEMENT) {\n    type = PreparsedElementType.SCRIPT;\n  } else if (nodeName == LINK_ELEMENT && relAttr == LINK_STYLE_REL_VALUE) {\n    type = PreparsedElementType.STYLESHEET;\n  }\n\n  return new PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs);\n}\n\nvar PreparsedElementType;\n\n(function (PreparsedElementType) {\n  PreparsedElementType[PreparsedElementType[\"NG_CONTENT\"] = 0] = \"NG_CONTENT\";\n  PreparsedElementType[PreparsedElementType[\"STYLE\"] = 1] = \"STYLE\";\n  PreparsedElementType[PreparsedElementType[\"STYLESHEET\"] = 2] = \"STYLESHEET\";\n  PreparsedElementType[PreparsedElementType[\"SCRIPT\"] = 3] = \"SCRIPT\";\n  PreparsedElementType[PreparsedElementType[\"OTHER\"] = 4] = \"OTHER\";\n})(PreparsedElementType || (PreparsedElementType = {}));\n\nvar PreparsedElement = function PreparsedElement(type, selectAttr, hrefAttr, nonBindable, projectAs) {\n  _classCallCheck(this, PreparsedElement);\n\n  this.type = type;\n  this.selectAttr = selectAttr;\n  this.hrefAttr = hrefAttr;\n  this.nonBindable = nonBindable;\n  this.projectAs = projectAs;\n};\n\nfunction normalizeNgContentSelect(selectAttr) {\n  if (selectAttr === null || selectAttr.length === 0) {\n    return '*';\n  }\n\n  return selectAttr;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar BIND_NAME_REGEXP = /^(?:(?:(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.*))|\\[\\(([^\\)]+)\\)\\]|\\[([^\\]]+)\\]|\\(([^\\)]+)\\))$/; // Group 1 = \"bind-\"\n\nvar KW_BIND_IDX = 1; // Group 2 = \"let-\"\n\nvar KW_LET_IDX = 2; // Group 3 = \"ref-/#\"\n\nvar KW_REF_IDX = 3; // Group 4 = \"on-\"\n\nvar KW_ON_IDX = 4; // Group 5 = \"bindon-\"\n\nvar KW_BINDON_IDX = 5; // Group 6 = \"@\"\n\nvar KW_AT_IDX = 6; // Group 7 = the identifier after \"bind-\", \"let-\", \"ref-/#\", \"on-\", \"bindon-\" or \"@\"\n\nvar IDENT_KW_IDX = 7; // Group 8 = identifier inside [()]\n\nvar IDENT_BANANA_BOX_IDX = 8; // Group 9 = identifier inside []\n\nvar IDENT_PROPERTY_IDX = 9; // Group 10 = identifier inside ()\n\nvar IDENT_EVENT_IDX = 10;\nvar TEMPLATE_ATTR_PREFIX$1 = '*';\nvar CLASS_ATTR = 'class';\n\nvar _TEXT_CSS_SELECTOR;\n\nfunction TEXT_CSS_SELECTOR() {\n  if (!_TEXT_CSS_SELECTOR) {\n    _TEXT_CSS_SELECTOR = CssSelector.parse('*')[0];\n  }\n\n  return _TEXT_CSS_SELECTOR;\n}\n\nvar TemplateParseError = /*#__PURE__*/function (_ParseError5) {\n  _inherits(TemplateParseError, _ParseError5);\n\n  var _super89 = _createSuper(TemplateParseError);\n\n  function TemplateParseError(message, span, level) {\n    _classCallCheck(this, TemplateParseError);\n\n    return _super89.call(this, span, message, level);\n  }\n\n  return TemplateParseError;\n}(ParseError);\n\nvar TemplateParseResult = function TemplateParseResult(templateAst, usedPipes, errors) {\n  _classCallCheck(this, TemplateParseResult);\n\n  this.templateAst = templateAst;\n  this.usedPipes = usedPipes;\n  this.errors = errors;\n};\n\nvar TemplateParser = /*#__PURE__*/function () {\n  function TemplateParser(_config, _reflector, _exprParser, _schemaRegistry, _htmlParser, _console, transforms) {\n    _classCallCheck(this, TemplateParser);\n\n    this._config = _config;\n    this._reflector = _reflector;\n    this._exprParser = _exprParser;\n    this._schemaRegistry = _schemaRegistry;\n    this._htmlParser = _htmlParser;\n    this._console = _console;\n    this.transforms = transforms;\n  }\n\n  _createClass(TemplateParser, [{\n    key: \"parse\",\n    value: function parse(component, template, directives, pipes, schemas, templateUrl, preserveWhitespaces) {\n      var _a;\n\n      var result = this.tryParse(component, template, directives, pipes, schemas, templateUrl, preserveWhitespaces);\n      var warnings = result.errors.filter(function (error) {\n        return error.level === ParseErrorLevel.WARNING;\n      });\n      var errors = result.errors.filter(function (error) {\n        return error.level === ParseErrorLevel.ERROR;\n      });\n\n      if (warnings.length > 0) {\n        (_a = this._console) === null || _a === void 0 ? void 0 : _a.warn(\"Template parse warnings:\\n\".concat(warnings.join('\\n')));\n      }\n\n      if (errors.length > 0) {\n        var errorString = errors.join('\\n');\n        throw syntaxError(\"Template parse errors:\\n\".concat(errorString), errors);\n      }\n\n      return {\n        template: result.templateAst,\n        pipes: result.usedPipes\n      };\n    }\n  }, {\n    key: \"tryParse\",\n    value: function tryParse(component, template, directives, pipes, schemas, templateUrl, preserveWhitespaces) {\n      var htmlParseResult = typeof template === 'string' ? this._htmlParser.parse(template, templateUrl, {\n        tokenizeExpansionForms: true,\n        interpolationConfig: this.getInterpolationConfig(component)\n      }) : template;\n\n      if (!preserveWhitespaces) {\n        htmlParseResult = removeWhitespaces(htmlParseResult);\n      }\n\n      return this.tryParseHtml(this.expandHtml(htmlParseResult), component, directives, pipes, schemas);\n    }\n  }, {\n    key: \"tryParseHtml\",\n    value: function tryParseHtml(htmlAstWithErrors, component, directives, pipes, schemas) {\n      var result;\n      var errors = htmlAstWithErrors.errors;\n      var usedPipes = [];\n\n      if (htmlAstWithErrors.rootNodes.length > 0) {\n        var uniqDirectives = removeSummaryDuplicates(directives);\n        var uniqPipes = removeSummaryDuplicates(pipes);\n        var providerViewContext = new ProviderViewContext(this._reflector, component);\n        var interpolationConfig = undefined;\n\n        if (component.template && component.template.interpolation) {\n          interpolationConfig = {\n            start: component.template.interpolation[0],\n            end: component.template.interpolation[1]\n          };\n        }\n\n        var bindingParser = new BindingParser(this._exprParser, interpolationConfig, this._schemaRegistry, uniqPipes, errors);\n        var parseVisitor = new TemplateParseVisitor(this._reflector, this._config, providerViewContext, uniqDirectives, bindingParser, this._schemaRegistry, schemas, errors);\n        result = visitAll$1(parseVisitor, htmlAstWithErrors.rootNodes, EMPTY_ELEMENT_CONTEXT);\n        errors.push.apply(errors, _toConsumableArray(providerViewContext.errors));\n        usedPipes.push.apply(usedPipes, _toConsumableArray(bindingParser.getUsedPipes()));\n      } else {\n        result = [];\n      }\n\n      this._assertNoReferenceDuplicationOnTemplate(result, errors);\n\n      if (errors.length > 0) {\n        return new TemplateParseResult(result, usedPipes, errors);\n      }\n\n      if (this.transforms) {\n        this.transforms.forEach(function (transform) {\n          result = templateVisitAll(transform, result);\n        });\n      }\n\n      return new TemplateParseResult(result, usedPipes, errors);\n    }\n  }, {\n    key: \"expandHtml\",\n    value: function expandHtml(htmlAstWithErrors) {\n      var forced = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var errors = htmlAstWithErrors.errors;\n\n      if (errors.length == 0 || forced) {\n        // Transform ICU messages to angular directives\n        var expandedHtmlAst = expandNodes(htmlAstWithErrors.rootNodes);\n        errors.push.apply(errors, _toConsumableArray(expandedHtmlAst.errors));\n        htmlAstWithErrors = new ParseTreeResult(expandedHtmlAst.nodes, errors);\n      }\n\n      return htmlAstWithErrors;\n    }\n  }, {\n    key: \"getInterpolationConfig\",\n    value: function getInterpolationConfig(component) {\n      if (component.template) {\n        return InterpolationConfig.fromArray(component.template.interpolation);\n      }\n\n      return undefined;\n    }\n    /** @internal */\n\n  }, {\n    key: \"_assertNoReferenceDuplicationOnTemplate\",\n    value: function _assertNoReferenceDuplicationOnTemplate(result, errors) {\n      var existingReferences = [];\n      result.filter(function (element) {\n        return !!element.references;\n      }).forEach(function (element) {\n        return element.references.forEach(function (reference) {\n          var name = reference.name;\n\n          if (existingReferences.indexOf(name) < 0) {\n            existingReferences.push(name);\n          } else {\n            var _error2 = new TemplateParseError(\"Reference \\\"#\".concat(name, \"\\\" is defined several times\"), reference.sourceSpan, ParseErrorLevel.ERROR);\n\n            errors.push(_error2);\n          }\n        });\n      });\n    }\n  }, {\n    key: \"expressionParser\",\n    get: function get() {\n      return this._exprParser;\n    }\n  }]);\n\n  return TemplateParser;\n}();\n\nvar TemplateParseVisitor = /*#__PURE__*/function () {\n  function TemplateParseVisitor(reflector, config, providerViewContext, directives, _bindingParser, _schemaRegistry, _schemas, _targetErrors) {\n    var _this145 = this;\n\n    _classCallCheck(this, TemplateParseVisitor);\n\n    this.reflector = reflector;\n    this.config = config;\n    this.providerViewContext = providerViewContext;\n    this._bindingParser = _bindingParser;\n    this._schemaRegistry = _schemaRegistry;\n    this._schemas = _schemas;\n    this._targetErrors = _targetErrors;\n    this.selectorMatcher = new SelectorMatcher();\n    this.directivesIndex = new Map();\n    this.ngContentCount = 0; // Note: queries start with id 1 so we can use the number in a Bloom filter!\n\n    this.contentQueryStartId = providerViewContext.component.viewQueries.length + 1;\n    directives.forEach(function (directive, index) {\n      var selector = CssSelector.parse(directive.selector);\n\n      _this145.selectorMatcher.addSelectables(selector, directive);\n\n      _this145.directivesIndex.set(directive, index);\n    });\n  }\n\n  _createClass(TemplateParseVisitor, [{\n    key: \"visitExpansion\",\n    value: function visitExpansion(expansion, context) {\n      return null;\n    }\n  }, {\n    key: \"visitExpansionCase\",\n    value: function visitExpansionCase(expansionCase, context) {\n      return null;\n    }\n  }, {\n    key: \"visitText\",\n    value: function visitText(text, parent) {\n      var ngContentIndex = parent.findNgContentIndex(TEXT_CSS_SELECTOR());\n      var valueNoNgsp = replaceNgsp(text.value);\n\n      var expr = this._bindingParser.parseInterpolation(valueNoNgsp, text.sourceSpan);\n\n      return expr ? new BoundTextAst(expr, ngContentIndex, text.sourceSpan) : new TextAst(valueNoNgsp, ngContentIndex, text.sourceSpan);\n    }\n  }, {\n    key: \"visitAttribute\",\n    value: function visitAttribute(attribute, context) {\n      return new AttrAst(attribute.name, attribute.value, attribute.sourceSpan);\n    }\n  }, {\n    key: \"visitComment\",\n    value: function visitComment(comment, context) {\n      return null;\n    }\n  }, {\n    key: \"visitElement\",\n    value: function visitElement(element, parent) {\n      var _this146 = this;\n\n      var queryStartIndex = this.contentQueryStartId;\n      var elName = element.name;\n      var preparsedElement = preparseElement(element);\n\n      if (preparsedElement.type === PreparsedElementType.SCRIPT || preparsedElement.type === PreparsedElementType.STYLE) {\n        // Skipping <script> for security reasons\n        // Skipping <style> as we already processed them\n        // in the StyleCompiler\n        return null;\n      }\n\n      if (preparsedElement.type === PreparsedElementType.STYLESHEET && isStyleUrlResolvable(preparsedElement.hrefAttr)) {\n        // Skipping stylesheets with either relative urls or package scheme as we already processed\n        // them in the StyleCompiler\n        return null;\n      }\n\n      var matchableAttrs = [];\n      var elementOrDirectiveProps = [];\n      var elementOrDirectiveRefs = [];\n      var elementVars = [];\n      var events = [];\n      var templateElementOrDirectiveProps = [];\n      var templateMatchableAttrs = [];\n      var templateElementVars = [];\n      var hasInlineTemplates = false;\n      var attrs = [];\n      var isTemplateElement = isNgTemplate(element.name);\n      element.attrs.forEach(function (attr) {\n        var parsedVariables = [];\n\n        var hasBinding = _this146._parseAttr(isTemplateElement, attr, matchableAttrs, elementOrDirectiveProps, events, elementOrDirectiveRefs, elementVars);\n\n        elementVars.push.apply(elementVars, _toConsumableArray(parsedVariables.map(function (v) {\n          return VariableAst.fromParsedVariable(v);\n        })));\n        var templateValue;\n        var templateKey;\n\n        var normalizedName = _this146._normalizeAttributeName(attr.name);\n\n        if (normalizedName.startsWith(TEMPLATE_ATTR_PREFIX$1)) {\n          templateValue = attr.value;\n          templateKey = normalizedName.substring(TEMPLATE_ATTR_PREFIX$1.length);\n        }\n\n        var hasTemplateBinding = templateValue != null;\n\n        if (hasTemplateBinding) {\n          if (hasInlineTemplates) {\n            _this146._reportError(\"Can't have multiple template bindings on one element. Use only one attribute prefixed with *\", attr.sourceSpan);\n          }\n\n          hasInlineTemplates = true;\n          var _parsedVariables = [];\n          var absoluteOffset = (attr.valueSpan || attr.sourceSpan).start.offset;\n\n          _this146._bindingParser.parseInlineTemplateBinding(templateKey, templateValue, attr.sourceSpan, absoluteOffset, templateMatchableAttrs, templateElementOrDirectiveProps, _parsedVariables);\n\n          templateElementVars.push.apply(templateElementVars, _toConsumableArray(_parsedVariables.map(function (v) {\n            return VariableAst.fromParsedVariable(v);\n          })));\n        }\n\n        if (!hasBinding && !hasTemplateBinding) {\n          // don't include the bindings as attributes as well in the AST\n          attrs.push(_this146.visitAttribute(attr, null));\n          matchableAttrs.push([attr.name, attr.value]);\n        }\n      });\n      var elementCssSelector = createElementCssSelector(elName, matchableAttrs);\n\n      var _this$_parseDirective = this._parseDirectives(this.selectorMatcher, elementCssSelector),\n          directiveMetas = _this$_parseDirective.directives,\n          matchElement = _this$_parseDirective.matchElement;\n\n      var references = [];\n      var boundDirectivePropNames = new Set();\n\n      var directiveAsts = this._createDirectiveAsts(isTemplateElement, element.name, directiveMetas, elementOrDirectiveProps, elementOrDirectiveRefs, element.sourceSpan, references, boundDirectivePropNames);\n\n      var elementProps = this._createElementPropertyAsts(element.name, elementOrDirectiveProps, boundDirectivePropNames);\n\n      var isViewRoot = parent.isTemplateElement || hasInlineTemplates;\n      var providerContext = new ProviderElementContext(this.providerViewContext, parent.providerContext, isViewRoot, directiveAsts, attrs, references, isTemplateElement, queryStartIndex, element.sourceSpan);\n      var children = visitAll$1(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR : this, element.children, ElementContext.create(isTemplateElement, directiveAsts, isTemplateElement ? parent.providerContext : providerContext));\n      providerContext.afterElement(); // Override the actual selector when the `ngProjectAs` attribute is provided\n\n      var projectionSelector = preparsedElement.projectAs != '' ? CssSelector.parse(preparsedElement.projectAs)[0] : elementCssSelector;\n      var ngContentIndex = parent.findNgContentIndex(projectionSelector);\n      var parsedElement;\n\n      if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {\n        // `<ng-content>` element\n        if (element.children && !element.children.every(_isEmptyTextNode)) {\n          this._reportError(\"<ng-content> element cannot have content.\", element.sourceSpan);\n        }\n\n        parsedElement = new NgContentAst(this.ngContentCount++, hasInlineTemplates ? null : ngContentIndex, element.sourceSpan);\n      } else if (isTemplateElement) {\n        // `<ng-template>` element\n        this._assertAllEventsPublishedByDirectives(directiveAsts, events);\n\n        this._assertNoComponentsNorElementBindingsOnTemplate(directiveAsts, elementProps, element.sourceSpan);\n\n        parsedElement = new EmbeddedTemplateAst(attrs, events, references, elementVars, providerContext.transformedDirectiveAsts, providerContext.transformProviders, providerContext.transformedHasViewContainer, providerContext.queryMatches, children, hasInlineTemplates ? null : ngContentIndex, element.sourceSpan);\n      } else {\n        // element other than `<ng-content>` and `<ng-template>`\n        this._assertElementExists(matchElement, element);\n\n        this._assertOnlyOneComponent(directiveAsts, element.sourceSpan);\n\n        var _ngContentIndex = hasInlineTemplates ? null : parent.findNgContentIndex(projectionSelector);\n\n        parsedElement = new ElementAst(elName, attrs, elementProps, events, references, providerContext.transformedDirectiveAsts, providerContext.transformProviders, providerContext.transformedHasViewContainer, providerContext.queryMatches, children, hasInlineTemplates ? null : _ngContentIndex, element.sourceSpan, element.endSourceSpan || null);\n      }\n\n      if (hasInlineTemplates) {\n        // The element as a *-attribute\n        var templateQueryStartIndex = this.contentQueryStartId;\n        var templateSelector = createElementCssSelector('ng-template', templateMatchableAttrs);\n\n        var _this$_parseDirective2 = this._parseDirectives(this.selectorMatcher, templateSelector),\n            directives = _this$_parseDirective2.directives;\n\n        var templateBoundDirectivePropNames = new Set();\n\n        var templateDirectiveAsts = this._createDirectiveAsts(true, elName, directives, templateElementOrDirectiveProps, [], element.sourceSpan, [], templateBoundDirectivePropNames);\n\n        var templateElementProps = this._createElementPropertyAsts(elName, templateElementOrDirectiveProps, templateBoundDirectivePropNames);\n\n        this._assertNoComponentsNorElementBindingsOnTemplate(templateDirectiveAsts, templateElementProps, element.sourceSpan);\n\n        var templateProviderContext = new ProviderElementContext(this.providerViewContext, parent.providerContext, parent.isTemplateElement, templateDirectiveAsts, [], [], true, templateQueryStartIndex, element.sourceSpan);\n        templateProviderContext.afterElement();\n        parsedElement = new EmbeddedTemplateAst([], [], [], templateElementVars, templateProviderContext.transformedDirectiveAsts, templateProviderContext.transformProviders, templateProviderContext.transformedHasViewContainer, templateProviderContext.queryMatches, [parsedElement], ngContentIndex, element.sourceSpan);\n      }\n\n      return parsedElement;\n    }\n  }, {\n    key: \"_parseAttr\",\n    value: function _parseAttr(isTemplateElement, attr, targetMatchableAttrs, targetProps, targetEvents, targetRefs, targetVars) {\n      var name = this._normalizeAttributeName(attr.name);\n\n      var value = attr.value;\n      var srcSpan = attr.sourceSpan;\n      var absoluteOffset = attr.valueSpan ? attr.valueSpan.start.offset : srcSpan.start.offset;\n      var boundEvents = [];\n      var bindParts = name.match(BIND_NAME_REGEXP);\n      var hasBinding = false;\n\n      if (bindParts !== null) {\n        hasBinding = true;\n\n        if (bindParts[KW_BIND_IDX] != null) {\n          this._bindingParser.parsePropertyBinding(bindParts[IDENT_KW_IDX], value, false, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);\n        } else if (bindParts[KW_LET_IDX]) {\n          if (isTemplateElement) {\n            var identifier = bindParts[IDENT_KW_IDX];\n\n            this._parseVariable(identifier, value, srcSpan, targetVars);\n          } else {\n            this._reportError(\"\\\"let-\\\" is only supported on ng-template elements.\", srcSpan);\n          }\n        } else if (bindParts[KW_REF_IDX]) {\n          var _identifier = bindParts[IDENT_KW_IDX];\n\n          this._parseReference(_identifier, value, srcSpan, targetRefs);\n        } else if (bindParts[KW_ON_IDX]) {\n          this._bindingParser.parseEvent(bindParts[IDENT_KW_IDX], value, srcSpan, attr.valueSpan || srcSpan, targetMatchableAttrs, boundEvents);\n        } else if (bindParts[KW_BINDON_IDX]) {\n          this._bindingParser.parsePropertyBinding(bindParts[IDENT_KW_IDX], value, false, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);\n\n          this._parseAssignmentEvent(bindParts[IDENT_KW_IDX], value, srcSpan, attr.valueSpan || srcSpan, targetMatchableAttrs, boundEvents);\n        } else if (bindParts[KW_AT_IDX]) {\n          this._bindingParser.parseLiteralAttr(name, value, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);\n        } else if (bindParts[IDENT_BANANA_BOX_IDX]) {\n          this._bindingParser.parsePropertyBinding(bindParts[IDENT_BANANA_BOX_IDX], value, false, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);\n\n          this._parseAssignmentEvent(bindParts[IDENT_BANANA_BOX_IDX], value, srcSpan, attr.valueSpan || srcSpan, targetMatchableAttrs, boundEvents);\n        } else if (bindParts[IDENT_PROPERTY_IDX]) {\n          this._bindingParser.parsePropertyBinding(bindParts[IDENT_PROPERTY_IDX], value, false, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);\n        } else if (bindParts[IDENT_EVENT_IDX]) {\n          this._bindingParser.parseEvent(bindParts[IDENT_EVENT_IDX], value, srcSpan, attr.valueSpan || srcSpan, targetMatchableAttrs, boundEvents);\n        }\n      } else {\n        hasBinding = this._bindingParser.parsePropertyInterpolation(name, value, srcSpan, attr.valueSpan, targetMatchableAttrs, targetProps);\n      }\n\n      if (!hasBinding) {\n        this._bindingParser.parseLiteralAttr(name, value, srcSpan, absoluteOffset, attr.valueSpan, targetMatchableAttrs, targetProps);\n      }\n\n      targetEvents.push.apply(targetEvents, _toConsumableArray(boundEvents.map(function (e) {\n        return BoundEventAst.fromParsedEvent(e);\n      })));\n      return hasBinding;\n    }\n  }, {\n    key: \"_normalizeAttributeName\",\n    value: function _normalizeAttributeName(attrName) {\n      return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;\n    }\n  }, {\n    key: \"_parseVariable\",\n    value: function _parseVariable(identifier, value, sourceSpan, targetVars) {\n      if (identifier.indexOf('-') > -1) {\n        this._reportError(\"\\\"-\\\" is not allowed in variable names\", sourceSpan);\n      } else if (identifier.length === 0) {\n        this._reportError(\"Variable does not have a name\", sourceSpan);\n      }\n\n      targetVars.push(new VariableAst(identifier, value, sourceSpan));\n    }\n  }, {\n    key: \"_parseReference\",\n    value: function _parseReference(identifier, value, sourceSpan, targetRefs) {\n      if (identifier.indexOf('-') > -1) {\n        this._reportError(\"\\\"-\\\" is not allowed in reference names\", sourceSpan);\n      } else if (identifier.length === 0) {\n        this._reportError(\"Reference does not have a name\", sourceSpan);\n      }\n\n      targetRefs.push(new ElementOrDirectiveRef(identifier, value, sourceSpan));\n    }\n  }, {\n    key: \"_parseAssignmentEvent\",\n    value: function _parseAssignmentEvent(name, expression, sourceSpan, valueSpan, targetMatchableAttrs, targetEvents) {\n      this._bindingParser.parseEvent(\"\".concat(name, \"Change\"), \"\".concat(expression, \"=$event\"), sourceSpan, valueSpan, targetMatchableAttrs, targetEvents);\n    }\n  }, {\n    key: \"_parseDirectives\",\n    value: function _parseDirectives(selectorMatcher, elementCssSelector) {\n      var _this147 = this;\n\n      // Need to sort the directives so that we get consistent results throughout,\n      // as selectorMatcher uses Maps inside.\n      // Also deduplicate directives as they might match more than one time!\n      var directives = newArray(this.directivesIndex.size); // Whether any directive selector matches on the element name\n\n      var matchElement = false;\n      selectorMatcher.match(elementCssSelector, function (selector, directive) {\n        directives[_this147.directivesIndex.get(directive)] = directive;\n        matchElement = matchElement || selector.hasElementSelector();\n      });\n      return {\n        directives: directives.filter(function (dir) {\n          return !!dir;\n        }),\n        matchElement: matchElement\n      };\n    }\n  }, {\n    key: \"_createDirectiveAsts\",\n    value: function _createDirectiveAsts(isTemplateElement, elementName, directives, props, elementOrDirectiveRefs, elementSourceSpan, targetReferences, targetBoundDirectivePropNames) {\n      var _this148 = this;\n\n      var matchedReferences = new Set();\n      var component = null;\n      var directiveAsts = directives.map(function (directive) {\n        var sourceSpan = new ParseSourceSpan(elementSourceSpan.start, elementSourceSpan.end, \"Directive \".concat(identifierName(directive.type)));\n\n        if (directive.isComponent) {\n          component = directive;\n        }\n\n        var directiveProperties = [];\n\n        var boundProperties = _this148._bindingParser.createDirectiveHostPropertyAsts(directive, elementName, sourceSpan);\n\n        var hostProperties = boundProperties.map(function (prop) {\n          return BoundElementPropertyAst.fromBoundProperty(prop);\n        }); // Note: We need to check the host properties here as well,\n        // as we don't know the element name in the DirectiveWrapperCompiler yet.\n\n        hostProperties = _this148._checkPropertiesInSchema(elementName, hostProperties);\n\n        var parsedEvents = _this148._bindingParser.createDirectiveHostEventAsts(directive, sourceSpan);\n\n        _this148._createDirectivePropertyAsts(directive.inputs, props, directiveProperties, targetBoundDirectivePropNames);\n\n        elementOrDirectiveRefs.forEach(function (elOrDirRef) {\n          if (elOrDirRef.value.length === 0 && directive.isComponent || elOrDirRef.isReferenceToDirective(directive)) {\n            targetReferences.push(new ReferenceAst(elOrDirRef.name, createTokenForReference(directive.type.reference), elOrDirRef.value, elOrDirRef.sourceSpan));\n            matchedReferences.add(elOrDirRef.name);\n          }\n        });\n        var hostEvents = parsedEvents.map(function (e) {\n          return BoundEventAst.fromParsedEvent(e);\n        });\n        var contentQueryStartId = _this148.contentQueryStartId;\n        _this148.contentQueryStartId += directive.queries.length;\n        return new DirectiveAst(directive, directiveProperties, hostProperties, hostEvents, contentQueryStartId, sourceSpan);\n      });\n      elementOrDirectiveRefs.forEach(function (elOrDirRef) {\n        if (elOrDirRef.value.length > 0) {\n          if (!matchedReferences.has(elOrDirRef.name)) {\n            _this148._reportError(\"There is no directive with \\\"exportAs\\\" set to \\\"\".concat(elOrDirRef.value, \"\\\"\"), elOrDirRef.sourceSpan);\n          }\n        } else if (!component) {\n          var refToken = null;\n\n          if (isTemplateElement) {\n            refToken = createTokenForExternalReference(_this148.reflector, Identifiers.TemplateRef);\n          }\n\n          targetReferences.push(new ReferenceAst(elOrDirRef.name, refToken, elOrDirRef.value, elOrDirRef.sourceSpan));\n        }\n      });\n      return directiveAsts;\n    }\n  }, {\n    key: \"_createDirectivePropertyAsts\",\n    value: function _createDirectivePropertyAsts(directiveProperties, boundProps, targetBoundDirectiveProps, targetBoundDirectivePropNames) {\n      if (directiveProperties) {\n        var boundPropsByName = new Map();\n        boundProps.forEach(function (boundProp) {\n          var prevValue = boundPropsByName.get(boundProp.name);\n\n          if (!prevValue || prevValue.isLiteral) {\n            // give [a]=\"b\" a higher precedence than a=\"b\" on the same element\n            boundPropsByName.set(boundProp.name, boundProp);\n          }\n        });\n        Object.keys(directiveProperties).forEach(function (dirProp) {\n          var elProp = directiveProperties[dirProp];\n          var boundProp = boundPropsByName.get(elProp); // Bindings are optional, so this binding only needs to be set up if an expression is given.\n\n          if (boundProp) {\n            targetBoundDirectivePropNames.add(boundProp.name);\n\n            if (!isEmptyExpression(boundProp.expression)) {\n              targetBoundDirectiveProps.push(new BoundDirectivePropertyAst(dirProp, boundProp.name, boundProp.expression, boundProp.sourceSpan));\n            }\n          }\n        });\n      }\n    }\n  }, {\n    key: \"_createElementPropertyAsts\",\n    value: function _createElementPropertyAsts(elementName, props, boundDirectivePropNames) {\n      var _this149 = this;\n\n      var boundElementProps = [];\n      props.forEach(function (prop) {\n        if (!prop.isLiteral && !boundDirectivePropNames.has(prop.name)) {\n          var boundProp = _this149._bindingParser.createBoundElementProperty(elementName, prop);\n\n          boundElementProps.push(BoundElementPropertyAst.fromBoundProperty(boundProp));\n        }\n      });\n      return this._checkPropertiesInSchema(elementName, boundElementProps);\n    }\n  }, {\n    key: \"_findComponentDirectives\",\n    value: function _findComponentDirectives(directives) {\n      return directives.filter(function (directive) {\n        return directive.directive.isComponent;\n      });\n    }\n  }, {\n    key: \"_findComponentDirectiveNames\",\n    value: function _findComponentDirectiveNames(directives) {\n      return this._findComponentDirectives(directives).map(function (directive) {\n        return identifierName(directive.directive.type);\n      });\n    }\n  }, {\n    key: \"_assertOnlyOneComponent\",\n    value: function _assertOnlyOneComponent(directives, sourceSpan) {\n      var componentTypeNames = this._findComponentDirectiveNames(directives);\n\n      if (componentTypeNames.length > 1) {\n        this._reportError(\"More than one component matched on this element.\\n\" + \"Make sure that only one component's selector can match a given element.\\n\" + \"Conflicting components: \".concat(componentTypeNames.join(',')), sourceSpan);\n      }\n    }\n    /**\n     * Make sure that non-angular tags conform to the schemas.\n     *\n     * Note: An element is considered an angular tag when at least one directive selector matches the\n     * tag name.\n     *\n     * @param matchElement Whether any directive has matched on the tag name\n     * @param element the html element\n     */\n\n  }, {\n    key: \"_assertElementExists\",\n    value: function _assertElementExists(matchElement, element) {\n      var elName = element.name.replace(/^:xhtml:/, '');\n\n      if (!matchElement && !this._schemaRegistry.hasElement(elName, this._schemas)) {\n        var errorMsg = \"'\".concat(elName, \"' is not a known element:\\n\");\n        errorMsg += \"1. If '\".concat(elName, \"' is an Angular component, then verify that it is part of this module.\\n\");\n\n        if (elName.indexOf('-') > -1) {\n          errorMsg += \"2. If '\".concat(elName, \"' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.\");\n        } else {\n          errorMsg += \"2. To allow any element add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.\";\n        }\n\n        this._reportError(errorMsg, element.sourceSpan);\n      }\n    }\n  }, {\n    key: \"_assertNoComponentsNorElementBindingsOnTemplate\",\n    value: function _assertNoComponentsNorElementBindingsOnTemplate(directives, elementProps, sourceSpan) {\n      var _this150 = this;\n\n      var componentTypeNames = this._findComponentDirectiveNames(directives);\n\n      if (componentTypeNames.length > 0) {\n        this._reportError(\"Components on an embedded template: \".concat(componentTypeNames.join(',')), sourceSpan);\n      }\n\n      elementProps.forEach(function (prop) {\n        _this150._reportError(\"Property binding \".concat(prop.name, \" not used by any directive on an embedded template. Make sure that the property name is spelled correctly and all directives are listed in the \\\"@NgModule.declarations\\\".\"), sourceSpan);\n      });\n    }\n  }, {\n    key: \"_assertAllEventsPublishedByDirectives\",\n    value: function _assertAllEventsPublishedByDirectives(directives, events) {\n      var _this151 = this;\n\n      var allDirectiveEvents = new Set();\n      directives.forEach(function (directive) {\n        Object.keys(directive.directive.outputs).forEach(function (k) {\n          var eventName = directive.directive.outputs[k];\n          allDirectiveEvents.add(eventName);\n        });\n      });\n      events.forEach(function (event) {\n        if (event.target != null || !allDirectiveEvents.has(event.name)) {\n          _this151._reportError(\"Event binding \".concat(event.fullName, \" not emitted by any directive on an embedded template. Make sure that the event name is spelled correctly and all directives are listed in the \\\"@NgModule.declarations\\\".\"), event.sourceSpan);\n        }\n      });\n    }\n  }, {\n    key: \"_checkPropertiesInSchema\",\n    value: function _checkPropertiesInSchema(elementName, boundProps) {\n      var _this152 = this;\n\n      // Note: We can't filter out empty expressions before this method,\n      // as we still want to validate them!\n      return boundProps.filter(function (boundProp) {\n        if (boundProp.type === 0\n        /* Property */\n        && !_this152._schemaRegistry.hasProperty(elementName, boundProp.name, _this152._schemas)) {\n          var errorMsg = \"Can't bind to '\".concat(boundProp.name, \"' since it isn't a known property of '\").concat(elementName, \"'.\");\n\n          if (elementName.startsWith('ng-')) {\n            errorMsg += \"\\n1. If '\".concat(boundProp.name, \"' is an Angular directive, then add 'CommonModule' to the '@NgModule.imports' of this component.\") + \"\\n2. To allow any property add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.\";\n          } else if (elementName.indexOf('-') > -1) {\n            errorMsg += \"\\n1. If '\".concat(elementName, \"' is an Angular component and it has '\").concat(boundProp.name, \"' input, then verify that it is part of this module.\") + \"\\n2. If '\".concat(elementName, \"' is a Web Component then add 'CUSTOM_ELEMENTS_SCHEMA' to the '@NgModule.schemas' of this component to suppress this message.\") + \"\\n3. To allow any property add 'NO_ERRORS_SCHEMA' to the '@NgModule.schemas' of this component.\";\n          }\n\n          _this152._reportError(errorMsg, boundProp.sourceSpan);\n        }\n\n        return !isEmptyExpression(boundProp.value);\n      });\n    }\n  }, {\n    key: \"_reportError\",\n    value: function _reportError(message, sourceSpan) {\n      var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ParseErrorLevel.ERROR;\n\n      this._targetErrors.push(new ParseError(sourceSpan, message, level));\n    }\n  }]);\n\n  return TemplateParseVisitor;\n}();\n\nvar NonBindableVisitor = /*#__PURE__*/function () {\n  function NonBindableVisitor() {\n    _classCallCheck(this, NonBindableVisitor);\n  }\n\n  _createClass(NonBindableVisitor, [{\n    key: \"visitElement\",\n    value: function visitElement(ast, parent) {\n      var preparsedElement = preparseElement(ast);\n\n      if (preparsedElement.type === PreparsedElementType.SCRIPT || preparsedElement.type === PreparsedElementType.STYLE || preparsedElement.type === PreparsedElementType.STYLESHEET) {\n        // Skipping <script> for security reasons\n        // Skipping <style> and stylesheets as we already processed them\n        // in the StyleCompiler\n        return null;\n      }\n\n      var attrNameAndValues = ast.attrs.map(function (attr) {\n        return [attr.name, attr.value];\n      });\n      var selector = createElementCssSelector(ast.name, attrNameAndValues);\n      var ngContentIndex = parent.findNgContentIndex(selector);\n      var children = visitAll$1(this, ast.children, EMPTY_ELEMENT_CONTEXT);\n      return new ElementAst(ast.name, visitAll$1(this, ast.attrs), [], [], [], [], [], false, [], children, ngContentIndex, ast.sourceSpan, ast.endSourceSpan);\n    }\n  }, {\n    key: \"visitComment\",\n    value: function visitComment(comment, context) {\n      return null;\n    }\n  }, {\n    key: \"visitAttribute\",\n    value: function visitAttribute(attribute, context) {\n      return new AttrAst(attribute.name, attribute.value, attribute.sourceSpan);\n    }\n  }, {\n    key: \"visitText\",\n    value: function visitText(text, parent) {\n      var ngContentIndex = parent.findNgContentIndex(TEXT_CSS_SELECTOR());\n      return new TextAst(text.value, ngContentIndex, text.sourceSpan);\n    }\n  }, {\n    key: \"visitExpansion\",\n    value: function visitExpansion(expansion, context) {\n      return expansion;\n    }\n  }, {\n    key: \"visitExpansionCase\",\n    value: function visitExpansionCase(expansionCase, context) {\n      return expansionCase;\n    }\n  }]);\n\n  return NonBindableVisitor;\n}();\n/**\n * A reference to an element or directive in a template. E.g., the reference in this template:\n *\n * <div #myMenu=\"coolMenu\">\n *\n * would be {name: 'myMenu', value: 'coolMenu', sourceSpan: ...}\n */\n\n\nvar ElementOrDirectiveRef = /*#__PURE__*/function () {\n  function ElementOrDirectiveRef(name, value, sourceSpan) {\n    _classCallCheck(this, ElementOrDirectiveRef);\n\n    this.name = name;\n    this.value = value;\n    this.sourceSpan = sourceSpan;\n  }\n  /** Gets whether this is a reference to the given directive. */\n\n\n  _createClass(ElementOrDirectiveRef, [{\n    key: \"isReferenceToDirective\",\n    value: function isReferenceToDirective(directive) {\n      return splitExportAs(directive.exportAs).indexOf(this.value) !== -1;\n    }\n  }]);\n\n  return ElementOrDirectiveRef;\n}();\n/** Splits a raw, potentially comma-delimited `exportAs` value into an array of names. */\n\n\nfunction splitExportAs(exportAs) {\n  return exportAs ? exportAs.split(',').map(function (e) {\n    return e.trim();\n  }) : [];\n}\n\nfunction splitClasses(classAttrValue) {\n  return classAttrValue.trim().split(/\\s+/g);\n}\n\nvar ElementContext = /*#__PURE__*/function () {\n  function ElementContext(isTemplateElement, _ngContentIndexMatcher, _wildcardNgContentIndex, providerContext) {\n    _classCallCheck(this, ElementContext);\n\n    this.isTemplateElement = isTemplateElement;\n    this._ngContentIndexMatcher = _ngContentIndexMatcher;\n    this._wildcardNgContentIndex = _wildcardNgContentIndex;\n    this.providerContext = providerContext;\n  }\n\n  _createClass(ElementContext, [{\n    key: \"findNgContentIndex\",\n    value: function findNgContentIndex(selector) {\n      var ngContentIndices = [];\n\n      this._ngContentIndexMatcher.match(selector, function (selector, ngContentIndex) {\n        ngContentIndices.push(ngContentIndex);\n      });\n\n      ngContentIndices.sort();\n\n      if (this._wildcardNgContentIndex != null) {\n        ngContentIndices.push(this._wildcardNgContentIndex);\n      }\n\n      return ngContentIndices.length > 0 ? ngContentIndices[0] : null;\n    }\n  }], [{\n    key: \"create\",\n    value: function create(isTemplateElement, directives, providerContext) {\n      var matcher = new SelectorMatcher();\n      var wildcardNgContentIndex = null;\n      var component = directives.find(function (directive) {\n        return directive.directive.isComponent;\n      });\n\n      if (component) {\n        var ngContentSelectors = component.directive.template.ngContentSelectors;\n\n        for (var i = 0; i < ngContentSelectors.length; i++) {\n          var selector = ngContentSelectors[i];\n\n          if (selector === '*') {\n            wildcardNgContentIndex = i;\n          } else {\n            matcher.addSelectables(CssSelector.parse(ngContentSelectors[i]), i);\n          }\n        }\n      }\n\n      return new ElementContext(isTemplateElement, matcher, wildcardNgContentIndex, providerContext);\n    }\n  }]);\n\n  return ElementContext;\n}();\n\nfunction createElementCssSelector(elementName, attributes) {\n  var cssSelector = new CssSelector();\n  var elNameNoNs = splitNsName(elementName)[1];\n  cssSelector.setElement(elNameNoNs);\n\n  for (var i = 0; i < attributes.length; i++) {\n    var attrName = attributes[i][0];\n    var attrNameNoNs = splitNsName(attrName)[1];\n    var attrValue = attributes[i][1];\n    cssSelector.addAttribute(attrNameNoNs, attrValue);\n\n    if (attrName.toLowerCase() == CLASS_ATTR) {\n      var classes = splitClasses(attrValue);\n      classes.forEach(function (className) {\n        return cssSelector.addClassName(className);\n      });\n    }\n  }\n\n  return cssSelector;\n}\n\nvar EMPTY_ELEMENT_CONTEXT = new ElementContext(true, new SelectorMatcher(), null, null);\nvar NON_BINDABLE_VISITOR = new NonBindableVisitor();\n\nfunction _isEmptyTextNode(node) {\n  return node instanceof Text$3 && node.value.trim().length == 0;\n}\n\nfunction removeSummaryDuplicates(items) {\n  var map = new Map();\n  items.forEach(function (item) {\n    if (!map.get(item.type.reference)) {\n      map.set(item.type.reference, item);\n    }\n  });\n  return Array.from(map.values());\n}\n\nfunction isEmptyExpression(ast) {\n  if (ast instanceof ASTWithSource) {\n    ast = ast.ast;\n  }\n\n  return ast instanceof EmptyExpr;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Parses string representation of a style and converts it into object literal.\n *\n * @param value string representation of style as used in the `style` attribute in HTML.\n *   Example: `color: red; height: auto`.\n * @returns An array of style property name and value pairs, e.g. `['color', 'red', 'height',\n * 'auto']`\n */\n\n\nfunction parse(value) {\n  // we use a string array here instead of a string map\n  // because a string-map is not guaranteed to retain the\n  // order of the entries whereas a string array can be\n  // constructed in a [key, value, key, value] format.\n  var styles = [];\n  var i = 0;\n  var parenDepth = 0;\n  var quote = 0\n  /* QuoteNone */\n  ;\n  var valueStart = 0;\n  var propStart = 0;\n  var currentProp = null;\n  var valueHasQuotes = false;\n\n  while (i < value.length) {\n    var token = value.charCodeAt(i++);\n\n    switch (token) {\n      case 40\n      /* OpenParen */\n      :\n        parenDepth++;\n        break;\n\n      case 41\n      /* CloseParen */\n      :\n        parenDepth--;\n        break;\n\n      case 39\n      /* QuoteSingle */\n      :\n        // valueStart needs to be there since prop values don't\n        // have quotes in CSS\n        valueHasQuotes = valueHasQuotes || valueStart > 0;\n\n        if (quote === 0\n        /* QuoteNone */\n        ) {\n            quote = 39\n            /* QuoteSingle */\n            ;\n          } else if (quote === 39\n        /* QuoteSingle */\n        && value.charCodeAt(i - 1) !== 92\n        /* BackSlash */\n        ) {\n            quote = 0\n            /* QuoteNone */\n            ;\n          }\n\n        break;\n\n      case 34\n      /* QuoteDouble */\n      :\n        // same logic as above\n        valueHasQuotes = valueHasQuotes || valueStart > 0;\n\n        if (quote === 0\n        /* QuoteNone */\n        ) {\n            quote = 34\n            /* QuoteDouble */\n            ;\n          } else if (quote === 34\n        /* QuoteDouble */\n        && value.charCodeAt(i - 1) !== 92\n        /* BackSlash */\n        ) {\n            quote = 0\n            /* QuoteNone */\n            ;\n          }\n\n        break;\n\n      case 58\n      /* Colon */\n      :\n        if (!currentProp && parenDepth === 0 && quote === 0\n        /* QuoteNone */\n        ) {\n            currentProp = hyphenate(value.substring(propStart, i - 1).trim());\n            valueStart = i;\n          }\n\n        break;\n\n      case 59\n      /* Semicolon */\n      :\n        if (currentProp && valueStart > 0 && parenDepth === 0 && quote === 0\n        /* QuoteNone */\n        ) {\n            var styleVal = value.substring(valueStart, i - 1).trim();\n            styles.push(currentProp, valueHasQuotes ? stripUnnecessaryQuotes(styleVal) : styleVal);\n            propStart = i;\n            valueStart = 0;\n            currentProp = null;\n            valueHasQuotes = false;\n          }\n\n        break;\n    }\n  }\n\n  if (currentProp && valueStart) {\n    var _styleVal = value.substr(valueStart).trim();\n\n    styles.push(currentProp, valueHasQuotes ? stripUnnecessaryQuotes(_styleVal) : _styleVal);\n  }\n\n  return styles;\n}\n\nfunction stripUnnecessaryQuotes(value) {\n  var qS = value.charCodeAt(0);\n  var qE = value.charCodeAt(value.length - 1);\n\n  if (qS == qE && (qS == 39\n  /* QuoteSingle */\n  || qS == 34\n  /* QuoteDouble */\n  )) {\n    var tempValue = value.substring(1, value.length - 1); // special case to avoid using a multi-quoted string that was just chomped\n    // (e.g. `font-family: \"Verdana\", \"sans-serif\"`)\n\n    if (tempValue.indexOf('\\'') == -1 && tempValue.indexOf('\"') == -1) {\n      value = tempValue;\n    }\n  }\n\n  return value;\n}\n\nfunction hyphenate(value) {\n  return value.replace(/[a-z][A-Z]/g, function (v) {\n    return v.charAt(0) + '-' + v.charAt(1);\n  }).toLowerCase();\n}\n\nvar IMPORTANT_FLAG = '!important';\n/**\n * Minimum amount of binding slots required in the runtime for style/class bindings.\n *\n * Styling in Angular uses up two slots in the runtime LView/TData data structures to\n * record binding data, property information and metadata.\n *\n * When a binding is registered it will place the following information in the `LView`:\n *\n * slot 1) binding value\n * slot 2) cached value (all other values collected before it in string form)\n *\n * When a binding is registered it will place the following information in the `TData`:\n *\n * slot 1) prop name\n * slot 2) binding index that points to the previous style/class binding (and some extra config\n * values)\n *\n * Let's imagine we have a binding that looks like so:\n *\n * ```\n * <div [style.width]=\"x\" [style.height]=\"y\">\n * ```\n *\n * Our `LView` and `TData` data-structures look like so:\n *\n * ```typescript\n * LView = [\n *   // ...\n *   x, // value of x\n *   \"width: x\",\n *\n *   y, // value of y\n *   \"width: x; height: y\",\n *   // ...\n * ];\n *\n * TData = [\n *   // ...\n *   \"width\", // binding slot 20\n *   0,\n *\n *   \"height\",\n *   20,\n *   // ...\n * ];\n * ```\n *\n * */\n\nvar MIN_STYLING_BINDING_SLOTS_REQUIRED = 2;\n/**\n * Produces creation/update instructions for all styling bindings (class and style)\n *\n * It also produces the creation instruction to register all initial styling values\n * (which are all the static class=\"...\" and style=\"...\" attribute values that exist\n * on an element within a template).\n *\n * The builder class below handles producing instructions for the following cases:\n *\n * - Static style/class attributes (style=\"...\" and class=\"...\")\n * - Dynamic style/class map bindings ([style]=\"map\" and [class]=\"map|string\")\n * - Dynamic style/class property bindings ([style.prop]=\"exp\" and [class.name]=\"exp\")\n *\n * Due to the complex relationship of all of these cases, the instructions generated\n * for these attributes/properties/bindings must be done so in the correct order. The\n * order which these must be generated is as follows:\n *\n * if (createMode) {\n *   styling(...)\n * }\n * if (updateMode) {\n *   styleMap(...)\n *   classMap(...)\n *   styleProp(...)\n *   classProp(...)\n * }\n *\n * The creation/update methods within the builder class produce these instructions.\n */\n\nvar StylingBuilder = /*#__PURE__*/function () {\n  function StylingBuilder(_directiveExpr) {\n    _classCallCheck(this, StylingBuilder);\n\n    this._directiveExpr = _directiveExpr;\n    /** Whether or not there are any static styling values present */\n\n    this._hasInitialValues = false;\n    /**\n     *  Whether or not there are any styling bindings present\n     *  (i.e. `[style]`, `[class]`, `[style.prop]` or `[class.name]`)\n     */\n\n    this.hasBindings = false;\n    this.hasBindingsWithPipes = false;\n    /** the input for [class] (if it exists) */\n\n    this._classMapInput = null;\n    /** the input for [style] (if it exists) */\n\n    this._styleMapInput = null;\n    /** an array of each [style.prop] input */\n\n    this._singleStyleInputs = null;\n    /** an array of each [class.name] input */\n\n    this._singleClassInputs = null;\n    this._lastStylingInput = null;\n    this._firstStylingInput = null; // maps are used instead of hash maps because a Map will\n    // retain the ordering of the keys\n\n    /**\n     * Represents the location of each style binding in the template\n     * (e.g. `<div [style.width]=\"w\" [style.height]=\"h\">` implies\n     * that `width=0` and `height=1`)\n     */\n\n    this._stylesIndex = new Map();\n    /**\n     * Represents the location of each class binding in the template\n     * (e.g. `<div [class.big]=\"b\" [class.hidden]=\"h\">` implies\n     * that `big=0` and `hidden=1`)\n     */\n\n    this._classesIndex = new Map();\n    this._initialStyleValues = [];\n    this._initialClassValues = [];\n  }\n  /**\n   * Registers a given input to the styling builder to be later used when producing AOT code.\n   *\n   * The code below will only accept the input if it is somehow tied to styling (whether it be\n   * style/class bindings or static style/class attributes).\n   */\n\n\n  _createClass(StylingBuilder, [{\n    key: \"registerBoundInput\",\n    value: function registerBoundInput(input) {\n      // [attr.style] or [attr.class] are skipped in the code below,\n      // they should not be treated as styling-based bindings since\n      // they are intended to be written directly to the attr and\n      // will therefore skip all style/class resolution that is present\n      // with style=\"\", [style]=\"\" and [style.prop]=\"\", class=\"\",\n      // [class.prop]=\"\". [class]=\"\" assignments\n      var binding = null;\n      var name = input.name;\n\n      switch (input.type) {\n        case 0\n        /* Property */\n        :\n          binding = this.registerInputBasedOnName(name, input.value, input.sourceSpan);\n          break;\n\n        case 3\n        /* Style */\n        :\n          binding = this.registerStyleInput(name, false, input.value, input.sourceSpan, input.unit);\n          break;\n\n        case 2\n        /* Class */\n        :\n          binding = this.registerClassInput(name, false, input.value, input.sourceSpan);\n          break;\n      }\n\n      return binding ? true : false;\n    }\n  }, {\n    key: \"registerInputBasedOnName\",\n    value: function registerInputBasedOnName(name, expression, sourceSpan) {\n      var binding = null;\n      var prefix = name.substring(0, 6);\n      var isStyle = name === 'style' || prefix === 'style.' || prefix === 'style!';\n      var isClass = !isStyle && (name === 'class' || prefix === 'class.' || prefix === 'class!');\n\n      if (isStyle || isClass) {\n        var isMapBased = name.charAt(5) !== '.'; // style.prop or class.prop makes this a no\n\n        var property = name.substr(isMapBased ? 5 : 6); // the dot explains why there's a +1\n\n        if (isStyle) {\n          binding = this.registerStyleInput(property, isMapBased, expression, sourceSpan);\n        } else {\n          binding = this.registerClassInput(property, isMapBased, expression, sourceSpan);\n        }\n      }\n\n      return binding;\n    }\n  }, {\n    key: \"registerStyleInput\",\n    value: function registerStyleInput(name, isMapBased, value, sourceSpan, suffix) {\n      if (isEmptyExpression(value)) {\n        return null;\n      }\n\n      name = normalizePropName(name);\n\n      var _parseProperty = parseProperty(name),\n          property = _parseProperty.property,\n          hasOverrideFlag = _parseProperty.hasOverrideFlag,\n          bindingSuffix = _parseProperty.suffix;\n\n      suffix = typeof suffix === 'string' && suffix.length !== 0 ? suffix : bindingSuffix;\n      var entry = {\n        name: property,\n        suffix: suffix,\n        value: value,\n        sourceSpan: sourceSpan,\n        hasOverrideFlag: hasOverrideFlag\n      };\n\n      if (isMapBased) {\n        this._styleMapInput = entry;\n      } else {\n        (this._singleStyleInputs = this._singleStyleInputs || []).push(entry);\n        registerIntoMap(this._stylesIndex, property);\n      }\n\n      this._lastStylingInput = entry;\n      this._firstStylingInput = this._firstStylingInput || entry;\n\n      this._checkForPipes(value);\n\n      this.hasBindings = true;\n      return entry;\n    }\n  }, {\n    key: \"registerClassInput\",\n    value: function registerClassInput(name, isMapBased, value, sourceSpan) {\n      if (isEmptyExpression(value)) {\n        return null;\n      }\n\n      var _parseProperty2 = parseProperty(name),\n          property = _parseProperty2.property,\n          hasOverrideFlag = _parseProperty2.hasOverrideFlag;\n\n      var entry = {\n        name: property,\n        value: value,\n        sourceSpan: sourceSpan,\n        hasOverrideFlag: hasOverrideFlag,\n        suffix: null\n      };\n\n      if (isMapBased) {\n        if (this._classMapInput) {\n          throw new Error('[class] and [className] bindings cannot be used on the same element simultaneously');\n        }\n\n        this._classMapInput = entry;\n      } else {\n        (this._singleClassInputs = this._singleClassInputs || []).push(entry);\n        registerIntoMap(this._classesIndex, property);\n      }\n\n      this._lastStylingInput = entry;\n      this._firstStylingInput = this._firstStylingInput || entry;\n\n      this._checkForPipes(value);\n\n      this.hasBindings = true;\n      return entry;\n    }\n  }, {\n    key: \"_checkForPipes\",\n    value: function _checkForPipes(value) {\n      if (value instanceof ASTWithSource && value.ast instanceof BindingPipe) {\n        this.hasBindingsWithPipes = true;\n      }\n    }\n    /**\n     * Registers the element's static style string value to the builder.\n     *\n     * @param value the style string (e.g. `width:100px; height:200px;`)\n     */\n\n  }, {\n    key: \"registerStyleAttr\",\n    value: function registerStyleAttr(value) {\n      this._initialStyleValues = parse(value);\n      this._hasInitialValues = true;\n    }\n    /**\n     * Registers the element's static class string value to the builder.\n     *\n     * @param value the className string (e.g. `disabled gold zoom`)\n     */\n\n  }, {\n    key: \"registerClassAttr\",\n    value: function registerClassAttr(value) {\n      this._initialClassValues = value.trim().split(/\\s+/g);\n      this._hasInitialValues = true;\n    }\n    /**\n     * Appends all styling-related expressions to the provided attrs array.\n     *\n     * @param attrs an existing array where each of the styling expressions\n     * will be inserted into.\n     */\n\n  }, {\n    key: \"populateInitialStylingAttrs\",\n    value: function populateInitialStylingAttrs(attrs) {\n      // [CLASS_MARKER, 'foo', 'bar', 'baz' ...]\n      if (this._initialClassValues.length) {\n        attrs.push(literal(1\n        /* Classes */\n        ));\n\n        for (var i = 0; i < this._initialClassValues.length; i++) {\n          attrs.push(literal(this._initialClassValues[i]));\n        }\n      } // [STYLE_MARKER, 'width', '200px', 'height', '100px', ...]\n\n\n      if (this._initialStyleValues.length) {\n        attrs.push(literal(2\n        /* Styles */\n        ));\n\n        for (var _i6 = 0; _i6 < this._initialStyleValues.length; _i6 += 2) {\n          attrs.push(literal(this._initialStyleValues[_i6]), literal(this._initialStyleValues[_i6 + 1]));\n        }\n      }\n    }\n    /**\n     * Builds an instruction with all the expressions and parameters for `elementHostAttrs`.\n     *\n     * The instruction generation code below is used for producing the AOT statement code which is\n     * responsible for registering initial styles (within a directive hostBindings' creation block),\n     * as well as any of the provided attribute values, to the directive host element.\n     */\n\n  }, {\n    key: \"assignHostAttrs\",\n    value: function assignHostAttrs(attrs, definitionMap) {\n      if (this._directiveExpr && (attrs.length || this._hasInitialValues)) {\n        this.populateInitialStylingAttrs(attrs);\n        definitionMap.set('hostAttrs', literalArr(attrs));\n      }\n    }\n    /**\n     * Builds an instruction with all the expressions and parameters for `classMap`.\n     *\n     * The instruction data will contain all expressions for `classMap` to function\n     * which includes the `[class]` expression params.\n     */\n\n  }, {\n    key: \"buildClassMapInstruction\",\n    value: function buildClassMapInstruction(valueConverter) {\n      if (this._classMapInput) {\n        return this._buildMapBasedInstruction(valueConverter, true, this._classMapInput);\n      }\n\n      return null;\n    }\n    /**\n     * Builds an instruction with all the expressions and parameters for `styleMap`.\n     *\n     * The instruction data will contain all expressions for `styleMap` to function\n     * which includes the `[style]` expression params.\n     */\n\n  }, {\n    key: \"buildStyleMapInstruction\",\n    value: function buildStyleMapInstruction(valueConverter) {\n      if (this._styleMapInput) {\n        return this._buildMapBasedInstruction(valueConverter, false, this._styleMapInput);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_buildMapBasedInstruction\",\n    value: function _buildMapBasedInstruction(valueConverter, isClassBased, stylingInput) {\n      // each styling binding value is stored in the LView\n      // map-based bindings allocate two slots: one for the\n      // previous binding value and another for the previous\n      // className or style attribute value.\n      var totalBindingSlotsRequired = MIN_STYLING_BINDING_SLOTS_REQUIRED; // these values must be outside of the update block so that they can\n      // be evaluated (the AST visit call) during creation time so that any\n      // pipes can be picked up in time before the template is built\n\n      var mapValue = stylingInput.value.visit(valueConverter);\n      var reference;\n\n      if (mapValue instanceof Interpolation) {\n        totalBindingSlotsRequired += mapValue.expressions.length;\n        reference = isClassBased ? getClassMapInterpolationExpression(mapValue) : getStyleMapInterpolationExpression(mapValue);\n      } else {\n        reference = isClassBased ? Identifiers$1.classMap : Identifiers$1.styleMap;\n      }\n\n      return {\n        reference: reference,\n        calls: [{\n          supportsInterpolation: true,\n          sourceSpan: stylingInput.sourceSpan,\n          allocateBindingSlots: totalBindingSlotsRequired,\n          params: function params(convertFn) {\n            var convertResult = convertFn(mapValue);\n            var params = Array.isArray(convertResult) ? convertResult : [convertResult];\n            return params;\n          }\n        }]\n      };\n    }\n  }, {\n    key: \"_buildSingleInputs\",\n    value: function _buildSingleInputs(reference, inputs, valueConverter, getInterpolationExpressionFn, isClassBased) {\n      var instructions = [];\n      inputs.forEach(function (input) {\n        var previousInstruction = instructions[instructions.length - 1];\n        var value = input.value.visit(valueConverter);\n        var referenceForCall = reference; // each styling binding value is stored in the LView\n        // but there are two values stored for each binding:\n        //   1) the value itself\n        //   2) an intermediate value (concatenation of style up to this point).\n        //      We need to store the intermediate value so that we don't allocate\n        //      the strings on each CD.\n\n        var totalBindingSlotsRequired = MIN_STYLING_BINDING_SLOTS_REQUIRED;\n\n        if (value instanceof Interpolation) {\n          totalBindingSlotsRequired += value.expressions.length;\n\n          if (getInterpolationExpressionFn) {\n            referenceForCall = getInterpolationExpressionFn(value);\n          }\n        }\n\n        var call = {\n          sourceSpan: input.sourceSpan,\n          allocateBindingSlots: totalBindingSlotsRequired,\n          supportsInterpolation: !!getInterpolationExpressionFn,\n          params: function params(convertFn) {\n            // params => stylingProp(propName, value, suffix)\n            var params = [];\n            params.push(literal(input.name));\n            var convertResult = convertFn(value);\n\n            if (Array.isArray(convertResult)) {\n              params.push.apply(params, _toConsumableArray(convertResult));\n            } else {\n              params.push(convertResult);\n            } // [style.prop] bindings may use suffix values (e.g. px, em, etc...), therefore,\n            // if that is detected then we need to pass that in as an optional param.\n\n\n            if (!isClassBased && input.suffix !== null) {\n              params.push(literal(input.suffix));\n            }\n\n            return params;\n          }\n        }; // If we ended up generating a call to the same instruction as the previous styling property\n        // we can chain the calls together safely to save some bytes, otherwise we have to generate\n        // a separate instruction call. This is primarily a concern with interpolation instructions\n        // where we may start off with one `reference`, but end up using another based on the\n        // number of interpolations.\n\n        if (previousInstruction && previousInstruction.reference === referenceForCall) {\n          previousInstruction.calls.push(call);\n        } else {\n          instructions.push({\n            reference: referenceForCall,\n            calls: [call]\n          });\n        }\n      });\n      return instructions;\n    }\n  }, {\n    key: \"_buildClassInputs\",\n    value: function _buildClassInputs(valueConverter) {\n      if (this._singleClassInputs) {\n        return this._buildSingleInputs(Identifiers$1.classProp, this._singleClassInputs, valueConverter, null, true);\n      }\n\n      return [];\n    }\n  }, {\n    key: \"_buildStyleInputs\",\n    value: function _buildStyleInputs(valueConverter) {\n      if (this._singleStyleInputs) {\n        return this._buildSingleInputs(Identifiers$1.styleProp, this._singleStyleInputs, valueConverter, getStylePropInterpolationExpression, false);\n      }\n\n      return [];\n    }\n    /**\n     * Constructs all instructions which contain the expressions that will be placed\n     * into the update block of a template function or a directive hostBindings function.\n     */\n\n  }, {\n    key: \"buildUpdateLevelInstructions\",\n    value: function buildUpdateLevelInstructions(valueConverter) {\n      var instructions = [];\n\n      if (this.hasBindings) {\n        var styleMapInstruction = this.buildStyleMapInstruction(valueConverter);\n\n        if (styleMapInstruction) {\n          instructions.push(styleMapInstruction);\n        }\n\n        var classMapInstruction = this.buildClassMapInstruction(valueConverter);\n\n        if (classMapInstruction) {\n          instructions.push(classMapInstruction);\n        }\n\n        instructions.push.apply(instructions, _toConsumableArray(this._buildStyleInputs(valueConverter)));\n        instructions.push.apply(instructions, _toConsumableArray(this._buildClassInputs(valueConverter)));\n      }\n\n      return instructions;\n    }\n  }]);\n\n  return StylingBuilder;\n}();\n\nfunction registerIntoMap(map, key) {\n  if (!map.has(key)) {\n    map.set(key, map.size);\n  }\n}\n\nfunction parseProperty(name) {\n  var hasOverrideFlag = false;\n  var overrideIndex = name.indexOf(IMPORTANT_FLAG);\n\n  if (overrideIndex !== -1) {\n    name = overrideIndex > 0 ? name.substring(0, overrideIndex) : '';\n    hasOverrideFlag = true;\n  }\n\n  var suffix = null;\n  var property = name;\n  var unitIndex = name.lastIndexOf('.');\n\n  if (unitIndex > 0) {\n    suffix = name.substr(unitIndex + 1);\n    property = name.substring(0, unitIndex);\n  }\n\n  return {\n    property: property,\n    suffix: suffix,\n    hasOverrideFlag: hasOverrideFlag\n  };\n}\n/**\n * Gets the instruction to generate for an interpolated class map.\n * @param interpolation An Interpolation AST\n */\n\n\nfunction getClassMapInterpolationExpression(interpolation) {\n  switch (getInterpolationArgsLength(interpolation)) {\n    case 1:\n      return Identifiers$1.classMap;\n\n    case 3:\n      return Identifiers$1.classMapInterpolate1;\n\n    case 5:\n      return Identifiers$1.classMapInterpolate2;\n\n    case 7:\n      return Identifiers$1.classMapInterpolate3;\n\n    case 9:\n      return Identifiers$1.classMapInterpolate4;\n\n    case 11:\n      return Identifiers$1.classMapInterpolate5;\n\n    case 13:\n      return Identifiers$1.classMapInterpolate6;\n\n    case 15:\n      return Identifiers$1.classMapInterpolate7;\n\n    case 17:\n      return Identifiers$1.classMapInterpolate8;\n\n    default:\n      return Identifiers$1.classMapInterpolateV;\n  }\n}\n/**\n * Gets the instruction to generate for an interpolated style map.\n * @param interpolation An Interpolation AST\n */\n\n\nfunction getStyleMapInterpolationExpression(interpolation) {\n  switch (getInterpolationArgsLength(interpolation)) {\n    case 1:\n      return Identifiers$1.styleMap;\n\n    case 3:\n      return Identifiers$1.styleMapInterpolate1;\n\n    case 5:\n      return Identifiers$1.styleMapInterpolate2;\n\n    case 7:\n      return Identifiers$1.styleMapInterpolate3;\n\n    case 9:\n      return Identifiers$1.styleMapInterpolate4;\n\n    case 11:\n      return Identifiers$1.styleMapInterpolate5;\n\n    case 13:\n      return Identifiers$1.styleMapInterpolate6;\n\n    case 15:\n      return Identifiers$1.styleMapInterpolate7;\n\n    case 17:\n      return Identifiers$1.styleMapInterpolate8;\n\n    default:\n      return Identifiers$1.styleMapInterpolateV;\n  }\n}\n/**\n * Gets the instruction to generate for an interpolated style prop.\n * @param interpolation An Interpolation AST\n */\n\n\nfunction getStylePropInterpolationExpression(interpolation) {\n  switch (getInterpolationArgsLength(interpolation)) {\n    case 1:\n      return Identifiers$1.styleProp;\n\n    case 3:\n      return Identifiers$1.stylePropInterpolate1;\n\n    case 5:\n      return Identifiers$1.stylePropInterpolate2;\n\n    case 7:\n      return Identifiers$1.stylePropInterpolate3;\n\n    case 9:\n      return Identifiers$1.stylePropInterpolate4;\n\n    case 11:\n      return Identifiers$1.stylePropInterpolate5;\n\n    case 13:\n      return Identifiers$1.stylePropInterpolate6;\n\n    case 15:\n      return Identifiers$1.stylePropInterpolate7;\n\n    case 17:\n      return Identifiers$1.stylePropInterpolate8;\n\n    default:\n      return Identifiers$1.stylePropInterpolateV;\n  }\n}\n\nfunction normalizePropName(prop) {\n  return hyphenate(prop);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar TokenType$1;\n\n(function (TokenType) {\n  TokenType[TokenType[\"Character\"] = 0] = \"Character\";\n  TokenType[TokenType[\"Identifier\"] = 1] = \"Identifier\";\n  TokenType[TokenType[\"Keyword\"] = 2] = \"Keyword\";\n  TokenType[TokenType[\"String\"] = 3] = \"String\";\n  TokenType[TokenType[\"Operator\"] = 4] = \"Operator\";\n  TokenType[TokenType[\"Number\"] = 5] = \"Number\";\n  TokenType[TokenType[\"Error\"] = 6] = \"Error\";\n})(TokenType$1 || (TokenType$1 = {}));\n\nvar KEYWORDS = ['var', 'let', 'as', 'null', 'undefined', 'true', 'false', 'if', 'else', 'this'];\n\nvar Lexer = /*#__PURE__*/function () {\n  function Lexer() {\n    _classCallCheck(this, Lexer);\n  }\n\n  _createClass(Lexer, [{\n    key: \"tokenize\",\n    value: function tokenize(text) {\n      var scanner = new _Scanner(text);\n      var tokens = [];\n      var token = scanner.scanToken();\n\n      while (token != null) {\n        tokens.push(token);\n        token = scanner.scanToken();\n      }\n\n      return tokens;\n    }\n  }]);\n\n  return Lexer;\n}();\n\nvar Token$1 = /*#__PURE__*/function () {\n  function Token$1(index, end, type, numValue, strValue) {\n    _classCallCheck(this, Token$1);\n\n    this.index = index;\n    this.end = end;\n    this.type = type;\n    this.numValue = numValue;\n    this.strValue = strValue;\n  }\n\n  _createClass(Token$1, [{\n    key: \"isCharacter\",\n    value: function isCharacter(code) {\n      return this.type == TokenType$1.Character && this.numValue == code;\n    }\n  }, {\n    key: \"isNumber\",\n    value: function isNumber() {\n      return this.type == TokenType$1.Number;\n    }\n  }, {\n    key: \"isString\",\n    value: function isString() {\n      return this.type == TokenType$1.String;\n    }\n  }, {\n    key: \"isOperator\",\n    value: function isOperator(operator) {\n      return this.type == TokenType$1.Operator && this.strValue == operator;\n    }\n  }, {\n    key: \"isIdentifier\",\n    value: function isIdentifier() {\n      return this.type == TokenType$1.Identifier;\n    }\n  }, {\n    key: \"isKeyword\",\n    value: function isKeyword() {\n      return this.type == TokenType$1.Keyword;\n    }\n  }, {\n    key: \"isKeywordLet\",\n    value: function isKeywordLet() {\n      return this.type == TokenType$1.Keyword && this.strValue == 'let';\n    }\n  }, {\n    key: \"isKeywordAs\",\n    value: function isKeywordAs() {\n      return this.type == TokenType$1.Keyword && this.strValue == 'as';\n    }\n  }, {\n    key: \"isKeywordNull\",\n    value: function isKeywordNull() {\n      return this.type == TokenType$1.Keyword && this.strValue == 'null';\n    }\n  }, {\n    key: \"isKeywordUndefined\",\n    value: function isKeywordUndefined() {\n      return this.type == TokenType$1.Keyword && this.strValue == 'undefined';\n    }\n  }, {\n    key: \"isKeywordTrue\",\n    value: function isKeywordTrue() {\n      return this.type == TokenType$1.Keyword && this.strValue == 'true';\n    }\n  }, {\n    key: \"isKeywordFalse\",\n    value: function isKeywordFalse() {\n      return this.type == TokenType$1.Keyword && this.strValue == 'false';\n    }\n  }, {\n    key: \"isKeywordThis\",\n    value: function isKeywordThis() {\n      return this.type == TokenType$1.Keyword && this.strValue == 'this';\n    }\n  }, {\n    key: \"isError\",\n    value: function isError() {\n      return this.type == TokenType$1.Error;\n    }\n  }, {\n    key: \"toNumber\",\n    value: function toNumber() {\n      return this.type == TokenType$1.Number ? this.numValue : -1;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      switch (this.type) {\n        case TokenType$1.Character:\n        case TokenType$1.Identifier:\n        case TokenType$1.Keyword:\n        case TokenType$1.Operator:\n        case TokenType$1.String:\n        case TokenType$1.Error:\n          return this.strValue;\n\n        case TokenType$1.Number:\n          return this.numValue.toString();\n\n        default:\n          return null;\n      }\n    }\n  }]);\n\n  return Token$1;\n}();\n\nfunction newCharacterToken(index, end, code) {\n  return new Token$1(index, end, TokenType$1.Character, code, String.fromCharCode(code));\n}\n\nfunction newIdentifierToken(index, end, text) {\n  return new Token$1(index, end, TokenType$1.Identifier, 0, text);\n}\n\nfunction newKeywordToken(index, end, text) {\n  return new Token$1(index, end, TokenType$1.Keyword, 0, text);\n}\n\nfunction newOperatorToken(index, end, text) {\n  return new Token$1(index, end, TokenType$1.Operator, 0, text);\n}\n\nfunction newStringToken(index, end, text) {\n  return new Token$1(index, end, TokenType$1.String, 0, text);\n}\n\nfunction newNumberToken(index, end, n) {\n  return new Token$1(index, end, TokenType$1.Number, n, '');\n}\n\nfunction newErrorToken(index, end, message) {\n  return new Token$1(index, end, TokenType$1.Error, 0, message);\n}\n\nvar EOF = new Token$1(-1, -1, TokenType$1.Character, 0, '');\n\nvar _Scanner = /*#__PURE__*/function () {\n  function _Scanner(input) {\n    _classCallCheck(this, _Scanner);\n\n    this.input = input;\n    this.peek = 0;\n    this.index = -1;\n    this.length = input.length;\n    this.advance();\n  }\n\n  _createClass(_Scanner, [{\n    key: \"advance\",\n    value: function advance() {\n      this.peek = ++this.index >= this.length ? $EOF : this.input.charCodeAt(this.index);\n    }\n  }, {\n    key: \"scanToken\",\n    value: function scanToken() {\n      var input = this.input,\n          length = this.length;\n      var peek = this.peek,\n          index = this.index; // Skip whitespace.\n\n      while (peek <= $SPACE) {\n        if (++index >= length) {\n          peek = $EOF;\n          break;\n        } else {\n          peek = input.charCodeAt(index);\n        }\n      }\n\n      this.peek = peek;\n      this.index = index;\n\n      if (index >= length) {\n        return null;\n      } // Handle identifiers and numbers.\n\n\n      if (isIdentifierStart(peek)) return this.scanIdentifier();\n      if (isDigit(peek)) return this.scanNumber(index);\n      var start = index;\n\n      switch (peek) {\n        case $PERIOD:\n          this.advance();\n          return isDigit(this.peek) ? this.scanNumber(start) : newCharacterToken(start, this.index, $PERIOD);\n\n        case $LPAREN:\n        case $RPAREN:\n        case $LBRACE:\n        case $RBRACE:\n        case $LBRACKET:\n        case $RBRACKET:\n        case $COMMA:\n        case $COLON:\n        case $SEMICOLON:\n          return this.scanCharacter(start, peek);\n\n        case $SQ:\n        case $DQ:\n          return this.scanString();\n\n        case $HASH:\n        case $PLUS:\n        case $MINUS:\n        case $STAR:\n        case $SLASH:\n        case $PERCENT:\n        case $CARET:\n          return this.scanOperator(start, String.fromCharCode(peek));\n\n        case $QUESTION:\n          return this.scanComplexOperator(start, '?', $PERIOD, '.');\n\n        case $LT:\n        case $GT:\n          return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=');\n\n        case $BANG:\n        case $EQ:\n          return this.scanComplexOperator(start, String.fromCharCode(peek), $EQ, '=', $EQ, '=');\n\n        case $AMPERSAND:\n          return this.scanComplexOperator(start, '&', $AMPERSAND, '&');\n\n        case $BAR:\n          return this.scanComplexOperator(start, '|', $BAR, '|');\n\n        case $NBSP:\n          while (isWhitespace(this.peek)) {\n            this.advance();\n          }\n\n          return this.scanToken();\n      }\n\n      this.advance();\n      return this.error(\"Unexpected character [\".concat(String.fromCharCode(peek), \"]\"), 0);\n    }\n  }, {\n    key: \"scanCharacter\",\n    value: function scanCharacter(start, code) {\n      this.advance();\n      return newCharacterToken(start, this.index, code);\n    }\n  }, {\n    key: \"scanOperator\",\n    value: function scanOperator(start, str) {\n      this.advance();\n      return newOperatorToken(start, this.index, str);\n    }\n    /**\n     * Tokenize a 2/3 char long operator\n     *\n     * @param start start index in the expression\n     * @param one first symbol (always part of the operator)\n     * @param twoCode code point for the second symbol\n     * @param two second symbol (part of the operator when the second code point matches)\n     * @param threeCode code point for the third symbol\n     * @param three third symbol (part of the operator when provided and matches source expression)\n     */\n\n  }, {\n    key: \"scanComplexOperator\",\n    value: function scanComplexOperator(start, one, twoCode, two, threeCode, three) {\n      this.advance();\n      var str = one;\n\n      if (this.peek == twoCode) {\n        this.advance();\n        str += two;\n      }\n\n      if (threeCode != null && this.peek == threeCode) {\n        this.advance();\n        str += three;\n      }\n\n      return newOperatorToken(start, this.index, str);\n    }\n  }, {\n    key: \"scanIdentifier\",\n    value: function scanIdentifier() {\n      var start = this.index;\n      this.advance();\n\n      while (isIdentifierPart(this.peek)) {\n        this.advance();\n      }\n\n      var str = this.input.substring(start, this.index);\n      return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, this.index, str) : newIdentifierToken(start, this.index, str);\n    }\n  }, {\n    key: \"scanNumber\",\n    value: function scanNumber(start) {\n      var simple = this.index === start;\n      this.advance(); // Skip initial digit.\n\n      while (true) {\n        if (isDigit(this.peek)) {// Do nothing.\n        } else if (this.peek == $PERIOD) {\n          simple = false;\n        } else if (isExponentStart(this.peek)) {\n          this.advance();\n          if (isExponentSign(this.peek)) this.advance();\n          if (!isDigit(this.peek)) return this.error('Invalid exponent', -1);\n          simple = false;\n        } else {\n          break;\n        }\n\n        this.advance();\n      }\n\n      var str = this.input.substring(start, this.index);\n      var value = simple ? parseIntAutoRadix(str) : parseFloat(str);\n      return newNumberToken(start, this.index, value);\n    }\n  }, {\n    key: \"scanString\",\n    value: function scanString() {\n      var start = this.index;\n      var quote = this.peek;\n      this.advance(); // Skip initial quote.\n\n      var buffer = '';\n      var marker = this.index;\n      var input = this.input;\n\n      while (this.peek != quote) {\n        if (this.peek == $BACKSLASH) {\n          buffer += input.substring(marker, this.index);\n          this.advance();\n          var unescapedCode = void 0; // Workaround for TS2.1-introduced type strictness\n\n          this.peek = this.peek;\n\n          if (this.peek == $u) {\n            // 4 character hex code for unicode character.\n            var hex = input.substring(this.index + 1, this.index + 5);\n\n            if (/^[0-9a-f]+$/i.test(hex)) {\n              unescapedCode = parseInt(hex, 16);\n            } else {\n              return this.error(\"Invalid unicode escape [\\\\u\".concat(hex, \"]\"), 0);\n            }\n\n            for (var i = 0; i < 5; i++) {\n              this.advance();\n            }\n          } else {\n            unescapedCode = unescape(this.peek);\n            this.advance();\n          }\n\n          buffer += String.fromCharCode(unescapedCode);\n          marker = this.index;\n        } else if (this.peek == $EOF) {\n          return this.error('Unterminated quote', 0);\n        } else {\n          this.advance();\n        }\n      }\n\n      var last = input.substring(marker, this.index);\n      this.advance(); // Skip terminating quote.\n\n      return newStringToken(start, this.index, buffer + last);\n    }\n  }, {\n    key: \"error\",\n    value: function error(message, offset) {\n      var position = this.index + offset;\n      return newErrorToken(position, this.index, \"Lexer Error: \".concat(message, \" at column \").concat(position, \" in expression [\").concat(this.input, \"]\"));\n    }\n  }]);\n\n  return _Scanner;\n}();\n\nfunction isIdentifierStart(code) {\n  return $a <= code && code <= $z || $A <= code && code <= $Z || code == $_ || code == $$;\n}\n\nfunction isIdentifier(input) {\n  if (input.length == 0) return false;\n  var scanner = new _Scanner(input);\n  if (!isIdentifierStart(scanner.peek)) return false;\n  scanner.advance();\n\n  while (scanner.peek !== $EOF) {\n    if (!isIdentifierPart(scanner.peek)) return false;\n    scanner.advance();\n  }\n\n  return true;\n}\n\nfunction isIdentifierPart(code) {\n  return isAsciiLetter(code) || isDigit(code) || code == $_ || code == $$;\n}\n\nfunction isExponentStart(code) {\n  return code == $e || code == $E;\n}\n\nfunction isExponentSign(code) {\n  return code == $MINUS || code == $PLUS;\n}\n\nfunction isQuote(code) {\n  return code === $SQ || code === $DQ || code === $BT;\n}\n\nfunction unescape(code) {\n  switch (code) {\n    case $n:\n      return $LF;\n\n    case $f:\n      return $FF;\n\n    case $r:\n      return $CR;\n\n    case $t:\n      return $TAB;\n\n    case $v:\n      return $VTAB;\n\n    default:\n      return code;\n  }\n}\n\nfunction parseIntAutoRadix(text) {\n  var result = parseInt(text);\n\n  if (isNaN(result)) {\n    throw new Error('Invalid integer literal when parsing ' + text);\n  }\n\n  return result;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar SplitInterpolation = function SplitInterpolation(strings, expressions, offsets) {\n  _classCallCheck(this, SplitInterpolation);\n\n  this.strings = strings;\n  this.expressions = expressions;\n  this.offsets = offsets;\n};\n\nvar TemplateBindingParseResult = function TemplateBindingParseResult(templateBindings, warnings, errors) {\n  _classCallCheck(this, TemplateBindingParseResult);\n\n  this.templateBindings = templateBindings;\n  this.warnings = warnings;\n  this.errors = errors;\n};\n\nvar defaultInterpolateRegExp = _createInterpolateRegExp(DEFAULT_INTERPOLATION_CONFIG);\n\nfunction _getInterpolateRegExp(config) {\n  if (config === DEFAULT_INTERPOLATION_CONFIG) {\n    return defaultInterpolateRegExp;\n  } else {\n    return _createInterpolateRegExp(config);\n  }\n}\n\nfunction _createInterpolateRegExp(config) {\n  var pattern = escapeRegExp(config.start) + '([\\\\s\\\\S]*?)' + escapeRegExp(config.end);\n  return new RegExp(pattern, 'g');\n}\n\nvar Parser$1 = /*#__PURE__*/function () {\n  function Parser$1(_lexer) {\n    _classCallCheck(this, Parser$1);\n\n    this._lexer = _lexer;\n    this.errors = [];\n    this.simpleExpressionChecker = SimpleExpressionChecker;\n  }\n\n  _createClass(Parser$1, [{\n    key: \"parseAction\",\n    value: function parseAction(input, location, absoluteOffset) {\n      var interpolationConfig = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_INTERPOLATION_CONFIG;\n\n      this._checkNoInterpolation(input, location, interpolationConfig);\n\n      var sourceToLex = this._stripComments(input);\n\n      var tokens = this._lexer.tokenize(this._stripComments(input));\n\n      var ast = new _ParseAST(input, location, absoluteOffset, tokens, sourceToLex.length, true, this.errors, input.length - sourceToLex.length).parseChain();\n      return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);\n    }\n  }, {\n    key: \"parseBinding\",\n    value: function parseBinding(input, location, absoluteOffset) {\n      var interpolationConfig = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_INTERPOLATION_CONFIG;\n\n      var ast = this._parseBindingAst(input, location, absoluteOffset, interpolationConfig);\n\n      return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);\n    }\n  }, {\n    key: \"checkSimpleExpression\",\n    value: function checkSimpleExpression(ast) {\n      var checker = new this.simpleExpressionChecker();\n      ast.visit(checker);\n      return checker.errors;\n    }\n  }, {\n    key: \"parseSimpleBinding\",\n    value: function parseSimpleBinding(input, location, absoluteOffset) {\n      var interpolationConfig = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_INTERPOLATION_CONFIG;\n\n      var ast = this._parseBindingAst(input, location, absoluteOffset, interpolationConfig);\n\n      var errors = this.checkSimpleExpression(ast);\n\n      if (errors.length > 0) {\n        this._reportError(\"Host binding expression cannot contain \".concat(errors.join(' ')), input, location);\n      }\n\n      return new ASTWithSource(ast, input, location, absoluteOffset, this.errors);\n    }\n  }, {\n    key: \"_reportError\",\n    value: function _reportError(message, input, errLocation, ctxLocation) {\n      this.errors.push(new ParserError(message, input, errLocation, ctxLocation));\n    }\n  }, {\n    key: \"_parseBindingAst\",\n    value: function _parseBindingAst(input, location, absoluteOffset, interpolationConfig) {\n      // Quotes expressions use 3rd-party expression language. We don't want to use\n      // our lexer or parser for that, so we check for that ahead of time.\n      var quote = this._parseQuote(input, location, absoluteOffset);\n\n      if (quote != null) {\n        return quote;\n      }\n\n      this._checkNoInterpolation(input, location, interpolationConfig);\n\n      var sourceToLex = this._stripComments(input);\n\n      var tokens = this._lexer.tokenize(sourceToLex);\n\n      return new _ParseAST(input, location, absoluteOffset, tokens, sourceToLex.length, false, this.errors, input.length - sourceToLex.length).parseChain();\n    }\n  }, {\n    key: \"_parseQuote\",\n    value: function _parseQuote(input, location, absoluteOffset) {\n      if (input == null) return null;\n      var prefixSeparatorIndex = input.indexOf(':');\n      if (prefixSeparatorIndex == -1) return null;\n      var prefix = input.substring(0, prefixSeparatorIndex).trim();\n      if (!isIdentifier(prefix)) return null;\n      var uninterpretedExpression = input.substring(prefixSeparatorIndex + 1);\n      var span = new ParseSpan(0, input.length);\n      return new Quote(span, span.toAbsolute(absoluteOffset), prefix, uninterpretedExpression, location);\n    }\n    /**\n     * Parse microsyntax template expression and return a list of bindings or\n     * parsing errors in case the given expression is invalid.\n     *\n     * For example,\n     * ```\n     *   <div *ngFor=\"let item of items\">\n     *         ^      ^ absoluteValueOffset for `templateValue`\n     *         absoluteKeyOffset for `templateKey`\n     * ```\n     * contains three bindings:\n     * 1. ngFor -> null\n     * 2. item -> NgForOfContext.$implicit\n     * 3. ngForOf -> items\n     *\n     * This is apparent from the de-sugared template:\n     * ```\n     *   <ng-template ngFor let-item [ngForOf]=\"items\">\n     * ```\n     *\n     * @param templateKey name of directive, without the * prefix. For example: ngIf, ngFor\n     * @param templateValue RHS of the microsyntax attribute\n     * @param templateUrl template filename if it's external, component filename if it's inline\n     * @param absoluteKeyOffset start of the `templateKey`\n     * @param absoluteValueOffset start of the `templateValue`\n     */\n\n  }, {\n    key: \"parseTemplateBindings\",\n    value: function parseTemplateBindings(templateKey, templateValue, templateUrl, absoluteKeyOffset, absoluteValueOffset) {\n      var tokens = this._lexer.tokenize(templateValue);\n\n      var parser = new _ParseAST(templateValue, templateUrl, absoluteValueOffset, tokens, templateValue.length, false\n      /* parseAction */\n      , this.errors, 0\n      /* relative offset */\n      );\n      return parser.parseTemplateBindings({\n        source: templateKey,\n        span: new AbsoluteSourceSpan(absoluteKeyOffset, absoluteKeyOffset + templateKey.length)\n      });\n    }\n  }, {\n    key: \"parseInterpolation\",\n    value: function parseInterpolation(input, location, absoluteOffset) {\n      var interpolationConfig = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_INTERPOLATION_CONFIG;\n      var split = this.splitInterpolation(input, location, interpolationConfig);\n      if (split == null) return null;\n      var expressions = [];\n\n      for (var i = 0; i < split.expressions.length; ++i) {\n        var expressionText = split.expressions[i];\n\n        var sourceToLex = this._stripComments(expressionText);\n\n        var tokens = this._lexer.tokenize(sourceToLex);\n\n        var ast = new _ParseAST(input, location, absoluteOffset, tokens, sourceToLex.length, false, this.errors, split.offsets[i] + (expressionText.length - sourceToLex.length)).parseChain();\n        expressions.push(ast);\n      }\n\n      var span = new ParseSpan(0, input == null ? 0 : input.length);\n      return new ASTWithSource(new Interpolation(span, span.toAbsolute(absoluteOffset), split.strings, expressions), input, location, absoluteOffset, this.errors);\n    }\n  }, {\n    key: \"splitInterpolation\",\n    value: function splitInterpolation(input, location) {\n      var interpolationConfig = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_INTERPOLATION_CONFIG;\n\n      var regexp = _getInterpolateRegExp(interpolationConfig);\n\n      var parts = input.split(regexp);\n\n      if (parts.length <= 1) {\n        return null;\n      }\n\n      var strings = [];\n      var expressions = [];\n      var offsets = [];\n      var offset = 0;\n\n      for (var i = 0; i < parts.length; i++) {\n        var part = parts[i];\n\n        if (i % 2 === 0) {\n          // fixed string\n          strings.push(part);\n          offset += part.length;\n        } else if (part.trim().length > 0) {\n          offset += interpolationConfig.start.length;\n          expressions.push(part);\n          offsets.push(offset);\n          offset += part.length + interpolationConfig.end.length;\n        } else {\n          this._reportError('Blank expressions are not allowed in interpolated strings', input, \"at column \".concat(this._findInterpolationErrorColumn(parts, i, interpolationConfig), \" in\"), location);\n\n          expressions.push('$implicit');\n          offsets.push(offset);\n        }\n      }\n\n      return new SplitInterpolation(strings, expressions, offsets);\n    }\n  }, {\n    key: \"wrapLiteralPrimitive\",\n    value: function wrapLiteralPrimitive(input, location, absoluteOffset) {\n      var span = new ParseSpan(0, input == null ? 0 : input.length);\n      return new ASTWithSource(new LiteralPrimitive(span, span.toAbsolute(absoluteOffset), input), input, location, absoluteOffset, this.errors);\n    }\n  }, {\n    key: \"_stripComments\",\n    value: function _stripComments(input) {\n      var i = this._commentStart(input);\n\n      return i != null ? input.substring(0, i).trim() : input;\n    }\n  }, {\n    key: \"_commentStart\",\n    value: function _commentStart(input) {\n      var outerQuote = null;\n\n      for (var i = 0; i < input.length - 1; i++) {\n        var char = input.charCodeAt(i);\n        var nextChar = input.charCodeAt(i + 1);\n        if (char === $SLASH && nextChar == $SLASH && outerQuote == null) return i;\n\n        if (outerQuote === char) {\n          outerQuote = null;\n        } else if (outerQuote == null && isQuote(char)) {\n          outerQuote = char;\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"_checkNoInterpolation\",\n    value: function _checkNoInterpolation(input, location, interpolationConfig) {\n      var regexp = _getInterpolateRegExp(interpolationConfig);\n\n      var parts = input.split(regexp);\n\n      if (parts.length > 1) {\n        this._reportError(\"Got interpolation (\".concat(interpolationConfig.start).concat(interpolationConfig.end, \") where expression was expected\"), input, \"at column \".concat(this._findInterpolationErrorColumn(parts, 1, interpolationConfig), \" in\"), location);\n      }\n    }\n  }, {\n    key: \"_findInterpolationErrorColumn\",\n    value: function _findInterpolationErrorColumn(parts, partInErrIdx, interpolationConfig) {\n      var errLocation = '';\n\n      for (var j = 0; j < partInErrIdx; j++) {\n        errLocation += j % 2 === 0 ? parts[j] : \"\".concat(interpolationConfig.start).concat(parts[j]).concat(interpolationConfig.end);\n      }\n\n      return errLocation.length;\n    }\n  }]);\n\n  return Parser$1;\n}();\n\nvar IvyParser = /*#__PURE__*/function (_Parser$) {\n  _inherits(IvyParser, _Parser$);\n\n  var _super90 = _createSuper(IvyParser);\n\n  function IvyParser() {\n    var _this153;\n\n    _classCallCheck(this, IvyParser);\n\n    _this153 = _super90.apply(this, arguments);\n    _this153.simpleExpressionChecker = IvySimpleExpressionChecker; //\n\n    return _this153;\n  }\n\n  return IvyParser;\n}(Parser$1);\n\nvar _ParseAST = /*#__PURE__*/function () {\n  function _ParseAST(input, location, absoluteOffset, tokens, inputLength, parseAction, errors, offset) {\n    _classCallCheck(this, _ParseAST);\n\n    this.input = input;\n    this.location = location;\n    this.absoluteOffset = absoluteOffset;\n    this.tokens = tokens;\n    this.inputLength = inputLength;\n    this.parseAction = parseAction;\n    this.errors = errors;\n    this.offset = offset;\n    this.rparensExpected = 0;\n    this.rbracketsExpected = 0;\n    this.rbracesExpected = 0; // Cache of expression start and input indeces to the absolute source span they map to, used to\n    // prevent creating superfluous source spans in `sourceSpan`.\n    // A serial of the expression start and input index is used for mapping because both are stateful\n    // and may change for subsequent expressions visited by the parser.\n\n    this.sourceSpanCache = new Map();\n    this.index = 0;\n  }\n\n  _createClass(_ParseAST, [{\n    key: \"peek\",\n    value: function peek(offset) {\n      var i = this.index + offset;\n      return i < this.tokens.length ? this.tokens[i] : EOF;\n    }\n  }, {\n    key: \"span\",\n    value: function span(start) {\n      return new ParseSpan(start, this.currentEndIndex);\n    }\n  }, {\n    key: \"sourceSpan\",\n    value: function sourceSpan(start) {\n      var serial = \"\".concat(start, \"@\").concat(this.inputIndex);\n\n      if (!this.sourceSpanCache.has(serial)) {\n        this.sourceSpanCache.set(serial, this.span(start).toAbsolute(this.absoluteOffset));\n      }\n\n      return this.sourceSpanCache.get(serial);\n    }\n  }, {\n    key: \"advance\",\n    value: function advance() {\n      this.index++;\n    }\n  }, {\n    key: \"consumeOptionalCharacter\",\n    value: function consumeOptionalCharacter(code) {\n      if (this.next.isCharacter(code)) {\n        this.advance();\n        return true;\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: \"peekKeywordLet\",\n    value: function peekKeywordLet() {\n      return this.next.isKeywordLet();\n    }\n  }, {\n    key: \"peekKeywordAs\",\n    value: function peekKeywordAs() {\n      return this.next.isKeywordAs();\n    }\n  }, {\n    key: \"expectCharacter\",\n    value: function expectCharacter(code) {\n      if (this.consumeOptionalCharacter(code)) return;\n      this.error(\"Missing expected \".concat(String.fromCharCode(code)));\n    }\n  }, {\n    key: \"consumeOptionalOperator\",\n    value: function consumeOptionalOperator(op) {\n      if (this.next.isOperator(op)) {\n        this.advance();\n        return true;\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: \"expectOperator\",\n    value: function expectOperator(operator) {\n      if (this.consumeOptionalOperator(operator)) return;\n      this.error(\"Missing expected operator \".concat(operator));\n    }\n  }, {\n    key: \"expectIdentifierOrKeyword\",\n    value: function expectIdentifierOrKeyword() {\n      var n = this.next;\n\n      if (!n.isIdentifier() && !n.isKeyword()) {\n        this.error(\"Unexpected token \".concat(n, \", expected identifier or keyword\"));\n        return '';\n      }\n\n      this.advance();\n      return n.toString();\n    }\n  }, {\n    key: \"expectIdentifierOrKeywordOrString\",\n    value: function expectIdentifierOrKeywordOrString() {\n      var n = this.next;\n\n      if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {\n        this.error(\"Unexpected token \".concat(n, \", expected identifier, keyword, or string\"));\n        return '';\n      }\n\n      this.advance();\n      return n.toString();\n    }\n  }, {\n    key: \"parseChain\",\n    value: function parseChain() {\n      var exprs = [];\n      var start = this.inputIndex;\n\n      while (this.index < this.tokens.length) {\n        var expr = this.parsePipe();\n        exprs.push(expr);\n\n        if (this.consumeOptionalCharacter($SEMICOLON)) {\n          if (!this.parseAction) {\n            this.error('Binding expression cannot contain chained expression');\n          }\n\n          while (this.consumeOptionalCharacter($SEMICOLON)) {} // read all semicolons\n\n        } else if (this.index < this.tokens.length) {\n          this.error(\"Unexpected token '\".concat(this.next, \"'\"));\n        }\n      }\n\n      if (exprs.length == 0) return new EmptyExpr(this.span(start), this.sourceSpan(start));\n      if (exprs.length == 1) return exprs[0];\n      return new Chain(this.span(start), this.sourceSpan(start), exprs);\n    }\n  }, {\n    key: \"parsePipe\",\n    value: function parsePipe() {\n      var result = this.parseExpression();\n\n      if (this.consumeOptionalOperator('|')) {\n        if (this.parseAction) {\n          this.error('Cannot have a pipe in an action expression');\n        }\n\n        do {\n          var nameStart = this.inputIndex;\n          var name = this.expectIdentifierOrKeyword();\n          var nameSpan = this.sourceSpan(nameStart);\n          var args = [];\n\n          while (this.consumeOptionalCharacter($COLON)) {\n            args.push(this.parseExpression());\n          }\n\n          var start = result.span.start;\n          result = new BindingPipe(this.span(start), this.sourceSpan(start), result, name, args, nameSpan);\n        } while (this.consumeOptionalOperator('|'));\n      }\n\n      return result;\n    }\n  }, {\n    key: \"parseExpression\",\n    value: function parseExpression() {\n      return this.parseConditional();\n    }\n  }, {\n    key: \"parseConditional\",\n    value: function parseConditional() {\n      var start = this.inputIndex;\n      var result = this.parseLogicalOr();\n\n      if (this.consumeOptionalOperator('?')) {\n        var yes = this.parsePipe();\n        var no;\n\n        if (!this.consumeOptionalCharacter($COLON)) {\n          var end = this.inputIndex;\n          var expression = this.input.substring(start, end);\n          this.error(\"Conditional expression \".concat(expression, \" requires all 3 expressions\"));\n          no = new EmptyExpr(this.span(start), this.sourceSpan(start));\n        } else {\n          no = this.parsePipe();\n        }\n\n        return new Conditional(this.span(start), this.sourceSpan(start), result, yes, no);\n      } else {\n        return result;\n      }\n    }\n  }, {\n    key: \"parseLogicalOr\",\n    value: function parseLogicalOr() {\n      // '||'\n      var result = this.parseLogicalAnd();\n\n      while (this.consumeOptionalOperator('||')) {\n        var right = this.parseLogicalAnd();\n        var start = result.span.start;\n        result = new Binary(this.span(start), this.sourceSpan(start), '||', result, right);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"parseLogicalAnd\",\n    value: function parseLogicalAnd() {\n      // '&&'\n      var result = this.parseEquality();\n\n      while (this.consumeOptionalOperator('&&')) {\n        var right = this.parseEquality();\n        var start = result.span.start;\n        result = new Binary(this.span(start), this.sourceSpan(start), '&&', result, right);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"parseEquality\",\n    value: function parseEquality() {\n      // '==','!=','===','!=='\n      var result = this.parseRelational();\n\n      while (this.next.type == TokenType$1.Operator) {\n        var operator = this.next.strValue;\n\n        switch (operator) {\n          case '==':\n          case '===':\n          case '!=':\n          case '!==':\n            this.advance();\n            var right = this.parseRelational();\n            var start = result.span.start;\n            result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n            continue;\n        }\n\n        break;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"parseRelational\",\n    value: function parseRelational() {\n      // '<', '>', '<=', '>='\n      var result = this.parseAdditive();\n\n      while (this.next.type == TokenType$1.Operator) {\n        var operator = this.next.strValue;\n\n        switch (operator) {\n          case '<':\n          case '>':\n          case '<=':\n          case '>=':\n            this.advance();\n            var right = this.parseAdditive();\n            var start = result.span.start;\n            result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n            continue;\n        }\n\n        break;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"parseAdditive\",\n    value: function parseAdditive() {\n      // '+', '-'\n      var result = this.parseMultiplicative();\n\n      while (this.next.type == TokenType$1.Operator) {\n        var operator = this.next.strValue;\n\n        switch (operator) {\n          case '+':\n          case '-':\n            this.advance();\n            var right = this.parseMultiplicative();\n            var start = result.span.start;\n            result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n            continue;\n        }\n\n        break;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"parseMultiplicative\",\n    value: function parseMultiplicative() {\n      // '*', '%', '/'\n      var result = this.parsePrefix();\n\n      while (this.next.type == TokenType$1.Operator) {\n        var operator = this.next.strValue;\n\n        switch (operator) {\n          case '*':\n          case '%':\n          case '/':\n            this.advance();\n            var right = this.parsePrefix();\n            var start = result.span.start;\n            result = new Binary(this.span(start), this.sourceSpan(start), operator, result, right);\n            continue;\n        }\n\n        break;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"parsePrefix\",\n    value: function parsePrefix() {\n      if (this.next.type == TokenType$1.Operator) {\n        var start = this.inputIndex;\n        var operator = this.next.strValue;\n        var literalSpan = new ParseSpan(start, start);\n        var literalSourceSpan = literalSpan.toAbsolute(this.absoluteOffset);\n        var result;\n\n        switch (operator) {\n          case '+':\n            this.advance();\n            result = this.parsePrefix();\n            return new Binary(this.span(start), this.sourceSpan(start), '-', result, new LiteralPrimitive(literalSpan, literalSourceSpan, 0));\n\n          case '-':\n            this.advance();\n            result = this.parsePrefix();\n            return new Binary(this.span(start), this.sourceSpan(start), operator, new LiteralPrimitive(literalSpan, literalSourceSpan, 0), result);\n\n          case '!':\n            this.advance();\n            result = this.parsePrefix();\n            return new PrefixNot(this.span(start), this.sourceSpan(start), result);\n        }\n      }\n\n      return this.parseCallChain();\n    }\n  }, {\n    key: \"parseCallChain\",\n    value: function parseCallChain() {\n      var result = this.parsePrimary();\n      var resultStart = result.span.start;\n\n      while (true) {\n        if (this.consumeOptionalCharacter($PERIOD)) {\n          result = this.parseAccessMemberOrMethodCall(result, false);\n        } else if (this.consumeOptionalOperator('?.')) {\n          result = this.parseAccessMemberOrMethodCall(result, true);\n        } else if (this.consumeOptionalCharacter($LBRACKET)) {\n          this.rbracketsExpected++;\n          var key = this.parsePipe();\n          this.rbracketsExpected--;\n          this.expectCharacter($RBRACKET);\n\n          if (this.consumeOptionalOperator('=')) {\n            var value = this.parseConditional();\n            result = new KeyedWrite(this.span(resultStart), this.sourceSpan(resultStart), result, key, value);\n          } else {\n            result = new KeyedRead(this.span(resultStart), this.sourceSpan(resultStart), result, key);\n          }\n        } else if (this.consumeOptionalCharacter($LPAREN)) {\n          this.rparensExpected++;\n          var args = this.parseCallArguments();\n          this.rparensExpected--;\n          this.expectCharacter($RPAREN);\n          result = new FunctionCall(this.span(resultStart), this.sourceSpan(resultStart), result, args);\n        } else if (this.consumeOptionalOperator('!')) {\n          result = new NonNullAssert(this.span(resultStart), this.sourceSpan(resultStart), result);\n        } else {\n          return result;\n        }\n      }\n    }\n  }, {\n    key: \"parsePrimary\",\n    value: function parsePrimary() {\n      var start = this.inputIndex;\n\n      if (this.consumeOptionalCharacter($LPAREN)) {\n        this.rparensExpected++;\n        var result = this.parsePipe();\n        this.rparensExpected--;\n        this.expectCharacter($RPAREN);\n        return result;\n      } else if (this.next.isKeywordNull()) {\n        this.advance();\n        return new LiteralPrimitive(this.span(start), this.sourceSpan(start), null);\n      } else if (this.next.isKeywordUndefined()) {\n        this.advance();\n        return new LiteralPrimitive(this.span(start), this.sourceSpan(start), void 0);\n      } else if (this.next.isKeywordTrue()) {\n        this.advance();\n        return new LiteralPrimitive(this.span(start), this.sourceSpan(start), true);\n      } else if (this.next.isKeywordFalse()) {\n        this.advance();\n        return new LiteralPrimitive(this.span(start), this.sourceSpan(start), false);\n      } else if (this.next.isKeywordThis()) {\n        this.advance();\n        return new ImplicitReceiver(this.span(start), this.sourceSpan(start));\n      } else if (this.consumeOptionalCharacter($LBRACKET)) {\n        this.rbracketsExpected++;\n        var elements = this.parseExpressionList($RBRACKET);\n        this.rbracketsExpected--;\n        this.expectCharacter($RBRACKET);\n        return new LiteralArray(this.span(start), this.sourceSpan(start), elements);\n      } else if (this.next.isCharacter($LBRACE)) {\n        return this.parseLiteralMap();\n      } else if (this.next.isIdentifier()) {\n        return this.parseAccessMemberOrMethodCall(new ImplicitReceiver(this.span(start), this.sourceSpan(start)), false);\n      } else if (this.next.isNumber()) {\n        var value = this.next.toNumber();\n        this.advance();\n        return new LiteralPrimitive(this.span(start), this.sourceSpan(start), value);\n      } else if (this.next.isString()) {\n        var literalValue = this.next.toString();\n        this.advance();\n        return new LiteralPrimitive(this.span(start), this.sourceSpan(start), literalValue);\n      } else if (this.index >= this.tokens.length) {\n        this.error(\"Unexpected end of expression: \".concat(this.input));\n        return new EmptyExpr(this.span(start), this.sourceSpan(start));\n      } else {\n        this.error(\"Unexpected token \".concat(this.next));\n        return new EmptyExpr(this.span(start), this.sourceSpan(start));\n      }\n    }\n  }, {\n    key: \"parseExpressionList\",\n    value: function parseExpressionList(terminator) {\n      var result = [];\n\n      if (!this.next.isCharacter(terminator)) {\n        do {\n          result.push(this.parsePipe());\n        } while (this.consumeOptionalCharacter($COMMA));\n      }\n\n      return result;\n    }\n  }, {\n    key: \"parseLiteralMap\",\n    value: function parseLiteralMap() {\n      var keys = [];\n      var values = [];\n      var start = this.inputIndex;\n      this.expectCharacter($LBRACE);\n\n      if (!this.consumeOptionalCharacter($RBRACE)) {\n        this.rbracesExpected++;\n\n        do {\n          var quoted = this.next.isString();\n          var key = this.expectIdentifierOrKeywordOrString();\n          keys.push({\n            key: key,\n            quoted: quoted\n          });\n          this.expectCharacter($COLON);\n          values.push(this.parsePipe());\n        } while (this.consumeOptionalCharacter($COMMA));\n\n        this.rbracesExpected--;\n        this.expectCharacter($RBRACE);\n      }\n\n      return new LiteralMap(this.span(start), this.sourceSpan(start), keys, values);\n    }\n  }, {\n    key: \"parseAccessMemberOrMethodCall\",\n    value: function parseAccessMemberOrMethodCall(receiver) {\n      var isSafe = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var start = receiver.span.start;\n      var nameStart = this.inputIndex;\n      var id = this.expectIdentifierOrKeyword();\n      var nameSpan = this.sourceSpan(nameStart);\n\n      if (this.consumeOptionalCharacter($LPAREN)) {\n        this.rparensExpected++;\n        var args = this.parseCallArguments();\n        this.expectCharacter($RPAREN);\n        this.rparensExpected--;\n        var span = this.span(start);\n        var sourceSpan = this.sourceSpan(start);\n        return isSafe ? new SafeMethodCall(span, sourceSpan, nameSpan, receiver, id, args) : new MethodCall(span, sourceSpan, nameSpan, receiver, id, args);\n      } else {\n        if (isSafe) {\n          if (this.consumeOptionalOperator('=')) {\n            this.error('The \\'?.\\' operator cannot be used in the assignment');\n            return new EmptyExpr(this.span(start), this.sourceSpan(start));\n          } else {\n            return new SafePropertyRead(this.span(start), this.sourceSpan(start), nameSpan, receiver, id);\n          }\n        } else {\n          if (this.consumeOptionalOperator('=')) {\n            if (!this.parseAction) {\n              this.error('Bindings cannot contain assignments');\n              return new EmptyExpr(this.span(start), this.sourceSpan(start));\n            }\n\n            var value = this.parseConditional();\n            return new PropertyWrite(this.span(start), this.sourceSpan(start), nameSpan, receiver, id, value);\n          } else {\n            return new PropertyRead(this.span(start), this.sourceSpan(start), nameSpan, receiver, id);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"parseCallArguments\",\n    value: function parseCallArguments() {\n      if (this.next.isCharacter($RPAREN)) return [];\n      var positionals = [];\n\n      do {\n        positionals.push(this.parsePipe());\n      } while (this.consumeOptionalCharacter($COMMA));\n\n      return positionals;\n    }\n    /**\n     * Parses an identifier, a keyword, a string with an optional `-` in between,\n     * and returns the string along with its absolute source span.\n     */\n\n  }, {\n    key: \"expectTemplateBindingKey\",\n    value: function expectTemplateBindingKey() {\n      var result = '';\n      var operatorFound = false;\n      var start = this.currentAbsoluteOffset;\n\n      do {\n        result += this.expectIdentifierOrKeywordOrString();\n        operatorFound = this.consumeOptionalOperator('-');\n\n        if (operatorFound) {\n          result += '-';\n        }\n      } while (operatorFound);\n\n      return {\n        source: result,\n        span: new AbsoluteSourceSpan(start, start + result.length)\n      };\n    }\n    /**\n     * Parse microsyntax template expression and return a list of bindings or\n     * parsing errors in case the given expression is invalid.\n     *\n     * For example,\n     * ```\n     *   <div *ngFor=\"let item of items; index as i; trackBy: func\">\n     * ```\n     * contains five bindings:\n     * 1. ngFor -> null\n     * 2. item -> NgForOfContext.$implicit\n     * 3. ngForOf -> items\n     * 4. i -> NgForOfContext.index\n     * 5. ngForTrackBy -> func\n     *\n     * For a full description of the microsyntax grammar, see\n     * https://gist.github.com/mhevery/d3530294cff2e4a1b3fe15ff75d08855\n     *\n     * @param templateKey name of the microsyntax directive, like ngIf, ngFor,\n     * without the *, along with its absolute span.\n     */\n\n  }, {\n    key: \"parseTemplateBindings\",\n    value: function parseTemplateBindings(templateKey) {\n      var bindings = []; // The first binding is for the template key itself\n      // In *ngFor=\"let item of items\", key = \"ngFor\", value = null\n      // In *ngIf=\"cond | pipe\", key = \"ngIf\", value = \"cond | pipe\"\n\n      bindings.push.apply(bindings, _toConsumableArray(this.parseDirectiveKeywordBindings(templateKey)));\n\n      while (this.index < this.tokens.length) {\n        // If it starts with 'let', then this must be variable declaration\n        var letBinding = this.parseLetBinding();\n\n        if (letBinding) {\n          bindings.push(letBinding);\n        } else {\n          // Two possible cases here, either `value \"as\" key` or\n          // \"directive-keyword expression\". We don't know which case, but both\n          // \"value\" and \"directive-keyword\" are template binding key, so consume\n          // the key first.\n          var key = this.expectTemplateBindingKey(); // Peek at the next token, if it is \"as\" then this must be variable\n          // declaration.\n\n          var binding = this.parseAsBinding(key);\n\n          if (binding) {\n            bindings.push(binding);\n          } else {\n            // Otherwise the key must be a directive keyword, like \"of\". Transform\n            // the key to actual key. Eg. of -> ngForOf, trackBy -> ngForTrackBy\n            key.source = templateKey.source + key.source[0].toUpperCase() + key.source.substring(1);\n            bindings.push.apply(bindings, _toConsumableArray(this.parseDirectiveKeywordBindings(key)));\n          }\n        }\n\n        this.consumeStatementTerminator();\n      }\n\n      return new TemplateBindingParseResult(bindings, []\n      /* warnings */\n      , this.errors);\n    }\n    /**\n     * Parse a directive keyword, followed by a mandatory expression.\n     * For example, \"of items\", \"trackBy: func\".\n     * The bindings are: ngForOf -> items, ngForTrackBy -> func\n     * There could be an optional \"as\" binding that follows the expression.\n     * For example,\n     * ```\n     *   *ngFor=\"let item of items | slice:0:1 as collection\".\n     *                    ^^ ^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^\n     *               keyword    bound target   optional 'as' binding\n     * ```\n     *\n     * @param key binding key, for example, ngFor, ngIf, ngForOf, along with its\n     * absolute span.\n     */\n\n  }, {\n    key: \"parseDirectiveKeywordBindings\",\n    value: function parseDirectiveKeywordBindings(key) {\n      var bindings = [];\n      this.consumeOptionalCharacter($COLON); // trackBy: trackByFunction\n\n      var value = this.getDirectiveBoundTarget();\n      var spanEnd = this.currentAbsoluteOffset; // The binding could optionally be followed by \"as\". For example,\n      // *ngIf=\"cond | pipe as x\". In this case, the key in the \"as\" binding\n      // is \"x\" and the value is the template key itself (\"ngIf\"). Note that the\n      // 'key' in the current context now becomes the \"value\" in the next binding.\n\n      var asBinding = this.parseAsBinding(key);\n\n      if (!asBinding) {\n        this.consumeStatementTerminator();\n        spanEnd = this.currentAbsoluteOffset;\n      }\n\n      var sourceSpan = new AbsoluteSourceSpan(key.span.start, spanEnd);\n      bindings.push(new ExpressionBinding(sourceSpan, key, value));\n\n      if (asBinding) {\n        bindings.push(asBinding);\n      }\n\n      return bindings;\n    }\n    /**\n     * Return the expression AST for the bound target of a directive keyword\n     * binding. For example,\n     * ```\n     *   *ngIf=\"condition | pipe\"\n     *          ^^^^^^^^^^^^^^^^ bound target for \"ngIf\"\n     *   *ngFor=\"let item of items\"\n     *                       ^^^^^ bound target for \"ngForOf\"\n     * ```\n     */\n\n  }, {\n    key: \"getDirectiveBoundTarget\",\n    value: function getDirectiveBoundTarget() {\n      if (this.next === EOF || this.peekKeywordAs() || this.peekKeywordLet()) {\n        return null;\n      }\n\n      var ast = this.parsePipe(); // example: \"condition | async\"\n\n      var _ast$span = ast.span,\n          start = _ast$span.start,\n          end = _ast$span.end;\n      var value = this.input.substring(start, end);\n      return new ASTWithSource(ast, value, this.location, this.absoluteOffset + start, this.errors);\n    }\n    /**\n     * Return the binding for a variable declared using `as`. Note that the order\n     * of the key-value pair in this declaration is reversed. For example,\n     * ```\n     *   *ngFor=\"let item of items; index as i\"\n     *                              ^^^^^    ^\n     *                              value    key\n     * ```\n     *\n     * @param value name of the value in the declaration, \"ngIf\" in the example\n     * above, along with its absolute span.\n     */\n\n  }, {\n    key: \"parseAsBinding\",\n    value: function parseAsBinding(value) {\n      if (!this.peekKeywordAs()) {\n        return null;\n      }\n\n      this.advance(); // consume the 'as' keyword\n\n      var key = this.expectTemplateBindingKey();\n      this.consumeStatementTerminator();\n      var sourceSpan = new AbsoluteSourceSpan(value.span.start, this.currentAbsoluteOffset);\n      return new VariableBinding(sourceSpan, key, value);\n    }\n    /**\n     * Return the binding for a variable declared using `let`. For example,\n     * ```\n     *   *ngFor=\"let item of items; let i=index;\"\n     *           ^^^^^^^^           ^^^^^^^^^^^\n     * ```\n     * In the first binding, `item` is bound to `NgForOfContext.$implicit`.\n     * In the second binding, `i` is bound to `NgForOfContext.index`.\n     */\n\n  }, {\n    key: \"parseLetBinding\",\n    value: function parseLetBinding() {\n      if (!this.peekKeywordLet()) {\n        return null;\n      }\n\n      var spanStart = this.currentAbsoluteOffset;\n      this.advance(); // consume the 'let' keyword\n\n      var key = this.expectTemplateBindingKey();\n      var value = null;\n\n      if (this.consumeOptionalOperator('=')) {\n        value = this.expectTemplateBindingKey();\n      }\n\n      this.consumeStatementTerminator();\n      var sourceSpan = new AbsoluteSourceSpan(spanStart, this.currentAbsoluteOffset);\n      return new VariableBinding(sourceSpan, key, value);\n    }\n    /**\n     * Consume the optional statement terminator: semicolon or comma.\n     */\n\n  }, {\n    key: \"consumeStatementTerminator\",\n    value: function consumeStatementTerminator() {\n      this.consumeOptionalCharacter($SEMICOLON) || this.consumeOptionalCharacter($COMMA);\n    }\n  }, {\n    key: \"error\",\n    value: function error(message) {\n      var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      this.errors.push(new ParserError(message, this.input, this.locationText(index), this.location));\n      this.skip();\n    }\n  }, {\n    key: \"locationText\",\n    value: function locationText() {\n      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      if (index == null) index = this.index;\n      return index < this.tokens.length ? \"at column \".concat(this.tokens[index].index + 1, \" in\") : \"at the end of the expression\";\n    } // Error recovery should skip tokens until it encounters a recovery point. skip() treats\n    // the end of input and a ';' as unconditionally a recovery point. It also treats ')',\n    // '}' and ']' as conditional recovery points if one of calling productions is expecting\n    // one of these symbols. This allows skip() to recover from errors such as '(a.) + 1' allowing\n    // more of the AST to be retained (it doesn't skip any tokens as the ')' is retained because\n    // of the '(' begins an '(' <expr> ')' production). The recovery points of grouping symbols\n    // must be conditional as they must be skipped if none of the calling productions are not\n    // expecting the closing token else we will never make progress in the case of an\n    // extraneous group closing symbol (such as a stray ')'). This is not the case for ';' because\n    // parseChain() is always the root production and it expects a ';'.\n    // If a production expects one of these token it increments the corresponding nesting count,\n    // and then decrements it just prior to checking if the token is in the input.\n\n  }, {\n    key: \"skip\",\n    value: function skip() {\n      var n = this.next;\n\n      while (this.index < this.tokens.length && !n.isCharacter($SEMICOLON) && (this.rparensExpected <= 0 || !n.isCharacter($RPAREN)) && (this.rbracesExpected <= 0 || !n.isCharacter($RBRACE)) && (this.rbracketsExpected <= 0 || !n.isCharacter($RBRACKET))) {\n        if (this.next.isError()) {\n          this.errors.push(new ParserError(this.next.toString(), this.input, this.locationText(), this.location));\n        }\n\n        this.advance();\n        n = this.next;\n      }\n    }\n  }, {\n    key: \"next\",\n    get: function get() {\n      return this.peek(0);\n    }\n    /** Whether all the parser input has been processed. */\n\n  }, {\n    key: \"atEOF\",\n    get: function get() {\n      return this.index >= this.tokens.length;\n    }\n    /**\n     * Index of the next token to be processed, or the end of the last token if all have been\n     * processed.\n     */\n\n  }, {\n    key: \"inputIndex\",\n    get: function get() {\n      return this.atEOF ? this.currentEndIndex : this.next.index + this.offset;\n    }\n    /**\n     * End index of the last processed token, or the start of the first token if none have been\n     * processed.\n     */\n\n  }, {\n    key: \"currentEndIndex\",\n    get: function get() {\n      if (this.index > 0) {\n        var curToken = this.peek(-1);\n        return curToken.end + this.offset;\n      } // No tokens have been processed yet; return the next token's start or the length of the input\n      // if there is no token.\n\n\n      if (this.tokens.length === 0) {\n        return this.inputLength + this.offset;\n      }\n\n      return this.next.index + this.offset;\n    }\n    /**\n     * Returns the absolute offset of the start of the current token.\n     */\n\n  }, {\n    key: \"currentAbsoluteOffset\",\n    get: function get() {\n      return this.absoluteOffset + this.inputIndex;\n    }\n  }]);\n\n  return _ParseAST;\n}();\n\nvar SimpleExpressionChecker = /*#__PURE__*/function () {\n  function SimpleExpressionChecker() {\n    _classCallCheck(this, SimpleExpressionChecker);\n\n    this.errors = [];\n  }\n\n  _createClass(SimpleExpressionChecker, [{\n    key: \"visitImplicitReceiver\",\n    value: function visitImplicitReceiver(ast, context) {}\n  }, {\n    key: \"visitInterpolation\",\n    value: function visitInterpolation(ast, context) {}\n  }, {\n    key: \"visitLiteralPrimitive\",\n    value: function visitLiteralPrimitive(ast, context) {}\n  }, {\n    key: \"visitPropertyRead\",\n    value: function visitPropertyRead(ast, context) {}\n  }, {\n    key: \"visitPropertyWrite\",\n    value: function visitPropertyWrite(ast, context) {}\n  }, {\n    key: \"visitSafePropertyRead\",\n    value: function visitSafePropertyRead(ast, context) {}\n  }, {\n    key: \"visitMethodCall\",\n    value: function visitMethodCall(ast, context) {}\n  }, {\n    key: \"visitSafeMethodCall\",\n    value: function visitSafeMethodCall(ast, context) {}\n  }, {\n    key: \"visitFunctionCall\",\n    value: function visitFunctionCall(ast, context) {}\n  }, {\n    key: \"visitLiteralArray\",\n    value: function visitLiteralArray(ast, context) {\n      this.visitAll(ast.expressions);\n    }\n  }, {\n    key: \"visitLiteralMap\",\n    value: function visitLiteralMap(ast, context) {\n      this.visitAll(ast.values);\n    }\n  }, {\n    key: \"visitBinary\",\n    value: function visitBinary(ast, context) {}\n  }, {\n    key: \"visitPrefixNot\",\n    value: function visitPrefixNot(ast, context) {}\n  }, {\n    key: \"visitNonNullAssert\",\n    value: function visitNonNullAssert(ast, context) {}\n  }, {\n    key: \"visitConditional\",\n    value: function visitConditional(ast, context) {}\n  }, {\n    key: \"visitPipe\",\n    value: function visitPipe(ast, context) {\n      this.errors.push('pipes');\n    }\n  }, {\n    key: \"visitKeyedRead\",\n    value: function visitKeyedRead(ast, context) {}\n  }, {\n    key: \"visitKeyedWrite\",\n    value: function visitKeyedWrite(ast, context) {}\n  }, {\n    key: \"visitAll\",\n    value: function visitAll(asts) {\n      var _this154 = this;\n\n      return asts.map(function (node) {\n        return node.visit(_this154);\n      });\n    }\n  }, {\n    key: \"visitChain\",\n    value: function visitChain(ast, context) {}\n  }, {\n    key: \"visitQuote\",\n    value: function visitQuote(ast, context) {}\n  }]);\n\n  return SimpleExpressionChecker;\n}();\n/**\n * This class extends SimpleExpressionChecker used in View Engine and performs more strict checks to\n * make sure host bindings do not contain pipes. In View Engine, having pipes in host bindings is\n * not supported as well, but in some cases (like `!(value | async)`) the error is not triggered at\n * compile time. In order to preserve View Engine behavior, more strict checks are introduced for\n * Ivy mode only.\n */\n\n\nvar IvySimpleExpressionChecker = /*#__PURE__*/function (_SimpleExpressionChec) {\n  _inherits(IvySimpleExpressionChecker, _SimpleExpressionChec);\n\n  var _super91 = _createSuper(IvySimpleExpressionChecker);\n\n  function IvySimpleExpressionChecker() {\n    _classCallCheck(this, IvySimpleExpressionChecker);\n\n    return _super91.apply(this, arguments);\n  }\n\n  _createClass(IvySimpleExpressionChecker, [{\n    key: \"visitBinary\",\n    value: function visitBinary(ast, context) {\n      ast.left.visit(this);\n      ast.right.visit(this);\n    }\n  }, {\n    key: \"visitPrefixNot\",\n    value: function visitPrefixNot(ast, context) {\n      ast.expression.visit(this);\n    }\n  }]);\n\n  return IvySimpleExpressionChecker;\n}(SimpleExpressionChecker);\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// =================================================================================================\n// =================================================================================================\n// =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========\n// =================================================================================================\n// =================================================================================================\n//\n//        DO NOT EDIT THIS LIST OF SECURITY SENSITIVE PROPERTIES WITHOUT A SECURITY REVIEW!\n//                               Reach out to mprobst for details.\n//\n// =================================================================================================\n\n/** Map from tagName|propertyName SecurityContext. Properties applying to all tags use '*'. */\n\n\nvar _SECURITY_SCHEMA;\n\nfunction SECURITY_SCHEMA() {\n  if (!_SECURITY_SCHEMA) {\n    _SECURITY_SCHEMA = {}; // Case is insignificant below, all element and attribute names are lower-cased for lookup.\n\n    registerContext(SecurityContext.HTML, ['iframe|srcdoc', '*|innerHTML', '*|outerHTML']);\n    registerContext(SecurityContext.STYLE, ['*|style']); // NB: no SCRIPT contexts here, they are never allowed due to the parser stripping them.\n\n    registerContext(SecurityContext.URL, ['*|formAction', 'area|href', 'area|ping', 'audio|src', 'a|href', 'a|ping', 'blockquote|cite', 'body|background', 'del|cite', 'form|action', 'img|src', 'img|srcset', 'input|src', 'ins|cite', 'q|cite', 'source|src', 'source|srcset', 'track|src', 'video|poster', 'video|src']);\n    registerContext(SecurityContext.RESOURCE_URL, ['applet|code', 'applet|codebase', 'base|href', 'embed|src', 'frame|src', 'head|profile', 'html|manifest', 'iframe|src', 'link|href', 'media|src', 'object|codebase', 'object|data', 'script|src']);\n  }\n\n  return _SECURITY_SCHEMA;\n}\n\nfunction registerContext(ctx, specs) {\n  var _iterator9 = _createForOfIteratorHelper(specs),\n      _step9;\n\n  try {\n    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n      var spec = _step9.value;\n      _SECURITY_SCHEMA[spec.toLowerCase()] = ctx;\n    }\n  } catch (err) {\n    _iterator9.e(err);\n  } finally {\n    _iterator9.f();\n  }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar ElementSchemaRegistry = function ElementSchemaRegistry() {\n  _classCallCheck(this, ElementSchemaRegistry);\n};\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar BOOLEAN = 'boolean';\nvar NUMBER = 'number';\nvar STRING = 'string';\nvar OBJECT = 'object';\n/**\n * This array represents the DOM schema. It encodes inheritance, properties, and events.\n *\n * ## Overview\n *\n * Each line represents one kind of element. The `element_inheritance` and properties are joined\n * using `element_inheritance|properties` syntax.\n *\n * ## Element Inheritance\n *\n * The `element_inheritance` can be further subdivided as `element1,element2,...^parentElement`.\n * Here the individual elements are separated by `,` (commas). Every element in the list\n * has identical properties.\n *\n * An `element` may inherit additional properties from `parentElement` If no `^parentElement` is\n * specified then `\"\"` (blank) element is assumed.\n *\n * NOTE: The blank element inherits from root `[Element]` element, the super element of all\n * elements.\n *\n * NOTE an element prefix such as `:svg:` has no special meaning to the schema.\n *\n * ## Properties\n *\n * Each element has a set of properties separated by `,` (commas). Each property can be prefixed\n * by a special character designating its type:\n *\n * - (no prefix): property is a string.\n * - `*`: property represents an event.\n * - `!`: property is a boolean.\n * - `#`: property is a number.\n * - `%`: property is an object.\n *\n * ## Query\n *\n * The class creates an internal squas representation which allows to easily answer the query of\n * if a given property exist on a given element.\n *\n * NOTE: We don't yet support querying for types or events.\n * NOTE: This schema is auto extracted from `schema_extractor.ts` located in the test folder,\n *       see dom_element_schema_registry_spec.ts\n */\n// =================================================================================================\n// =================================================================================================\n// =========== S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P   -  S T O P  ===========\n// =================================================================================================\n// =================================================================================================\n//\n//                       DO NOT EDIT THIS DOM SCHEMA WITHOUT A SECURITY REVIEW!\n//\n// Newly added properties must be security reviewed and assigned an appropriate SecurityContext in\n// dom_security_schema.ts. Reach out to mprobst & rjamet for details.\n//\n// =================================================================================================\n\nvar SCHEMA = ['[Element]|textContent,%classList,className,id,innerHTML,*beforecopy,*beforecut,*beforepaste,*copy,*cut,*paste,*search,*selectstart,*webkitfullscreenchange,*webkitfullscreenerror,*wheel,outerHTML,#scrollLeft,#scrollTop,slot' +\n/* added manually to avoid breaking changes */\n',*message,*mozfullscreenchange,*mozfullscreenerror,*mozpointerlockchange,*mozpointerlockerror,*webglcontextcreationerror,*webglcontextlost,*webglcontextrestored', '[HTMLElement]^[Element]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,outerText,!spellcheck,%style,#tabIndex,title,!translate', 'abbr,address,article,aside,b,bdi,bdo,cite,code,dd,dfn,dt,em,figcaption,figure,footer,header,i,kbd,main,mark,nav,noscript,rb,rp,rt,rtc,ruby,s,samp,section,small,strong,sub,sup,u,var,wbr^[HTMLElement]|accessKey,contentEditable,dir,!draggable,!hidden,innerText,lang,*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,outerText,!spellcheck,%style,#tabIndex,title,!translate', 'media^[HTMLElement]|!autoplay,!controls,%controlsList,%crossOrigin,#currentTime,!defaultMuted,#defaultPlaybackRate,!disableRemotePlayback,!loop,!muted,*encrypted,*waitingforkey,#playbackRate,preload,src,%srcObject,#volume', ':svg:^[HTMLElement]|*abort,*auxclick,*blur,*cancel,*canplay,*canplaythrough,*change,*click,*close,*contextmenu,*cuechange,*dblclick,*drag,*dragend,*dragenter,*dragleave,*dragover,*dragstart,*drop,*durationchange,*emptied,*ended,*error,*focus,*gotpointercapture,*input,*invalid,*keydown,*keypress,*keyup,*load,*loadeddata,*loadedmetadata,*loadstart,*lostpointercapture,*mousedown,*mouseenter,*mouseleave,*mousemove,*mouseout,*mouseover,*mouseup,*mousewheel,*pause,*play,*playing,*pointercancel,*pointerdown,*pointerenter,*pointerleave,*pointermove,*pointerout,*pointerover,*pointerup,*progress,*ratechange,*reset,*resize,*scroll,*seeked,*seeking,*select,*show,*stalled,*submit,*suspend,*timeupdate,*toggle,*volumechange,*waiting,%style,#tabIndex', ':svg:graphics^:svg:|', ':svg:animation^:svg:|*begin,*end,*repeat', ':svg:geometry^:svg:|', ':svg:componentTransferFunction^:svg:|', ':svg:gradient^:svg:|', ':svg:textContent^:svg:graphics|', ':svg:textPositioning^:svg:textContent|', 'a^[HTMLElement]|charset,coords,download,hash,host,hostname,href,hreflang,name,password,pathname,ping,port,protocol,referrerPolicy,rel,rev,search,shape,target,text,type,username', 'area^[HTMLElement]|alt,coords,download,hash,host,hostname,href,!noHref,password,pathname,ping,port,protocol,referrerPolicy,rel,search,shape,target,username', 'audio^media|', 'br^[HTMLElement]|clear', 'base^[HTMLElement]|href,target', 'body^[HTMLElement]|aLink,background,bgColor,link,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,text,vLink', 'button^[HTMLElement]|!autofocus,!disabled,formAction,formEnctype,formMethod,!formNoValidate,formTarget,name,type,value', 'canvas^[HTMLElement]|#height,#width', 'content^[HTMLElement]|select', 'dl^[HTMLElement]|!compact', 'datalist^[HTMLElement]|', 'details^[HTMLElement]|!open', 'dialog^[HTMLElement]|!open,returnValue', 'dir^[HTMLElement]|!compact', 'div^[HTMLElement]|align', 'embed^[HTMLElement]|align,height,name,src,type,width', 'fieldset^[HTMLElement]|!disabled,name', 'font^[HTMLElement]|color,face,size', 'form^[HTMLElement]|acceptCharset,action,autocomplete,encoding,enctype,method,name,!noValidate,target', 'frame^[HTMLElement]|frameBorder,longDesc,marginHeight,marginWidth,name,!noResize,scrolling,src', 'frameset^[HTMLElement]|cols,*beforeunload,*blur,*error,*focus,*hashchange,*languagechange,*load,*message,*offline,*online,*pagehide,*pageshow,*popstate,*rejectionhandled,*resize,*scroll,*storage,*unhandledrejection,*unload,rows', 'hr^[HTMLElement]|align,color,!noShade,size,width', 'head^[HTMLElement]|', 'h1,h2,h3,h4,h5,h6^[HTMLElement]|align', 'html^[HTMLElement]|version', 'iframe^[HTMLElement]|align,!allowFullscreen,frameBorder,height,longDesc,marginHeight,marginWidth,name,referrerPolicy,%sandbox,scrolling,src,srcdoc,width', 'img^[HTMLElement]|align,alt,border,%crossOrigin,#height,#hspace,!isMap,longDesc,lowsrc,name,referrerPolicy,sizes,src,srcset,useMap,#vspace,#width', 'input^[HTMLElement]|accept,align,alt,autocapitalize,autocomplete,!autofocus,!checked,!defaultChecked,defaultValue,dirName,!disabled,%files,formAction,formEnctype,formMethod,!formNoValidate,formTarget,#height,!incremental,!indeterminate,max,#maxLength,min,#minLength,!multiple,name,pattern,placeholder,!readOnly,!required,selectionDirection,#selectionEnd,#selectionStart,#size,src,step,type,useMap,value,%valueAsDate,#valueAsNumber,#width', 'li^[HTMLElement]|type,#value', 'label^[HTMLElement]|htmlFor', 'legend^[HTMLElement]|align', 'link^[HTMLElement]|as,charset,%crossOrigin,!disabled,href,hreflang,integrity,media,referrerPolicy,rel,%relList,rev,%sizes,target,type', 'map^[HTMLElement]|name', 'marquee^[HTMLElement]|behavior,bgColor,direction,height,#hspace,#loop,#scrollAmount,#scrollDelay,!trueSpeed,#vspace,width', 'menu^[HTMLElement]|!compact', 'meta^[HTMLElement]|content,httpEquiv,name,scheme', 'meter^[HTMLElement]|#high,#low,#max,#min,#optimum,#value', 'ins,del^[HTMLElement]|cite,dateTime', 'ol^[HTMLElement]|!compact,!reversed,#start,type', 'object^[HTMLElement]|align,archive,border,code,codeBase,codeType,data,!declare,height,#hspace,name,standby,type,useMap,#vspace,width', 'optgroup^[HTMLElement]|!disabled,label', 'option^[HTMLElement]|!defaultSelected,!disabled,label,!selected,text,value', 'output^[HTMLElement]|defaultValue,%htmlFor,name,value', 'p^[HTMLElement]|align', 'param^[HTMLElement]|name,type,value,valueType', 'picture^[HTMLElement]|', 'pre^[HTMLElement]|#width', 'progress^[HTMLElement]|#max,#value', 'q,blockquote,cite^[HTMLElement]|', 'script^[HTMLElement]|!async,charset,%crossOrigin,!defer,event,htmlFor,integrity,src,text,type', 'select^[HTMLElement]|!autofocus,!disabled,#length,!multiple,name,!required,#selectedIndex,#size,value', 'shadow^[HTMLElement]|', 'slot^[HTMLElement]|name', 'source^[HTMLElement]|media,sizes,src,srcset,type', 'span^[HTMLElement]|', 'style^[HTMLElement]|!disabled,media,type', 'caption^[HTMLElement]|align', 'th,td^[HTMLElement]|abbr,align,axis,bgColor,ch,chOff,#colSpan,headers,height,!noWrap,#rowSpan,scope,vAlign,width', 'col,colgroup^[HTMLElement]|align,ch,chOff,#span,vAlign,width', 'table^[HTMLElement]|align,bgColor,border,%caption,cellPadding,cellSpacing,frame,rules,summary,%tFoot,%tHead,width', 'tr^[HTMLElement]|align,bgColor,ch,chOff,vAlign', 'tfoot,thead,tbody^[HTMLElement]|align,ch,chOff,vAlign', 'template^[HTMLElement]|', 'textarea^[HTMLElement]|autocapitalize,!autofocus,#cols,defaultValue,dirName,!disabled,#maxLength,#minLength,name,placeholder,!readOnly,!required,#rows,selectionDirection,#selectionEnd,#selectionStart,value,wrap', 'title^[HTMLElement]|text', 'track^[HTMLElement]|!default,kind,label,src,srclang', 'ul^[HTMLElement]|!compact,type', 'unknown^[HTMLElement]|', 'video^media|#height,poster,#width', ':svg:a^:svg:graphics|', ':svg:animate^:svg:animation|', ':svg:animateMotion^:svg:animation|', ':svg:animateTransform^:svg:animation|', ':svg:circle^:svg:geometry|', ':svg:clipPath^:svg:graphics|', ':svg:defs^:svg:graphics|', ':svg:desc^:svg:|', ':svg:discard^:svg:|', ':svg:ellipse^:svg:geometry|', ':svg:feBlend^:svg:|', ':svg:feColorMatrix^:svg:|', ':svg:feComponentTransfer^:svg:|', ':svg:feComposite^:svg:|', ':svg:feConvolveMatrix^:svg:|', ':svg:feDiffuseLighting^:svg:|', ':svg:feDisplacementMap^:svg:|', ':svg:feDistantLight^:svg:|', ':svg:feDropShadow^:svg:|', ':svg:feFlood^:svg:|', ':svg:feFuncA^:svg:componentTransferFunction|', ':svg:feFuncB^:svg:componentTransferFunction|', ':svg:feFuncG^:svg:componentTransferFunction|', ':svg:feFuncR^:svg:componentTransferFunction|', ':svg:feGaussianBlur^:svg:|', ':svg:feImage^:svg:|', ':svg:feMerge^:svg:|', ':svg:feMergeNode^:svg:|', ':svg:feMorphology^:svg:|', ':svg:feOffset^:svg:|', ':svg:fePointLight^:svg:|', ':svg:feSpecularLighting^:svg:|', ':svg:feSpotLight^:svg:|', ':svg:feTile^:svg:|', ':svg:feTurbulence^:svg:|', ':svg:filter^:svg:|', ':svg:foreignObject^:svg:graphics|', ':svg:g^:svg:graphics|', ':svg:image^:svg:graphics|', ':svg:line^:svg:geometry|', ':svg:linearGradient^:svg:gradient|', ':svg:mpath^:svg:|', ':svg:marker^:svg:|', ':svg:mask^:svg:|', ':svg:metadata^:svg:|', ':svg:path^:svg:geometry|', ':svg:pattern^:svg:|', ':svg:polygon^:svg:geometry|', ':svg:polyline^:svg:geometry|', ':svg:radialGradient^:svg:gradient|', ':svg:rect^:svg:geometry|', ':svg:svg^:svg:graphics|#currentScale,#zoomAndPan', ':svg:script^:svg:|type', ':svg:set^:svg:animation|', ':svg:stop^:svg:|', ':svg:style^:svg:|!disabled,media,title,type', ':svg:switch^:svg:graphics|', ':svg:symbol^:svg:|', ':svg:tspan^:svg:textPositioning|', ':svg:text^:svg:textPositioning|', ':svg:textPath^:svg:textContent|', ':svg:title^:svg:|', ':svg:use^:svg:graphics|', ':svg:view^:svg:|#zoomAndPan', 'data^[HTMLElement]|value', 'keygen^[HTMLElement]|!autofocus,challenge,!disabled,form,keytype,name', 'menuitem^[HTMLElement]|type,label,icon,!disabled,!checked,radiogroup,!default', 'summary^[HTMLElement]|', 'time^[HTMLElement]|dateTime', ':svg:cursor^:svg:|'];\nvar _ATTR_TO_PROP = {\n  'class': 'className',\n  'for': 'htmlFor',\n  'formaction': 'formAction',\n  'innerHtml': 'innerHTML',\n  'readonly': 'readOnly',\n  'tabindex': 'tabIndex'\n};\n\nvar DomElementSchemaRegistry = /*#__PURE__*/function (_ElementSchemaRegistr) {\n  _inherits(DomElementSchemaRegistry, _ElementSchemaRegistr);\n\n  var _super92 = _createSuper(DomElementSchemaRegistry);\n\n  function DomElementSchemaRegistry() {\n    var _this155;\n\n    _classCallCheck(this, DomElementSchemaRegistry);\n\n    _this155 = _super92.call(this);\n    _this155._schema = {};\n    SCHEMA.forEach(function (encodedType) {\n      var type = {};\n\n      var _encodedType$split = encodedType.split('|'),\n          _encodedType$split2 = _slicedToArray(_encodedType$split, 2),\n          strType = _encodedType$split2[0],\n          strProperties = _encodedType$split2[1];\n\n      var properties = strProperties.split(',');\n\n      var _strType$split = strType.split('^'),\n          _strType$split2 = _slicedToArray(_strType$split, 2),\n          typeNames = _strType$split2[0],\n          superName = _strType$split2[1];\n\n      typeNames.split(',').forEach(function (tag) {\n        return _this155._schema[tag.toLowerCase()] = type;\n      });\n\n      var superType = superName && _this155._schema[superName.toLowerCase()];\n\n      if (superType) {\n        Object.keys(superType).forEach(function (prop) {\n          type[prop] = superType[prop];\n        });\n      }\n\n      properties.forEach(function (property) {\n        if (property.length > 0) {\n          switch (property[0]) {\n            case '*':\n              // We don't yet support events.\n              // If ever allowing to bind to events, GO THROUGH A SECURITY REVIEW, allowing events\n              // will\n              // almost certainly introduce bad XSS vulnerabilities.\n              // type[property.substring(1)] = EVENT;\n              break;\n\n            case '!':\n              type[property.substring(1)] = BOOLEAN;\n              break;\n\n            case '#':\n              type[property.substring(1)] = NUMBER;\n              break;\n\n            case '%':\n              type[property.substring(1)] = OBJECT;\n              break;\n\n            default:\n              type[property] = STRING;\n          }\n        }\n      });\n    });\n    return _this155;\n  }\n\n  _createClass(DomElementSchemaRegistry, [{\n    key: \"hasProperty\",\n    value: function hasProperty(tagName, propName, schemaMetas) {\n      if (schemaMetas.some(function (schema) {\n        return schema.name === NO_ERRORS_SCHEMA.name;\n      })) {\n        return true;\n      }\n\n      if (tagName.indexOf('-') > -1) {\n        if (isNgContainer(tagName) || isNgContent(tagName)) {\n          return false;\n        }\n\n        if (schemaMetas.some(function (schema) {\n          return schema.name === CUSTOM_ELEMENTS_SCHEMA.name;\n        })) {\n          // Can't tell now as we don't know which properties a custom element will get\n          // once it is instantiated\n          return true;\n        }\n      }\n\n      var elementProperties = this._schema[tagName.toLowerCase()] || this._schema['unknown'];\n\n      return !!elementProperties[propName];\n    }\n  }, {\n    key: \"hasElement\",\n    value: function hasElement(tagName, schemaMetas) {\n      if (schemaMetas.some(function (schema) {\n        return schema.name === NO_ERRORS_SCHEMA.name;\n      })) {\n        return true;\n      }\n\n      if (tagName.indexOf('-') > -1) {\n        if (isNgContainer(tagName) || isNgContent(tagName)) {\n          return true;\n        }\n\n        if (schemaMetas.some(function (schema) {\n          return schema.name === CUSTOM_ELEMENTS_SCHEMA.name;\n        })) {\n          // Allow any custom elements\n          return true;\n        }\n      }\n\n      return !!this._schema[tagName.toLowerCase()];\n    }\n    /**\n     * securityContext returns the security context for the given property on the given DOM tag.\n     *\n     * Tag and property name are statically known and cannot change at runtime, i.e. it is not\n     * possible to bind a value into a changing attribute or tag name.\n     *\n     * The filtering is based on a list of allowed tags|attributes. All attributes in the schema\n     * above are assumed to have the 'NONE' security context, i.e. that they are safe inert\n     * string values. Only specific well known attack vectors are assigned their appropriate context.\n     */\n\n  }, {\n    key: \"securityContext\",\n    value: function securityContext(tagName, propName, isAttribute) {\n      if (isAttribute) {\n        // NB: For security purposes, use the mapped property name, not the attribute name.\n        propName = this.getMappedPropName(propName);\n      } // Make sure comparisons are case insensitive, so that case differences between attribute and\n      // property names do not have a security impact.\n\n\n      tagName = tagName.toLowerCase();\n      propName = propName.toLowerCase();\n      var ctx = SECURITY_SCHEMA()[tagName + '|' + propName];\n\n      if (ctx) {\n        return ctx;\n      }\n\n      ctx = SECURITY_SCHEMA()['*|' + propName];\n      return ctx ? ctx : SecurityContext.NONE;\n    }\n  }, {\n    key: \"getMappedPropName\",\n    value: function getMappedPropName(propName) {\n      return _ATTR_TO_PROP[propName] || propName;\n    }\n  }, {\n    key: \"getDefaultComponentElementName\",\n    value: function getDefaultComponentElementName() {\n      return 'ng-component';\n    }\n  }, {\n    key: \"validateProperty\",\n    value: function validateProperty(name) {\n      if (name.toLowerCase().startsWith('on')) {\n        var msg = \"Binding to event property '\".concat(name, \"' is disallowed for security reasons, \") + \"please use (\".concat(name.slice(2), \")=...\") + \"\\nIf '\".concat(name, \"' is a directive input, make sure the directive is imported by the\") + \" current module.\";\n        return {\n          error: true,\n          msg: msg\n        };\n      } else {\n        return {\n          error: false\n        };\n      }\n    }\n  }, {\n    key: \"validateAttribute\",\n    value: function validateAttribute(name) {\n      if (name.toLowerCase().startsWith('on')) {\n        var msg = \"Binding to event attribute '\".concat(name, \"' is disallowed for security reasons, \") + \"please use (\".concat(name.slice(2), \")=...\");\n        return {\n          error: true,\n          msg: msg\n        };\n      } else {\n        return {\n          error: false\n        };\n      }\n    }\n  }, {\n    key: \"allKnownElementNames\",\n    value: function allKnownElementNames() {\n      return Object.keys(this._schema);\n    }\n  }, {\n    key: \"normalizeAnimationStyleProperty\",\n    value: function normalizeAnimationStyleProperty(propName) {\n      return dashCaseToCamelCase(propName);\n    }\n  }, {\n    key: \"normalizeAnimationStyleValue\",\n    value: function normalizeAnimationStyleValue(camelCaseProp, userProvidedProp, val) {\n      var unit = '';\n      var strVal = val.toString().trim();\n      var errorMsg = null;\n\n      if (_isPixelDimensionStyle(camelCaseProp) && val !== 0 && val !== '0') {\n        if (typeof val === 'number') {\n          unit = 'px';\n        } else {\n          var valAndSuffixMatch = val.match(/^[+-]?[\\d\\.]+([a-z]*)$/);\n\n          if (valAndSuffixMatch && valAndSuffixMatch[1].length == 0) {\n            errorMsg = \"Please provide a CSS unit value for \".concat(userProvidedProp, \":\").concat(val);\n          }\n        }\n      }\n\n      return {\n        error: errorMsg,\n        value: strVal + unit\n      };\n    }\n  }]);\n\n  return DomElementSchemaRegistry;\n}(ElementSchemaRegistry);\n\nfunction _isPixelDimensionStyle(prop) {\n  switch (prop) {\n    case 'width':\n    case 'height':\n    case 'minWidth':\n    case 'minHeight':\n    case 'maxWidth':\n    case 'maxHeight':\n    case 'left':\n    case 'top':\n    case 'bottom':\n    case 'right':\n    case 'fontSize':\n    case 'outlineWidth':\n    case 'outlineOffset':\n    case 'paddingTop':\n    case 'paddingLeft':\n    case 'paddingBottom':\n    case 'paddingRight':\n    case 'marginTop':\n    case 'marginLeft':\n    case 'marginBottom':\n    case 'marginRight':\n    case 'borderRadius':\n    case 'borderWidth':\n    case 'borderTopWidth':\n    case 'borderLeftWidth':\n    case 'borderRightWidth':\n    case 'borderBottomWidth':\n    case 'textIndent':\n      return true;\n\n    default:\n      return false;\n  }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar BIND_NAME_REGEXP$1 = /^(?:(?:(?:(bind-)|(let-)|(ref-|#)|(on-)|(bindon-)|(@))(.*))|\\[\\(([^\\)]+)\\)\\]|\\[([^\\]]+)\\]|\\(([^\\)]+)\\))$/; // Group 1 = \"bind-\"\n\nvar KW_BIND_IDX$1 = 1; // Group 2 = \"let-\"\n\nvar KW_LET_IDX$1 = 2; // Group 3 = \"ref-/#\"\n\nvar KW_REF_IDX$1 = 3; // Group 4 = \"on-\"\n\nvar KW_ON_IDX$1 = 4; // Group 5 = \"bindon-\"\n\nvar KW_BINDON_IDX$1 = 5; // Group 6 = \"@\"\n\nvar KW_AT_IDX$1 = 6; // Group 7 = the identifier after \"bind-\", \"let-\", \"ref-/#\", \"on-\", \"bindon-\" or \"@\"\n\nvar IDENT_KW_IDX$1 = 7; // Group 8 = identifier inside [()]\n\nvar IDENT_BANANA_BOX_IDX$1 = 8; // Group 9 = identifier inside []\n\nvar IDENT_PROPERTY_IDX$1 = 9; // Group 10 = identifier inside ()\n\nvar IDENT_EVENT_IDX$1 = 10;\nvar TEMPLATE_ATTR_PREFIX$2 = '*';\n\nfunction htmlAstToRender3Ast(htmlNodes, bindingParser) {\n  var transformer = new HtmlAstToIvyAst(bindingParser);\n  var ivyNodes = visitAll$1(transformer, htmlNodes); // Errors might originate in either the binding parser or the html to ivy transformer\n\n  var allErrors = bindingParser.errors.concat(transformer.errors);\n  var errors = allErrors.filter(function (e) {\n    return e.level === ParseErrorLevel.ERROR;\n  });\n\n  if (errors.length > 0) {\n    var errorString = errors.join('\\n');\n    throw syntaxError(\"Template parse errors:\\n\".concat(errorString), errors);\n  }\n\n  return {\n    nodes: ivyNodes,\n    errors: allErrors,\n    styleUrls: transformer.styleUrls,\n    styles: transformer.styles,\n    ngContentSelectors: transformer.ngContentSelectors\n  };\n}\n\nvar HtmlAstToIvyAst = /*#__PURE__*/function () {\n  function HtmlAstToIvyAst(bindingParser) {\n    _classCallCheck(this, HtmlAstToIvyAst);\n\n    this.bindingParser = bindingParser;\n    this.errors = [];\n    this.styles = [];\n    this.styleUrls = [];\n    this.ngContentSelectors = [];\n    this.inI18nBlock = false;\n  } // HTML visitor\n\n\n  _createClass(HtmlAstToIvyAst, [{\n    key: \"visitElement\",\n    value: function visitElement(element) {\n      var _this156 = this;\n\n      var isI18nRootElement = isI18nRootNode(element.i18n);\n\n      if (isI18nRootElement) {\n        if (this.inI18nBlock) {\n          this.reportError('Cannot mark an element as translatable inside of a translatable section. Please remove the nested i18n marker.', element.sourceSpan);\n        }\n\n        this.inI18nBlock = true;\n      }\n\n      var preparsedElement = preparseElement(element);\n\n      if (preparsedElement.type === PreparsedElementType.SCRIPT) {\n        return null;\n      } else if (preparsedElement.type === PreparsedElementType.STYLE) {\n        var contents = textContents(element);\n\n        if (contents !== null) {\n          this.styles.push(contents);\n        }\n\n        return null;\n      } else if (preparsedElement.type === PreparsedElementType.STYLESHEET && isStyleUrlResolvable(preparsedElement.hrefAttr)) {\n        this.styleUrls.push(preparsedElement.hrefAttr);\n        return null;\n      } // Whether the element is a `<ng-template>`\n\n\n      var isTemplateElement = isNgTemplate(element.name);\n      var parsedProperties = [];\n      var boundEvents = [];\n      var variables = [];\n      var references = [];\n      var attributes = [];\n      var i18nAttrsMeta = {};\n      var templateParsedProperties = [];\n      var templateVariables = []; // Whether the element has any *-attribute\n\n      var elementHasInlineTemplate = false;\n\n      var _iterator10 = _createForOfIteratorHelper(element.attrs),\n          _step10;\n\n      try {\n        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n          var attribute = _step10.value;\n          var hasBinding = false;\n          var normalizedName = normalizeAttributeName(attribute.name); // `*attr` defines template bindings\n\n          var isTemplateBinding = false;\n\n          if (attribute.i18n) {\n            i18nAttrsMeta[attribute.name] = attribute.i18n;\n          }\n\n          if (normalizedName.startsWith(TEMPLATE_ATTR_PREFIX$2)) {\n            // *-attributes\n            if (elementHasInlineTemplate) {\n              this.reportError(\"Can't have multiple template bindings on one element. Use only one attribute prefixed with *\", attribute.sourceSpan);\n            }\n\n            isTemplateBinding = true;\n            elementHasInlineTemplate = true;\n            var templateValue = attribute.value;\n            var templateKey = normalizedName.substring(TEMPLATE_ATTR_PREFIX$2.length);\n            var parsedVariables = [];\n            var absoluteValueOffset = attribute.valueSpan ? attribute.valueSpan.start.offset : // If there is no value span the attribute does not have a value, like `attr` in\n            //`<div attr></div>`. In this case, point to one character beyond the last character of\n            // the attribute name.\n            attribute.sourceSpan.start.offset + attribute.name.length;\n            this.bindingParser.parseInlineTemplateBinding(templateKey, templateValue, attribute.sourceSpan, absoluteValueOffset, [], templateParsedProperties, parsedVariables);\n            templateVariables.push.apply(templateVariables, _toConsumableArray(parsedVariables.map(function (v) {\n              return new Variable(v.name, v.value, v.sourceSpan, v.valueSpan);\n            })));\n          } else {\n            // Check for variables, events, property bindings, interpolation\n            hasBinding = this.parseAttribute(isTemplateElement, attribute, [], parsedProperties, boundEvents, variables, references);\n          }\n\n          if (!hasBinding && !isTemplateBinding) {\n            // don't include the bindings as attributes as well in the AST\n            attributes.push(this.visitAttribute(attribute));\n          }\n        }\n      } catch (err) {\n        _iterator10.e(err);\n      } finally {\n        _iterator10.f();\n      }\n\n      var children = visitAll$1(preparsedElement.nonBindable ? NON_BINDABLE_VISITOR$1 : this, element.children);\n      var parsedElement;\n\n      if (preparsedElement.type === PreparsedElementType.NG_CONTENT) {\n        // `<ng-content>`\n        if (element.children && !element.children.every(function (node) {\n          return isEmptyTextNode(node) || isCommentNode(node);\n        })) {\n          this.reportError(\"<ng-content> element cannot have content.\", element.sourceSpan);\n        }\n\n        var selector = preparsedElement.selectAttr;\n        var attrs = element.attrs.map(function (attr) {\n          return _this156.visitAttribute(attr);\n        });\n        parsedElement = new Content(selector, attrs, element.sourceSpan, element.i18n);\n        this.ngContentSelectors.push(selector);\n      } else if (isTemplateElement) {\n        // `<ng-template>`\n        var _attrs = this.extractAttributes(element.name, parsedProperties, i18nAttrsMeta);\n\n        parsedElement = new Template(element.name, attributes, _attrs.bound, boundEvents, [\n          /* no template attributes */\n        ], children, references, variables, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);\n      } else {\n        var _attrs2 = this.extractAttributes(element.name, parsedProperties, i18nAttrsMeta);\n\n        parsedElement = new Element(element.name, attributes, _attrs2.bound, boundEvents, children, references, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, element.i18n);\n      }\n\n      if (elementHasInlineTemplate) {\n        // If this node is an inline-template (e.g. has *ngFor) then we need to create a template\n        // node that contains this node.\n        // Moreover, if the node is an element, then we need to hoist its attributes to the template\n        // node for matching against content projection selectors.\n        var _attrs3 = this.extractAttributes('ng-template', templateParsedProperties, i18nAttrsMeta);\n\n        var templateAttrs = [];\n\n        _attrs3.literal.forEach(function (attr) {\n          return templateAttrs.push(attr);\n        });\n\n        _attrs3.bound.forEach(function (attr) {\n          return templateAttrs.push(attr);\n        });\n\n        var hoistedAttrs = parsedElement instanceof Element ? {\n          attributes: parsedElement.attributes,\n          inputs: parsedElement.inputs,\n          outputs: parsedElement.outputs\n        } : {\n          attributes: [],\n          inputs: [],\n          outputs: []\n        }; // For <ng-template>s with structural directives on them, avoid passing i18n information to\n        // the wrapping template to prevent unnecessary i18n instructions from being generated. The\n        // necessary i18n meta information will be extracted from child elements.\n\n        var i18n = isTemplateElement && isI18nRootElement ? undefined : element.i18n; // TODO(pk): test for this case\n\n        parsedElement = new Template(parsedElement.name, hoistedAttrs.attributes, hoistedAttrs.inputs, hoistedAttrs.outputs, templateAttrs, [parsedElement], [\n          /* no references */\n        ], templateVariables, element.sourceSpan, element.startSourceSpan, element.endSourceSpan, i18n);\n      }\n\n      if (isI18nRootElement) {\n        this.inI18nBlock = false;\n      }\n\n      return parsedElement;\n    }\n  }, {\n    key: \"visitAttribute\",\n    value: function visitAttribute(attribute) {\n      return new TextAttribute(attribute.name, attribute.value, attribute.sourceSpan, attribute.valueSpan, attribute.i18n);\n    }\n  }, {\n    key: \"visitText\",\n    value: function visitText(text) {\n      return this._visitTextWithInterpolation(text.value, text.sourceSpan, text.i18n);\n    }\n  }, {\n    key: \"visitExpansion\",\n    value: function visitExpansion(expansion) {\n      var _this157 = this;\n\n      if (!expansion.i18n) {\n        // do not generate Icu in case it was created\n        // outside of i18n block in a template\n        return null;\n      }\n\n      if (!isI18nRootNode(expansion.i18n)) {\n        throw new Error(\"Invalid type \\\"\".concat(expansion.i18n.constructor, \"\\\" for \\\"i18n\\\" property of \").concat(expansion.sourceSpan.toString(), \". Expected a \\\"Message\\\"\"));\n      }\n\n      var message = expansion.i18n;\n      var vars = {};\n      var placeholders = {}; // extract VARs from ICUs - we process them separately while\n      // assembling resulting message via goog.getMsg function, since\n      // we need to pass them to top-level goog.getMsg call\n\n      Object.keys(message.placeholders).forEach(function (key) {\n        var value = message.placeholders[key];\n\n        if (key.startsWith(I18N_ICU_VAR_PREFIX)) {\n          var config = _this157.bindingParser.interpolationConfig; // ICU expression is a plain string, not wrapped into start\n          // and end tags, so we wrap it before passing to binding parser\n\n          var wrapped = \"\".concat(config.start).concat(value).concat(config.end);\n          vars[key] = _this157._visitTextWithInterpolation(wrapped, expansion.sourceSpan);\n        } else {\n          placeholders[key] = _this157._visitTextWithInterpolation(value, expansion.sourceSpan);\n        }\n      });\n      return new Icu(vars, placeholders, expansion.sourceSpan, message);\n    }\n  }, {\n    key: \"visitExpansionCase\",\n    value: function visitExpansionCase(expansionCase) {\n      return null;\n    }\n  }, {\n    key: \"visitComment\",\n    value: function visitComment(comment) {\n      return null;\n    } // convert view engine `ParsedProperty` to a format suitable for IVY\n\n  }, {\n    key: \"extractAttributes\",\n    value: function extractAttributes(elementName, properties, i18nPropsMeta) {\n      var _this158 = this;\n\n      var bound = [];\n      var literal = [];\n      properties.forEach(function (prop) {\n        var i18n = i18nPropsMeta[prop.name];\n\n        if (prop.isLiteral) {\n          literal.push(new TextAttribute(prop.name, prop.expression.source || '', prop.sourceSpan, undefined, i18n));\n        } else {\n          // Note that validation is skipped and property mapping is disabled\n          // due to the fact that we need to make sure a given prop is not an\n          // input of a directive and directive matching happens at runtime.\n          var bep = _this158.bindingParser.createBoundElementProperty(elementName, prop,\n          /* skipValidation */\n          true,\n          /* mapPropertyName */\n          false);\n\n          bound.push(BoundAttribute.fromBoundElementProperty(bep, i18n));\n        }\n      });\n      return {\n        bound: bound,\n        literal: literal\n      };\n    }\n  }, {\n    key: \"parseAttribute\",\n    value: function parseAttribute(isTemplateElement, attribute, matchableAttributes, parsedProperties, boundEvents, variables, references) {\n      var name = normalizeAttributeName(attribute.name);\n      var value = attribute.value;\n      var srcSpan = attribute.sourceSpan;\n      var absoluteOffset = attribute.valueSpan ? attribute.valueSpan.start.offset : srcSpan.start.offset;\n      var bindParts = name.match(BIND_NAME_REGEXP$1);\n      var hasBinding = false;\n\n      if (bindParts) {\n        hasBinding = true;\n\n        if (bindParts[KW_BIND_IDX$1] != null) {\n          this.bindingParser.parsePropertyBinding(bindParts[IDENT_KW_IDX$1], value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties);\n        } else if (bindParts[KW_LET_IDX$1]) {\n          if (isTemplateElement) {\n            var identifier = bindParts[IDENT_KW_IDX$1];\n            this.parseVariable(identifier, value, srcSpan, attribute.valueSpan, variables);\n          } else {\n            this.reportError(\"\\\"let-\\\" is only supported on ng-template elements.\", srcSpan);\n          }\n        } else if (bindParts[KW_REF_IDX$1]) {\n          var _identifier2 = bindParts[IDENT_KW_IDX$1];\n          this.parseReference(_identifier2, value, srcSpan, attribute.valueSpan, references);\n        } else if (bindParts[KW_ON_IDX$1]) {\n          var events = [];\n          this.bindingParser.parseEvent(bindParts[IDENT_KW_IDX$1], value, srcSpan, attribute.valueSpan || srcSpan, matchableAttributes, events);\n          addEvents(events, boundEvents);\n        } else if (bindParts[KW_BINDON_IDX$1]) {\n          this.bindingParser.parsePropertyBinding(bindParts[IDENT_KW_IDX$1], value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties);\n          this.parseAssignmentEvent(bindParts[IDENT_KW_IDX$1], value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents);\n        } else if (bindParts[KW_AT_IDX$1]) {\n          this.bindingParser.parseLiteralAttr(name, value, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties);\n        } else if (bindParts[IDENT_BANANA_BOX_IDX$1]) {\n          this.bindingParser.parsePropertyBinding(bindParts[IDENT_BANANA_BOX_IDX$1], value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties);\n          this.parseAssignmentEvent(bindParts[IDENT_BANANA_BOX_IDX$1], value, srcSpan, attribute.valueSpan, matchableAttributes, boundEvents);\n        } else if (bindParts[IDENT_PROPERTY_IDX$1]) {\n          this.bindingParser.parsePropertyBinding(bindParts[IDENT_PROPERTY_IDX$1], value, false, srcSpan, absoluteOffset, attribute.valueSpan, matchableAttributes, parsedProperties);\n        } else if (bindParts[IDENT_EVENT_IDX$1]) {\n          var _events = [];\n          this.bindingParser.parseEvent(bindParts[IDENT_EVENT_IDX$1], value, srcSpan, attribute.valueSpan || srcSpan, matchableAttributes, _events);\n          addEvents(_events, boundEvents);\n        }\n      } else {\n        hasBinding = this.bindingParser.parsePropertyInterpolation(name, value, srcSpan, attribute.valueSpan, matchableAttributes, parsedProperties);\n      }\n\n      return hasBinding;\n    }\n  }, {\n    key: \"_visitTextWithInterpolation\",\n    value: function _visitTextWithInterpolation(value, sourceSpan, i18n) {\n      var valueNoNgsp = replaceNgsp(value);\n      var expr = this.bindingParser.parseInterpolation(valueNoNgsp, sourceSpan);\n      return expr ? new BoundText(expr, sourceSpan, i18n) : new Text(valueNoNgsp, sourceSpan);\n    }\n  }, {\n    key: \"parseVariable\",\n    value: function parseVariable(identifier, value, sourceSpan, valueSpan, variables) {\n      if (identifier.indexOf('-') > -1) {\n        this.reportError(\"\\\"-\\\" is not allowed in variable names\", sourceSpan);\n      } else if (identifier.length === 0) {\n        this.reportError(\"Variable does not have a name\", sourceSpan);\n      }\n\n      variables.push(new Variable(identifier, value, sourceSpan, valueSpan));\n    }\n  }, {\n    key: \"parseReference\",\n    value: function parseReference(identifier, value, sourceSpan, valueSpan, references) {\n      if (identifier.indexOf('-') > -1) {\n        this.reportError(\"\\\"-\\\" is not allowed in reference names\", sourceSpan);\n      } else if (identifier.length === 0) {\n        this.reportError(\"Reference does not have a name\", sourceSpan);\n      }\n\n      references.push(new Reference(identifier, value, sourceSpan, valueSpan));\n    }\n  }, {\n    key: \"parseAssignmentEvent\",\n    value: function parseAssignmentEvent(name, expression, sourceSpan, valueSpan, targetMatchableAttrs, boundEvents) {\n      var events = [];\n      this.bindingParser.parseEvent(\"\".concat(name, \"Change\"), \"\".concat(expression, \"=$event\"), sourceSpan, valueSpan || sourceSpan, targetMatchableAttrs, events);\n      addEvents(events, boundEvents);\n    }\n  }, {\n    key: \"reportError\",\n    value: function reportError(message, sourceSpan) {\n      var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ParseErrorLevel.ERROR;\n      this.errors.push(new ParseError(sourceSpan, message, level));\n    }\n  }]);\n\n  return HtmlAstToIvyAst;\n}();\n\nvar NonBindableVisitor$1 = /*#__PURE__*/function () {\n  function NonBindableVisitor$1() {\n    _classCallCheck(this, NonBindableVisitor$1);\n  }\n\n  _createClass(NonBindableVisitor$1, [{\n    key: \"visitElement\",\n    value: function visitElement(ast) {\n      var preparsedElement = preparseElement(ast);\n\n      if (preparsedElement.type === PreparsedElementType.SCRIPT || preparsedElement.type === PreparsedElementType.STYLE || preparsedElement.type === PreparsedElementType.STYLESHEET) {\n        // Skipping <script> for security reasons\n        // Skipping <style> and stylesheets as we already processed them\n        // in the StyleCompiler\n        return null;\n      }\n\n      var children = visitAll$1(this, ast.children, null);\n      return new Element(ast.name, visitAll$1(this, ast.attrs),\n      /* inputs */\n      [],\n      /* outputs */\n      [], children,\n      /* references */\n      [], ast.sourceSpan, ast.startSourceSpan, ast.endSourceSpan);\n    }\n  }, {\n    key: \"visitComment\",\n    value: function visitComment(comment) {\n      return null;\n    }\n  }, {\n    key: \"visitAttribute\",\n    value: function visitAttribute(attribute) {\n      return new TextAttribute(attribute.name, attribute.value, attribute.sourceSpan, undefined, attribute.i18n);\n    }\n  }, {\n    key: \"visitText\",\n    value: function visitText(text) {\n      return new Text(text.value, text.sourceSpan);\n    }\n  }, {\n    key: \"visitExpansion\",\n    value: function visitExpansion(expansion) {\n      return null;\n    }\n  }, {\n    key: \"visitExpansionCase\",\n    value: function visitExpansionCase(expansionCase) {\n      return null;\n    }\n  }]);\n\n  return NonBindableVisitor$1;\n}();\n\nvar NON_BINDABLE_VISITOR$1 = new NonBindableVisitor$1();\n\nfunction normalizeAttributeName(attrName) {\n  return /^data-/i.test(attrName) ? attrName.substring(5) : attrName;\n}\n\nfunction addEvents(events, boundEvents) {\n  boundEvents.push.apply(boundEvents, _toConsumableArray(events.map(function (e) {\n    return BoundEvent.fromParsedEvent(e);\n  })));\n}\n\nfunction isEmptyTextNode(node) {\n  return node instanceof Text$3 && node.value.trim().length == 0;\n}\n\nfunction isCommentNode(node) {\n  return node instanceof Comment;\n}\n\nfunction textContents(node) {\n  if (node.children.length !== 1 || !(node.children[0] instanceof Text$3)) {\n    return null;\n  } else {\n    return node.children[0].value;\n  }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar TagType;\n\n(function (TagType) {\n  TagType[TagType[\"ELEMENT\"] = 0] = \"ELEMENT\";\n  TagType[TagType[\"TEMPLATE\"] = 1] = \"TEMPLATE\";\n  TagType[TagType[\"PROJECTION\"] = 2] = \"PROJECTION\";\n})(TagType || (TagType = {}));\n/**\n * Generates an object that is used as a shared state between parent and all child contexts.\n */\n\n\nfunction setupRegistry() {\n  return {\n    getUniqueId: getSeqNumberGenerator(),\n    icus: new Map()\n  };\n}\n/**\n * I18nContext is a helper class which keeps track of all i18n-related aspects\n * (accumulates placeholders, bindings, etc) between i18nStart and i18nEnd instructions.\n *\n * When we enter a nested template, the top-level context is being passed down\n * to the nested component, which uses this context to generate a child instance\n * of I18nContext class (to handle nested template) and at the end, reconciles it back\n * with the parent context.\n *\n * @param index Instruction index of i18nStart, which initiates this context\n * @param ref Reference to a translation const that represents the content if thus context\n * @param level Nestng level defined for child contexts\n * @param templateIndex Instruction index of a template which this context belongs to\n * @param meta Meta information (id, meaning, description, etc) associated with this context\n */\n\n\nvar I18nContext = /*#__PURE__*/function () {\n  function I18nContext(index, ref) {\n    var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var templateIndex = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    var meta = arguments.length > 4 ? arguments[4] : undefined;\n    var registry = arguments.length > 5 ? arguments[5] : undefined;\n\n    _classCallCheck(this, I18nContext);\n\n    this.index = index;\n    this.ref = ref;\n    this.level = level;\n    this.templateIndex = templateIndex;\n    this.meta = meta;\n    this.registry = registry;\n    this.bindings = new Set();\n    this.placeholders = new Map();\n    this.isEmitted = false;\n    this._unresolvedCtxCount = 0;\n    this._registry = registry || setupRegistry();\n    this.id = this._registry.getUniqueId();\n  }\n\n  _createClass(I18nContext, [{\n    key: \"appendTag\",\n    value: function appendTag(type, node, index, closed) {\n      if (node.isVoid && closed) {\n        return; // ignore \"close\" for void tags\n      }\n\n      var ph = node.isVoid || !closed ? node.startName : node.closeName;\n      var content = {\n        type: type,\n        index: index,\n        ctx: this.id,\n        isVoid: node.isVoid,\n        closed: closed\n      };\n      updatePlaceholderMap(this.placeholders, ph, content);\n    }\n  }, {\n    key: \"getSerializedPlaceholders\",\n    value: function getSerializedPlaceholders() {\n      var result = new Map();\n      this.placeholders.forEach(function (values, key) {\n        return result.set(key, values.map(serializePlaceholderValue));\n      });\n      return result;\n    } // public API to accumulate i18n-related content\n\n  }, {\n    key: \"appendBinding\",\n    value: function appendBinding(binding) {\n      this.bindings.add(binding);\n    }\n  }, {\n    key: \"appendIcu\",\n    value: function appendIcu(name, ref) {\n      updatePlaceholderMap(this._registry.icus, name, ref);\n    }\n  }, {\n    key: \"appendBoundText\",\n    value: function appendBoundText(node) {\n      var _this159 = this;\n\n      var phs = assembleBoundTextPlaceholders(node, this.bindings.size, this.id);\n      phs.forEach(function (values, key) {\n        return updatePlaceholderMap.apply(void 0, [_this159.placeholders, key].concat(_toConsumableArray(values)));\n      });\n    }\n  }, {\n    key: \"appendTemplate\",\n    value: function appendTemplate(node, index) {\n      // add open and close tags at the same time,\n      // since we process nested templates separately\n      this.appendTag(TagType.TEMPLATE, node, index, false);\n      this.appendTag(TagType.TEMPLATE, node, index, true);\n      this._unresolvedCtxCount++;\n    }\n  }, {\n    key: \"appendElement\",\n    value: function appendElement(node, index, closed) {\n      this.appendTag(TagType.ELEMENT, node, index, closed);\n    }\n  }, {\n    key: \"appendProjection\",\n    value: function appendProjection(node, index) {\n      // add open and close tags at the same time,\n      // since we process projected content separately\n      this.appendTag(TagType.PROJECTION, node, index, false);\n      this.appendTag(TagType.PROJECTION, node, index, true);\n    }\n    /**\n     * Generates an instance of a child context based on the root one,\n     * when we enter a nested template within I18n section.\n     *\n     * @param index Instruction index of corresponding i18nStart, which initiates this context\n     * @param templateIndex Instruction index of a template which this context belongs to\n     * @param meta Meta information (id, meaning, description, etc) associated with this context\n     *\n     * @returns I18nContext instance\n     */\n\n  }, {\n    key: \"forkChildContext\",\n    value: function forkChildContext(index, templateIndex, meta) {\n      return new I18nContext(index, this.ref, this.level + 1, templateIndex, meta, this._registry);\n    }\n    /**\n     * Reconciles child context into parent one once the end of the i18n block is reached (i18nEnd).\n     *\n     * @param context Child I18nContext instance to be reconciled with parent context.\n     */\n\n  }, {\n    key: \"reconcileChildContext\",\n    value: function reconcileChildContext(context) {\n      var _this160 = this;\n\n      // set the right context id for open and close\n      // template tags, so we can use it as sub-block ids\n      ['start', 'close'].forEach(function (op) {\n        var key = context.meta[\"\".concat(op, \"Name\")];\n        var phs = _this160.placeholders.get(key) || [];\n        var tag = phs.find(findTemplateFn(_this160.id, context.templateIndex));\n\n        if (tag) {\n          tag.ctx = context.id;\n        }\n      }); // reconcile placeholders\n\n      var childPhs = context.placeholders;\n      childPhs.forEach(function (values, key) {\n        var phs = _this160.placeholders.get(key);\n\n        if (!phs) {\n          _this160.placeholders.set(key, values);\n\n          return;\n        } // try to find matching template...\n\n\n        var tmplIdx = phs.findIndex(findTemplateFn(context.id, context.templateIndex));\n\n        if (tmplIdx >= 0) {\n          // ... if found - replace it with nested template content\n          var isCloseTag = key.startsWith('CLOSE');\n          var isTemplateTag = key.endsWith('NG-TEMPLATE');\n\n          if (isTemplateTag) {\n            // current template's content is placed before or after\n            // parent template tag, depending on the open/close atrribute\n            phs.splice.apply(phs, [tmplIdx + (isCloseTag ? 0 : 1), 0].concat(_toConsumableArray(values)));\n          } else {\n            var idx = isCloseTag ? values.length - 1 : 0;\n            values[idx].tmpl = phs[tmplIdx];\n            phs.splice.apply(phs, [tmplIdx, 1].concat(_toConsumableArray(values)));\n          }\n        } else {\n          // ... otherwise just append content to placeholder value\n          phs.push.apply(phs, _toConsumableArray(values));\n        }\n\n        _this160.placeholders.set(key, phs);\n      });\n      this._unresolvedCtxCount--;\n    }\n  }, {\n    key: \"icus\",\n    get: function get() {\n      return this._registry.icus;\n    }\n  }, {\n    key: \"isRoot\",\n    get: function get() {\n      return this.level === 0;\n    }\n  }, {\n    key: \"isResolved\",\n    get: function get() {\n      return this._unresolvedCtxCount === 0;\n    }\n  }]);\n\n  return I18nContext;\n}(); //\n// Helper methods\n//\n\n\nfunction wrap(symbol, index, contextId, closed) {\n  var state = closed ? '/' : '';\n  return wrapI18nPlaceholder(\"\".concat(state).concat(symbol).concat(index), contextId);\n}\n\nfunction wrapTag(symbol, _ref13, closed) {\n  var index = _ref13.index,\n      ctx = _ref13.ctx,\n      isVoid = _ref13.isVoid;\n  return isVoid ? wrap(symbol, index, ctx) + wrap(symbol, index, ctx, true) : wrap(symbol, index, ctx, closed);\n}\n\nfunction findTemplateFn(ctx, templateIndex) {\n  return function (token) {\n    return typeof token === 'object' && token.type === TagType.TEMPLATE && token.index === templateIndex && token.ctx === ctx;\n  };\n}\n\nfunction serializePlaceholderValue(value) {\n  var element = function element(data, closed) {\n    return wrapTag('#', data, closed);\n  };\n\n  var template = function template(data, closed) {\n    return wrapTag('*', data, closed);\n  };\n\n  var projection = function projection(data, closed) {\n    return wrapTag('!', data, closed);\n  };\n\n  switch (value.type) {\n    case TagType.ELEMENT:\n      // close element tag\n      if (value.closed) {\n        return element(value, true) + (value.tmpl ? template(value.tmpl, true) : '');\n      } // open element tag that also initiates a template\n\n\n      if (value.tmpl) {\n        return template(value.tmpl) + element(value) + (value.isVoid ? template(value.tmpl, true) : '');\n      }\n\n      return element(value);\n\n    case TagType.TEMPLATE:\n      return template(value, value.closed);\n\n    case TagType.PROJECTION:\n      return projection(value, value.closed);\n\n    default:\n      return value;\n  }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar IcuSerializerVisitor = /*#__PURE__*/function () {\n  function IcuSerializerVisitor() {\n    _classCallCheck(this, IcuSerializerVisitor);\n  }\n\n  _createClass(IcuSerializerVisitor, [{\n    key: \"visitText\",\n    value: function visitText(text) {\n      return text.value;\n    }\n  }, {\n    key: \"visitContainer\",\n    value: function visitContainer(container) {\n      var _this161 = this;\n\n      return container.children.map(function (child) {\n        return child.visit(_this161);\n      }).join('');\n    }\n  }, {\n    key: \"visitIcu\",\n    value: function visitIcu(icu) {\n      var _this162 = this;\n\n      var strCases = Object.keys(icu.cases).map(function (k) {\n        return \"\".concat(k, \" {\").concat(icu.cases[k].visit(_this162), \"}\");\n      });\n      var result = \"{\".concat(icu.expressionPlaceholder, \", \").concat(icu.type, \", \").concat(strCases.join(' '), \"}\");\n      return result;\n    }\n  }, {\n    key: \"visitTagPlaceholder\",\n    value: function visitTagPlaceholder(ph) {\n      var _this163 = this;\n\n      return ph.isVoid ? this.formatPh(ph.startName) : \"\".concat(this.formatPh(ph.startName)).concat(ph.children.map(function (child) {\n        return child.visit(_this163);\n      }).join('')).concat(this.formatPh(ph.closeName));\n    }\n  }, {\n    key: \"visitPlaceholder\",\n    value: function visitPlaceholder(ph) {\n      return this.formatPh(ph.name);\n    }\n  }, {\n    key: \"visitIcuPlaceholder\",\n    value: function visitIcuPlaceholder(ph, context) {\n      return this.formatPh(ph.name);\n    }\n  }, {\n    key: \"formatPh\",\n    value: function formatPh(value) {\n      return \"{\".concat(formatI18nPlaceholderName(value,\n      /* useCamelCase */\n      false), \"}\");\n    }\n  }]);\n\n  return IcuSerializerVisitor;\n}();\n\nvar serializer = new IcuSerializerVisitor();\n\nfunction serializeIcuNode(icu) {\n  return icu.visit(serializer);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar TAG_TO_PLACEHOLDER_NAMES = {\n  'A': 'LINK',\n  'B': 'BOLD_TEXT',\n  'BR': 'LINE_BREAK',\n  'EM': 'EMPHASISED_TEXT',\n  'H1': 'HEADING_LEVEL1',\n  'H2': 'HEADING_LEVEL2',\n  'H3': 'HEADING_LEVEL3',\n  'H4': 'HEADING_LEVEL4',\n  'H5': 'HEADING_LEVEL5',\n  'H6': 'HEADING_LEVEL6',\n  'HR': 'HORIZONTAL_RULE',\n  'I': 'ITALIC_TEXT',\n  'LI': 'LIST_ITEM',\n  'LINK': 'MEDIA_LINK',\n  'OL': 'ORDERED_LIST',\n  'P': 'PARAGRAPH',\n  'Q': 'QUOTATION',\n  'S': 'STRIKETHROUGH_TEXT',\n  'SMALL': 'SMALL_TEXT',\n  'SUB': 'SUBSTRIPT',\n  'SUP': 'SUPERSCRIPT',\n  'TBODY': 'TABLE_BODY',\n  'TD': 'TABLE_CELL',\n  'TFOOT': 'TABLE_FOOTER',\n  'TH': 'TABLE_HEADER_CELL',\n  'THEAD': 'TABLE_HEADER',\n  'TR': 'TABLE_ROW',\n  'TT': 'MONOSPACED_TEXT',\n  'U': 'UNDERLINED_TEXT',\n  'UL': 'UNORDERED_LIST'\n};\n/**\n * Creates unique names for placeholder with different content.\n *\n * Returns the same placeholder name when the content is identical.\n */\n\nvar PlaceholderRegistry = /*#__PURE__*/function () {\n  function PlaceholderRegistry() {\n    _classCallCheck(this, PlaceholderRegistry);\n\n    // Count the occurrence of the base name top generate a unique name\n    this._placeHolderNameCounts = {}; // Maps signature to placeholder names\n\n    this._signatureToName = {};\n  }\n\n  _createClass(PlaceholderRegistry, [{\n    key: \"getStartTagPlaceholderName\",\n    value: function getStartTagPlaceholderName(tag, attrs, isVoid) {\n      var signature = this._hashTag(tag, attrs, isVoid);\n\n      if (this._signatureToName[signature]) {\n        return this._signatureToName[signature];\n      }\n\n      var upperTag = tag.toUpperCase();\n      var baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || \"TAG_\".concat(upperTag);\n\n      var name = this._generateUniqueName(isVoid ? baseName : \"START_\".concat(baseName));\n\n      this._signatureToName[signature] = name;\n      return name;\n    }\n  }, {\n    key: \"getCloseTagPlaceholderName\",\n    value: function getCloseTagPlaceholderName(tag) {\n      var signature = this._hashClosingTag(tag);\n\n      if (this._signatureToName[signature]) {\n        return this._signatureToName[signature];\n      }\n\n      var upperTag = tag.toUpperCase();\n      var baseName = TAG_TO_PLACEHOLDER_NAMES[upperTag] || \"TAG_\".concat(upperTag);\n\n      var name = this._generateUniqueName(\"CLOSE_\".concat(baseName));\n\n      this._signatureToName[signature] = name;\n      return name;\n    }\n  }, {\n    key: \"getPlaceholderName\",\n    value: function getPlaceholderName(name, content) {\n      var upperName = name.toUpperCase();\n      var signature = \"PH: \".concat(upperName, \"=\").concat(content);\n\n      if (this._signatureToName[signature]) {\n        return this._signatureToName[signature];\n      }\n\n      var uniqueName = this._generateUniqueName(upperName);\n\n      this._signatureToName[signature] = uniqueName;\n      return uniqueName;\n    }\n  }, {\n    key: \"getUniquePlaceholder\",\n    value: function getUniquePlaceholder(name) {\n      return this._generateUniqueName(name.toUpperCase());\n    } // Generate a hash for a tag - does not take attribute order into account\n\n  }, {\n    key: \"_hashTag\",\n    value: function _hashTag(tag, attrs, isVoid) {\n      var start = \"<\".concat(tag);\n      var strAttrs = Object.keys(attrs).sort().map(function (name) {\n        return \" \".concat(name, \"=\").concat(attrs[name]);\n      }).join('');\n      var end = isVoid ? '/>' : \"></\".concat(tag, \">\");\n      return start + strAttrs + end;\n    }\n  }, {\n    key: \"_hashClosingTag\",\n    value: function _hashClosingTag(tag) {\n      return this._hashTag(\"/\".concat(tag), {}, false);\n    }\n  }, {\n    key: \"_generateUniqueName\",\n    value: function _generateUniqueName(base) {\n      var seen = this._placeHolderNameCounts.hasOwnProperty(base);\n\n      if (!seen) {\n        this._placeHolderNameCounts[base] = 1;\n        return base;\n      }\n\n      var id = this._placeHolderNameCounts[base];\n      this._placeHolderNameCounts[base] = id + 1;\n      return \"\".concat(base, \"_\").concat(id);\n    }\n  }]);\n\n  return PlaceholderRegistry;\n}();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar _expParser = new Parser$1(new Lexer());\n/**\n * Returns a function converting html nodes to an i18n Message given an interpolationConfig\n */\n\n\nfunction createI18nMessageFactory(interpolationConfig) {\n  var visitor = new _I18nVisitor(_expParser, interpolationConfig);\n  return function (nodes, meaning, description, customId, visitNodeFn) {\n    return visitor.toI18nMessage(nodes, meaning, description, customId, visitNodeFn);\n  };\n}\n\nfunction noopVisitNodeFn(_html, i18n) {\n  return i18n;\n}\n\nvar _I18nVisitor = /*#__PURE__*/function () {\n  function _I18nVisitor(_expressionParser, _interpolationConfig) {\n    _classCallCheck(this, _I18nVisitor);\n\n    this._expressionParser = _expressionParser;\n    this._interpolationConfig = _interpolationConfig;\n  }\n\n  _createClass(_I18nVisitor, [{\n    key: \"toI18nMessage\",\n    value: function toI18nMessage(nodes) {\n      var meaning = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n      var description = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n      var customId = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n      var visitNodeFn = arguments.length > 4 ? arguments[4] : undefined;\n      var context = {\n        isIcu: nodes.length == 1 && nodes[0] instanceof Expansion,\n        icuDepth: 0,\n        placeholderRegistry: new PlaceholderRegistry(),\n        placeholderToContent: {},\n        placeholderToMessage: {},\n        visitNodeFn: visitNodeFn || noopVisitNodeFn\n      };\n      var i18nodes = visitAll$1(this, nodes, context);\n      return new Message(i18nodes, context.placeholderToContent, context.placeholderToMessage, meaning, description, customId);\n    }\n  }, {\n    key: \"visitElement\",\n    value: function visitElement(el, context) {\n      var children = visitAll$1(this, el.children, context);\n      var attrs = {};\n      el.attrs.forEach(function (attr) {\n        // Do not visit the attributes, translatable ones are top-level ASTs\n        attrs[attr.name] = attr.value;\n      });\n      var isVoid = getHtmlTagDefinition(el.name).isVoid;\n      var startPhName = context.placeholderRegistry.getStartTagPlaceholderName(el.name, attrs, isVoid);\n      context.placeholderToContent[startPhName] = el.sourceSpan.toString();\n      var closePhName = '';\n\n      if (!isVoid) {\n        closePhName = context.placeholderRegistry.getCloseTagPlaceholderName(el.name);\n        context.placeholderToContent[closePhName] = \"</\".concat(el.name, \">\");\n      }\n\n      var node = new TagPlaceholder(el.name, attrs, startPhName, closePhName, children, isVoid, el.sourceSpan);\n      return context.visitNodeFn(el, node);\n    }\n  }, {\n    key: \"visitAttribute\",\n    value: function visitAttribute(attribute, context) {\n      var node = this._visitTextWithInterpolation(attribute.value, attribute.sourceSpan, context);\n\n      return context.visitNodeFn(attribute, node);\n    }\n  }, {\n    key: \"visitText\",\n    value: function visitText(text, context) {\n      var node = this._visitTextWithInterpolation(text.value, text.sourceSpan, context);\n\n      return context.visitNodeFn(text, node);\n    }\n  }, {\n    key: \"visitComment\",\n    value: function visitComment(comment, context) {\n      return null;\n    }\n  }, {\n    key: \"visitExpansion\",\n    value: function visitExpansion(icu, context) {\n      var _this164 = this;\n\n      context.icuDepth++;\n      var i18nIcuCases = {};\n      var i18nIcu = new Icu$1(icu.switchValue, icu.type, i18nIcuCases, icu.sourceSpan);\n      icu.cases.forEach(function (caze) {\n        i18nIcuCases[caze.value] = new Container(caze.expression.map(function (node) {\n          return node.visit(_this164, context);\n        }), caze.expSourceSpan);\n      });\n      context.icuDepth--;\n\n      if (context.isIcu || context.icuDepth > 0) {\n        // Returns an ICU node when:\n        // - the message (vs a part of the message) is an ICU message, or\n        // - the ICU message is nested.\n        var expPh = context.placeholderRegistry.getUniquePlaceholder(\"VAR_\".concat(icu.type));\n        i18nIcu.expressionPlaceholder = expPh;\n        context.placeholderToContent[expPh] = icu.switchValue;\n        return context.visitNodeFn(icu, i18nIcu);\n      } // Else returns a placeholder\n      // ICU placeholders should not be replaced with their original content but with the their\n      // translations.\n      // TODO(vicb): add a html.Node -> i18n.Message cache to avoid having to re-create the msg\n\n\n      var phName = context.placeholderRegistry.getPlaceholderName('ICU', icu.sourceSpan.toString());\n      context.placeholderToMessage[phName] = this.toI18nMessage([icu], '', '', '', undefined);\n      var node = new IcuPlaceholder(i18nIcu, phName, icu.sourceSpan);\n      return context.visitNodeFn(icu, node);\n    }\n  }, {\n    key: \"visitExpansionCase\",\n    value: function visitExpansionCase(_icuCase, _context) {\n      throw new Error('Unreachable code');\n    }\n  }, {\n    key: \"_visitTextWithInterpolation\",\n    value: function _visitTextWithInterpolation(text, sourceSpan, context) {\n      var splitInterpolation = this._expressionParser.splitInterpolation(text, sourceSpan.start.toString(), this._interpolationConfig);\n\n      if (!splitInterpolation) {\n        // No expression, return a single text\n        return new Text$1(text, sourceSpan);\n      } // Return a group of text + expressions\n\n\n      var nodes = [];\n      var container = new Container(nodes, sourceSpan);\n      var _this$_interpolationC = this._interpolationConfig,\n          sDelimiter = _this$_interpolationC.start,\n          eDelimiter = _this$_interpolationC.end;\n\n      for (var i = 0; i < splitInterpolation.strings.length - 1; i++) {\n        var expression = splitInterpolation.expressions[i];\n        var baseName = _extractPlaceholderName(expression) || 'INTERPOLATION';\n        var phName = context.placeholderRegistry.getPlaceholderName(baseName, expression);\n\n        if (splitInterpolation.strings[i].length) {\n          // No need to add empty strings\n          nodes.push(new Text$1(splitInterpolation.strings[i], sourceSpan));\n        }\n\n        nodes.push(new Placeholder(expression, phName, sourceSpan));\n        context.placeholderToContent[phName] = sDelimiter + expression + eDelimiter;\n      } // The last index contains no expression\n\n\n      var lastStringIdx = splitInterpolation.strings.length - 1;\n\n      if (splitInterpolation.strings[lastStringIdx].length) {\n        nodes.push(new Text$1(splitInterpolation.strings[lastStringIdx], sourceSpan));\n      }\n\n      return container;\n    }\n  }]);\n\n  return _I18nVisitor;\n}();\n\nvar _CUSTOM_PH_EXP = /\\/\\/[\\s\\S]*i18n[\\s\\S]*\\([\\s\\S]*ph[\\s\\S]*=[\\s\\S]*(\"|')([\\s\\S]*?)\\1[\\s\\S]*\\)/g;\n\nfunction _extractPlaceholderName(input) {\n  return input.split(_CUSTOM_PH_EXP)[2];\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nvar setI18nRefs = function setI18nRefs(htmlNode, i18nNode) {\n  if (htmlNode instanceof NodeWithI18n) {\n    if (i18nNode instanceof IcuPlaceholder && htmlNode.i18n instanceof Message) {\n      // This html node represents an ICU but this is a second processing pass, and the legacy id\n      // was computed in the previous pass and stored in the `i18n` property as a message.\n      // We are about to wipe out that property so capture the previous message to be reused when\n      // generating the message for this ICU later. See `_generateI18nMessage()`.\n      i18nNode.previousMessage = htmlNode.i18n;\n    }\n\n    htmlNode.i18n = i18nNode;\n  }\n\n  return i18nNode;\n};\n/**\n * This visitor walks over HTML parse tree and converts information stored in\n * i18n-related attributes (\"i18n\" and \"i18n-*\") into i18n meta object that is\n * stored with other element's and attribute's information.\n */\n\n\nvar I18nMetaVisitor = /*#__PURE__*/function () {\n  function I18nMetaVisitor() {\n    var interpolationConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_INTERPOLATION_CONFIG;\n    var keepI18nAttrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var enableI18nLegacyMessageIdFormat = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    _classCallCheck(this, I18nMetaVisitor);\n\n    this.interpolationConfig = interpolationConfig;\n    this.keepI18nAttrs = keepI18nAttrs;\n    this.enableI18nLegacyMessageIdFormat = enableI18nLegacyMessageIdFormat; // whether visited nodes contain i18n information\n\n    this.hasI18nMeta = false; // i18n message generation factory\n\n    this._createI18nMessage = createI18nMessageFactory(this.interpolationConfig);\n  }\n\n  _createClass(I18nMetaVisitor, [{\n    key: \"_generateI18nMessage\",\n    value: function _generateI18nMessage(nodes) {\n      var meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n      var visitNodeFn = arguments.length > 2 ? arguments[2] : undefined;\n\n      var _this$_parseMetadata = this._parseMetadata(meta),\n          meaning = _this$_parseMetadata.meaning,\n          description = _this$_parseMetadata.description,\n          customId = _this$_parseMetadata.customId;\n\n      var message = this._createI18nMessage(nodes, meaning, description, customId, visitNodeFn);\n\n      this._setMessageId(message, meta);\n\n      this._setLegacyIds(message, meta);\n\n      return message;\n    }\n  }, {\n    key: \"visitElement\",\n    value: function visitElement(element) {\n      if (hasI18nAttrs(element)) {\n        this.hasI18nMeta = true;\n        var attrs = [];\n        var attrsMeta = {};\n\n        var _iterator11 = _createForOfIteratorHelper(element.attrs),\n            _step11;\n\n        try {\n          for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n            var _attr = _step11.value;\n\n            if (_attr.name === I18N_ATTR) {\n              // root 'i18n' node attribute\n              var i18n = element.i18n || _attr.value;\n\n              var message = this._generateI18nMessage(element.children, i18n, setI18nRefs); // do not assign empty i18n meta\n\n\n              if (message.nodes.length) {\n                element.i18n = message;\n              }\n            } else if (_attr.name.startsWith(I18N_ATTR_PREFIX)) {\n              // 'i18n-*' attributes\n              var key = _attr.name.slice(I18N_ATTR_PREFIX.length);\n\n              attrsMeta[key] = _attr.value;\n            } else {\n              // non-i18n attributes\n              attrs.push(_attr);\n            }\n          } // set i18n meta for attributes\n\n        } catch (err) {\n          _iterator11.e(err);\n        } finally {\n          _iterator11.f();\n        }\n\n        if (Object.keys(attrsMeta).length) {\n          var _iterator12 = _createForOfIteratorHelper(attrs),\n              _step12;\n\n          try {\n            for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n              var attr = _step12.value;\n              var meta = attrsMeta[attr.name]; // do not create translation for empty attributes\n\n              if (meta !== undefined && attr.value) {\n                attr.i18n = this._generateI18nMessage([attr], attr.i18n || meta);\n              }\n            }\n          } catch (err) {\n            _iterator12.e(err);\n          } finally {\n            _iterator12.f();\n          }\n        }\n\n        if (!this.keepI18nAttrs) {\n          // update element's attributes,\n          // keeping only non-i18n related ones\n          element.attrs = attrs;\n        }\n      }\n\n      visitAll$1(this, element.children, element.i18n);\n      return element;\n    }\n  }, {\n    key: \"visitExpansion\",\n    value: function visitExpansion(expansion, currentMessage) {\n      var message;\n      var meta = expansion.i18n;\n      this.hasI18nMeta = true;\n\n      if (meta instanceof IcuPlaceholder) {\n        // set ICU placeholder name (e.g. \"ICU_1\"),\n        // generated while processing root element contents,\n        // so we can reference it when we output translation\n        var name = meta.name;\n        message = this._generateI18nMessage([expansion], meta);\n        var icu = icuFromI18nMessage(message);\n        icu.name = name;\n      } else {\n        // ICU is a top level message, try to use metadata from container element if provided via\n        // `context` argument. Note: context may not be available for standalone ICUs (without\n        // wrapping element), so fallback to ICU metadata in this case.\n        message = this._generateI18nMessage([expansion], currentMessage || meta);\n      }\n\n      expansion.i18n = message;\n      return expansion;\n    }\n  }, {\n    key: \"visitText\",\n    value: function visitText(text) {\n      return text;\n    }\n  }, {\n    key: \"visitAttribute\",\n    value: function visitAttribute(attribute) {\n      return attribute;\n    }\n  }, {\n    key: \"visitComment\",\n    value: function visitComment(comment) {\n      return comment;\n    }\n  }, {\n    key: \"visitExpansionCase\",\n    value: function visitExpansionCase(expansionCase) {\n      return expansionCase;\n    }\n    /**\n     * Parse the general form `meta` passed into extract the explicit metadata needed to create a\n     * `Message`.\n     *\n     * There are three possibilities for the `meta` variable\n     * 1) a string from an `i18n` template attribute: parse it to extract the metadata values.\n     * 2) a `Message` from a previous processing pass: reuse the metadata values in the message.\n     * 4) other: ignore this and just process the message metadata as normal\n     *\n     * @param meta the bucket that holds information about the message\n     * @returns the parsed metadata.\n     */\n\n  }, {\n    key: \"_parseMetadata\",\n    value: function _parseMetadata(meta) {\n      return typeof meta === 'string' ? parseI18nMeta(meta) : meta instanceof Message ? meta : {};\n    }\n    /**\n     * Generate (or restore) message id if not specified already.\n     */\n\n  }, {\n    key: \"_setMessageId\",\n    value: function _setMessageId(message, meta) {\n      if (!message.id) {\n        message.id = meta instanceof Message && meta.id || decimalDigest(message);\n      }\n    }\n    /**\n     * Update the `message` with a `legacyId` if necessary.\n     *\n     * @param message the message whose legacy id should be set\n     * @param meta information about the message being processed\n     */\n\n  }, {\n    key: \"_setLegacyIds\",\n    value: function _setLegacyIds(message, meta) {\n      if (this.enableI18nLegacyMessageIdFormat) {\n        message.legacyIds = [computeDigest(message), computeDecimalDigest(message)];\n      } else if (typeof meta !== 'string') {\n        // This occurs if we are doing the 2nd pass after whitespace removal (see `parseTemplate()` in\n        // `packages/compiler/src/render3/view/template.ts`).\n        // In that case we want to reuse the legacy message generated in the 1st pass (see\n        // `setI18nRefs()`).\n        var previousMessage = meta instanceof Message ? meta : meta instanceof IcuPlaceholder ? meta.previousMessage : undefined;\n        message.legacyIds = previousMessage ? previousMessage.legacyIds : [];\n      }\n    }\n  }]);\n\n  return I18nMetaVisitor;\n}();\n/** I18n separators for metadata **/\n\n\nvar I18N_MEANING_SEPARATOR = '|';\nvar I18N_ID_SEPARATOR = '@@';\n/**\n * Parses i18n metas like:\n *  - \"@@id\",\n *  - \"description[@@id]\",\n *  - \"meaning|description[@@id]\"\n * and returns an object with parsed output.\n *\n * @param meta String that represents i18n meta\n * @returns Object with id, meaning and description fields\n */\n\nfunction parseI18nMeta() {\n  var meta = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  var customId;\n  var meaning;\n  var description;\n  meta = meta.trim();\n\n  if (meta) {\n    var idIndex = meta.indexOf(I18N_ID_SEPARATOR);\n    var descIndex = meta.indexOf(I18N_MEANING_SEPARATOR);\n    var meaningAndDesc;\n\n    var _ref14 = idIndex > -1 ? [meta.slice(0, idIndex), meta.slice(idIndex + 2)] : [meta, ''];\n\n    var _ref15 = _slicedToArray(_ref14, 2);\n\n    meaningAndDesc = _ref15[0];\n    customId = _ref15[1];\n\n    var _ref16 = descIndex > -1 ? [meaningAndDesc.slice(0, descIndex), meaningAndDesc.slice(descIndex + 1)] : ['', meaningAndDesc];\n\n    var _ref17 = _slicedToArray(_ref16, 2);\n\n    meaning = _ref17[0];\n    description = _ref17[1];\n  }\n\n  return {\n    customId: customId,\n    meaning: meaning,\n    description: description\n  };\n} // Converts i18n meta information for a message (id, description, meaning)\n// to a JsDoc statement formatted as expected by the Closure compiler.\n\n\nfunction i18nMetaToDocStmt(meta) {\n  var tags = [];\n\n  if (meta.description) {\n    tags.push({\n      tagName: \"desc\"\n      /* Desc */\n      ,\n      text: meta.description\n    });\n  }\n\n  if (meta.meaning) {\n    tags.push({\n      tagName: \"meaning\"\n      /* Meaning */\n      ,\n      text: meta.meaning\n    });\n  }\n\n  return tags.length == 0 ? null : new JSDocCommentStmt(tags);\n}\n/** Closure uses `goog.getMsg(message)` to lookup translations */\n\n\nvar GOOG_GET_MSG = 'goog.getMsg';\n\nfunction createGoogleGetMsgStatements(variable$1, message, closureVar, params) {\n  var messageString = serializeI18nMessageForGetMsg(message);\n  var args = [literal(messageString)];\n\n  if (Object.keys(params).length) {\n    args.push(mapLiteral(params, true));\n  } // /**\n  //  * @desc description of message\n  //  * @meaning meaning of message\n  //  */\n  // const MSG_... = goog.getMsg(..);\n  // I18N_X = MSG_...;\n\n\n  var statements = [];\n  var jsdocComment = i18nMetaToDocStmt(message);\n\n  if (jsdocComment !== null) {\n    statements.push(jsdocComment);\n  }\n\n  statements.push(closureVar.set(variable(GOOG_GET_MSG).callFn(args)).toConstDecl());\n  statements.push(new ExpressionStatement(variable$1.set(closureVar)));\n  return statements;\n}\n/**\n * This visitor walks over i18n tree and generates its string representation, including ICUs and\n * placeholders in `{$placeholder}` (for plain messages) or `{PLACEHOLDER}` (inside ICUs) format.\n */\n\n\nvar GetMsgSerializerVisitor = /*#__PURE__*/function () {\n  function GetMsgSerializerVisitor() {\n    _classCallCheck(this, GetMsgSerializerVisitor);\n  }\n\n  _createClass(GetMsgSerializerVisitor, [{\n    key: \"formatPh\",\n    value: function formatPh(value) {\n      return \"{$\".concat(formatI18nPlaceholderName(value), \"}\");\n    }\n  }, {\n    key: \"visitText\",\n    value: function visitText(text) {\n      return text.value;\n    }\n  }, {\n    key: \"visitContainer\",\n    value: function visitContainer(container) {\n      var _this165 = this;\n\n      return container.children.map(function (child) {\n        return child.visit(_this165);\n      }).join('');\n    }\n  }, {\n    key: \"visitIcu\",\n    value: function visitIcu(icu) {\n      return serializeIcuNode(icu);\n    }\n  }, {\n    key: \"visitTagPlaceholder\",\n    value: function visitTagPlaceholder(ph) {\n      var _this166 = this;\n\n      return ph.isVoid ? this.formatPh(ph.startName) : \"\".concat(this.formatPh(ph.startName)).concat(ph.children.map(function (child) {\n        return child.visit(_this166);\n      }).join('')).concat(this.formatPh(ph.closeName));\n    }\n  }, {\n    key: \"visitPlaceholder\",\n    value: function visitPlaceholder(ph) {\n      return this.formatPh(ph.name);\n    }\n  }, {\n    key: \"visitIcuPlaceholder\",\n    value: function visitIcuPlaceholder(ph, context) {\n      return this.formatPh(ph.name);\n    }\n  }]);\n\n  return GetMsgSerializerVisitor;\n}();\n\nvar serializerVisitor$1 = new GetMsgSerializerVisitor();\n\nfunction serializeI18nMessageForGetMsg(message) {\n  return message.nodes.map(function (node) {\n    return node.visit(serializerVisitor$1, null);\n  }).join('');\n}\n\nfunction createLocalizeStatements(variable, message, params) {\n  var statements = [];\n\n  var _serializeI18nMessage = serializeI18nMessageForLocalize(message),\n      messageParts = _serializeI18nMessage.messageParts,\n      placeHolders = _serializeI18nMessage.placeHolders;\n\n  statements.push(new ExpressionStatement(variable.set(localizedString(message, messageParts, placeHolders, placeHolders.map(function (ph) {\n    return params[ph];\n  })))));\n  return statements;\n}\n\nvar MessagePiece = function MessagePiece(text) {\n  _classCallCheck(this, MessagePiece);\n\n  this.text = text;\n};\n\nvar LiteralPiece = /*#__PURE__*/function (_MessagePiece) {\n  _inherits(LiteralPiece, _MessagePiece);\n\n  var _super93 = _createSuper(LiteralPiece);\n\n  function LiteralPiece() {\n    _classCallCheck(this, LiteralPiece);\n\n    return _super93.apply(this, arguments);\n  }\n\n  return LiteralPiece;\n}(MessagePiece);\n\nvar PlaceholderPiece = /*#__PURE__*/function (_MessagePiece2) {\n  _inherits(PlaceholderPiece, _MessagePiece2);\n\n  var _super94 = _createSuper(PlaceholderPiece);\n\n  function PlaceholderPiece(name) {\n    _classCallCheck(this, PlaceholderPiece);\n\n    return _super94.call(this, formatI18nPlaceholderName(name,\n    /* useCamelCase */\n    false));\n  }\n\n  return PlaceholderPiece;\n}(MessagePiece);\n/**\n * This visitor walks over an i18n tree, capturing literal strings and placeholders.\n *\n * The result can be used for generating the `$localize` tagged template literals.\n */\n\n\nvar LocalizeSerializerVisitor = /*#__PURE__*/function () {\n  function LocalizeSerializerVisitor() {\n    _classCallCheck(this, LocalizeSerializerVisitor);\n  }\n\n  _createClass(LocalizeSerializerVisitor, [{\n    key: \"visitText\",\n    value: function visitText(text, context) {\n      if (context[context.length - 1] instanceof LiteralPiece) {\n        // Two literal pieces in a row means that there was some comment node in-between.\n        context[context.length - 1].text += text.value;\n      } else {\n        context.push(new LiteralPiece(text.value));\n      }\n    }\n  }, {\n    key: \"visitContainer\",\n    value: function visitContainer(container, context) {\n      var _this167 = this;\n\n      container.children.forEach(function (child) {\n        return child.visit(_this167, context);\n      });\n    }\n  }, {\n    key: \"visitIcu\",\n    value: function visitIcu(icu, context) {\n      context.push(new LiteralPiece(serializeIcuNode(icu)));\n    }\n  }, {\n    key: \"visitTagPlaceholder\",\n    value: function visitTagPlaceholder(ph, context) {\n      var _this168 = this;\n\n      context.push(new PlaceholderPiece(ph.startName));\n\n      if (!ph.isVoid) {\n        ph.children.forEach(function (child) {\n          return child.visit(_this168, context);\n        });\n        context.push(new PlaceholderPiece(ph.closeName));\n      }\n    }\n  }, {\n    key: \"visitPlaceholder\",\n    value: function visitPlaceholder(ph, context) {\n      context.push(new PlaceholderPiece(ph.name));\n    }\n  }, {\n    key: \"visitIcuPlaceholder\",\n    value: function visitIcuPlaceholder(ph, context) {\n      context.push(new PlaceholderPiece(ph.name));\n    }\n  }]);\n\n  return LocalizeSerializerVisitor;\n}();\n\nvar serializerVisitor$2 = new LocalizeSerializerVisitor();\n/**\n * Serialize an i18n message into two arrays: messageParts and placeholders.\n *\n * These arrays will be used to generate `$localize` tagged template literals.\n *\n * @param message The message to be serialized.\n * @returns an object containing the messageParts and placeholders.\n */\n\nfunction serializeI18nMessageForLocalize(message) {\n  var pieces = [];\n  message.nodes.forEach(function (node) {\n    return node.visit(serializerVisitor$2, pieces);\n  });\n  return processMessagePieces(pieces);\n}\n/**\n * Convert the list of serialized MessagePieces into two arrays.\n *\n * One contains the literal string pieces and the other the placeholders that will be replaced by\n * expressions when rendering `$localize` tagged template literals.\n *\n * @param pieces The pieces to process.\n * @returns an object containing the messageParts and placeholders.\n */\n\n\nfunction processMessagePieces(pieces) {\n  var messageParts = [];\n  var placeHolders = [];\n\n  if (pieces[0] instanceof PlaceholderPiece) {\n    // The first piece was a placeholder so we need to add an initial empty message part.\n    messageParts.push('');\n  }\n\n  for (var i = 0; i < pieces.length; i++) {\n    var part = pieces[i];\n\n    if (part instanceof LiteralPiece) {\n      messageParts.push(part.text);\n    } else {\n      placeHolders.push(part.text);\n\n      if (pieces[i - 1] instanceof PlaceholderPiece) {\n        // There were two placeholders in a row, so we need to add an empty message part.\n        messageParts.push('');\n      }\n    }\n  }\n\n  if (pieces[pieces.length - 1] instanceof PlaceholderPiece) {\n    // The last piece was a placeholder so we need to add a final empty message part.\n    messageParts.push('');\n  }\n\n  return {\n    messageParts: messageParts,\n    placeHolders: placeHolders\n  };\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Selector attribute name of `<ng-content>`\n\n\nvar NG_CONTENT_SELECT_ATTR$1 = 'select'; // Attribute name of `ngProjectAs`.\n\nvar NG_PROJECT_AS_ATTR_NAME = 'ngProjectAs'; // List of supported global targets for event listeners\n\nvar GLOBAL_TARGET_RESOLVERS = new Map([['window', Identifiers$1.resolveWindow], ['document', Identifiers$1.resolveDocument], ['body', Identifiers$1.resolveBody]]);\nvar LEADING_TRIVIA_CHARS = [' ', '\\n', '\\r', '\\t']; //  if (rf & flags) { .. }\n\nfunction renderFlagCheckIfStmt(flags, statements) {\n  return ifStmt(variable(RENDER_FLAGS).bitwiseAnd(literal(flags), null, false), statements);\n}\n\nfunction prepareEventListenerParameters(eventAst) {\n  var handlerName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var scope = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  var type = eventAst.type,\n      name = eventAst.name,\n      target = eventAst.target,\n      phase = eventAst.phase,\n      handler = eventAst.handler;\n\n  if (target && !GLOBAL_TARGET_RESOLVERS.has(target)) {\n    throw new Error(\"Unexpected global target '\".concat(target, \"' defined for '\").concat(name, \"' event.\\n        Supported list of global targets: \").concat(Array.from(GLOBAL_TARGET_RESOLVERS.keys()), \".\"));\n  }\n\n  var eventArgumentName = '$event';\n  var implicitReceiverAccesses = new Set();\n  var implicitReceiverExpr = scope === null || scope.bindingLevel === 0 ? variable(CONTEXT_NAME) : scope.getOrCreateSharedContextVar(0);\n  var bindingExpr = convertActionBinding(scope, implicitReceiverExpr, handler, 'b', function () {\n    return error('Unexpected interpolation');\n  }, eventAst.handlerSpan, implicitReceiverAccesses);\n  var statements = [];\n\n  if (scope) {\n    statements.push.apply(statements, _toConsumableArray(scope.restoreViewStatement()));\n    statements.push.apply(statements, _toConsumableArray(scope.variableDeclarations()));\n  }\n\n  statements.push.apply(statements, _toConsumableArray(bindingExpr.render3Stmts));\n  var eventName = type === 1\n  /* Animation */\n  ? prepareSyntheticListenerName(name, phase) : name;\n  var fnName = handlerName && sanitizeIdentifier(handlerName);\n  var fnArgs = [];\n\n  if (implicitReceiverAccesses.has(eventArgumentName)) {\n    fnArgs.push(new FnParam(eventArgumentName, DYNAMIC_TYPE));\n  }\n\n  var handlerFn = fn(fnArgs, statements, INFERRED_TYPE, null, fnName);\n  var params = [literal(eventName), handlerFn];\n\n  if (target) {\n    params.push(literal(false), // `useCapture` flag, defaults to `false`\n    importExpr(GLOBAL_TARGET_RESOLVERS.get(target)));\n  }\n\n  return params;\n}\n\nvar TemplateDefinitionBuilder = /*#__PURE__*/function () {\n  function TemplateDefinitionBuilder(constantPool, parentBindingScope) {\n    var _this169 = this;\n\n    var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var contextName = arguments.length > 3 ? arguments[3] : undefined;\n    var i18nContext = arguments.length > 4 ? arguments[4] : undefined;\n    var templateIndex = arguments.length > 5 ? arguments[5] : undefined;\n    var templateName = arguments.length > 6 ? arguments[6] : undefined;\n    var directiveMatcher = arguments.length > 7 ? arguments[7] : undefined;\n    var directives = arguments.length > 8 ? arguments[8] : undefined;\n    var pipeTypeByName = arguments.length > 9 ? arguments[9] : undefined;\n    var pipes = arguments.length > 10 ? arguments[10] : undefined;\n\n    var _namespace = arguments.length > 11 ? arguments[11] : undefined;\n\n    var relativeContextFilePath = arguments.length > 12 ? arguments[12] : undefined;\n    var i18nUseExternalIds = arguments.length > 13 ? arguments[13] : undefined;\n\n    var _constants = arguments.length > 14 && arguments[14] !== undefined ? arguments[14] : [];\n\n    _classCallCheck(this, TemplateDefinitionBuilder);\n\n    this.constantPool = constantPool;\n    this.level = level;\n    this.contextName = contextName;\n    this.i18nContext = i18nContext;\n    this.templateIndex = templateIndex;\n    this.templateName = templateName;\n    this.directiveMatcher = directiveMatcher;\n    this.directives = directives;\n    this.pipeTypeByName = pipeTypeByName;\n    this.pipes = pipes;\n    this._namespace = _namespace;\n    this.i18nUseExternalIds = i18nUseExternalIds;\n    this._constants = _constants;\n    this._dataIndex = 0;\n    this._bindingContext = 0;\n    this._prefixCode = [];\n    /**\n     * List of callbacks to generate creation mode instructions. We store them here as we process\n     * the template so bindings in listeners are resolved only once all nodes have been visited.\n     * This ensures all local refs and context variables are available for matching.\n     */\n\n    this._creationCodeFns = [];\n    /**\n     * List of callbacks to generate update mode instructions. We store them here as we process\n     * the template so bindings are resolved only once all nodes have been visited. This ensures\n     * all local refs and context variables are available for matching.\n     */\n\n    this._updateCodeFns = [];\n    /** Index of the currently-selected node. */\n\n    this._currentIndex = 0;\n    /** Temporary variable declarations generated from visiting pipes, literals, etc. */\n\n    this._tempVariables = [];\n    /**\n     * List of callbacks to build nested templates. Nested templates must not be visited until\n     * after the parent template has finished visiting all of its nodes. This ensures that all\n     * local ref bindings in nested templates are able to find local ref values if the refs\n     * are defined after the template declaration.\n     */\n\n    this._nestedTemplateFns = [];\n    this._unsupported = unsupported; // i18n context local to this template\n\n    this.i18n = null; // Number of slots to reserve for pureFunctions\n\n    this._pureFunctionSlots = 0; // Number of binding slots\n\n    this._bindingSlots = 0; // Projection slots found in the template. Projection slots can distribute projected\n    // nodes based on a selector, or can just use the wildcard selector to match\n    // all nodes which aren't matching any selector.\n\n    this._ngContentReservedSlots = []; // Number of non-default selectors found in all parent templates of this template. We need to\n    // track it to properly adjust projection slot index in the `projection` instruction.\n\n    this._ngContentSelectorsOffset = 0; // Expression that should be used as implicit receiver when converting template\n    // expressions to output AST.\n\n    this._implicitReceiverExpr = null; // These should be handled in the template or element directly.\n\n    this.visitReference = invalid$1;\n    this.visitVariable = invalid$1;\n    this.visitTextAttribute = invalid$1;\n    this.visitBoundAttribute = invalid$1;\n    this.visitBoundEvent = invalid$1;\n    this._bindingScope = parentBindingScope.nestedScope(level); // Turn the relative context file path into an identifier by replacing non-alphanumeric\n    // characters with underscores.\n\n    this.fileBasedI18nSuffix = relativeContextFilePath.replace(/[^A-Za-z0-9]/g, '_') + '_';\n    this._valueConverter = new ValueConverter(constantPool, function () {\n      return _this169.allocateDataSlot();\n    }, function (numSlots) {\n      return _this169.allocatePureFunctionSlots(numSlots);\n    }, function (name, localName, slot, value) {\n      var pipeType = pipeTypeByName.get(name);\n\n      if (pipeType) {\n        _this169.pipes.add(pipeType);\n      }\n\n      _this169._bindingScope.set(_this169.level, localName, value);\n\n      _this169.creationInstruction(null, Identifiers$1.pipe, [literal(slot), literal(name)]);\n    });\n  }\n\n  _createClass(TemplateDefinitionBuilder, [{\n    key: \"buildTemplateFunction\",\n    value: function buildTemplateFunction(nodes, variables) {\n      var _this170 = this;\n\n      var ngContentSelectorsOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var i18n = arguments.length > 3 ? arguments[3] : undefined;\n      this._ngContentSelectorsOffset = ngContentSelectorsOffset;\n\n      if (this._namespace !== Identifiers$1.namespaceHTML) {\n        this.creationInstruction(null, this._namespace);\n      } // Create variable bindings\n\n\n      variables.forEach(function (v) {\n        return _this170.registerContextVariables(v);\n      }); // Initiate i18n context in case:\n      // - this template has parent i18n context\n      // - or the template has i18n meta associated with it,\n      //   but it's not initiated by the Element (e.g. <ng-template i18n>)\n\n      var initI18nContext = this.i18nContext || isI18nRootNode(i18n) && !isSingleI18nIcu(i18n) && !(isSingleElementTemplate(nodes) && nodes[0].i18n === i18n);\n      var selfClosingI18nInstruction = hasTextChildrenOnly(nodes);\n\n      if (initI18nContext) {\n        this.i18nStart(null, i18n, selfClosingI18nInstruction);\n      } // This is the initial pass through the nodes of this template. In this pass, we\n      // queue all creation mode and update mode instructions for generation in the second\n      // pass. It's necessary to separate the passes to ensure local refs are defined before\n      // resolving bindings. We also count bindings in this pass as we walk bound expressions.\n\n\n      visitAll(this, nodes); // Add total binding count to pure function count so pure function instructions are\n      // generated with the correct slot offset when update instructions are processed.\n\n      this._pureFunctionSlots += this._bindingSlots; // Pipes are walked in the first pass (to enqueue `pipe()` creation instructions and\n      // `pipeBind` update instructions), so we have to update the slot offsets manually\n      // to account for bindings.\n\n      this._valueConverter.updatePipeSlotOffsets(this._bindingSlots); // Nested templates must be processed before creation instructions so template()\n      // instructions can be generated with the correct internal const count.\n\n\n      this._nestedTemplateFns.forEach(function (buildTemplateFn) {\n        return buildTemplateFn();\n      }); // Output the `projectionDef` instruction when some `<ng-content>` tags are present.\n      // The `projectionDef` instruction is only emitted for the component template and\n      // is skipped for nested templates (<ng-template> tags).\n\n\n      if (this.level === 0 && this._ngContentReservedSlots.length) {\n        var parameters = []; // By default the `projectionDef` instructions creates one slot for the wildcard\n        // selector if no parameters are passed. Therefore we only want to allocate a new\n        // array for the projection slots if the default projection slot is not sufficient.\n\n        if (this._ngContentReservedSlots.length > 1 || this._ngContentReservedSlots[0] !== '*') {\n          var r3ReservedSlots = this._ngContentReservedSlots.map(function (s) {\n            return s !== '*' ? parseSelectorToR3Selector(s) : s;\n          });\n\n          parameters.push(this.constantPool.getConstLiteral(asLiteral(r3ReservedSlots), true));\n        } // Since we accumulate ngContent selectors while processing template elements,\n        // we *prepend* `projectionDef` to creation instructions block, to put it before\n        // any `projection` instructions\n\n\n        this.creationInstruction(null, Identifiers$1.projectionDef, parameters,\n        /* prepend */\n        true);\n      }\n\n      if (initI18nContext) {\n        this.i18nEnd(null, selfClosingI18nInstruction);\n      } // Generate all the creation mode instructions (e.g. resolve bindings in listeners)\n\n\n      var creationStatements = this._creationCodeFns.map(function (fn) {\n        return fn();\n      }); // Generate all the update mode instructions (e.g. resolve property or text bindings)\n\n\n      var updateStatements = this._updateCodeFns.map(function (fn) {\n        return fn();\n      }); //  Variable declaration must occur after binding resolution so we can generate context\n      //  instructions that build on each other.\n      // e.g. const b = nextContext().$implicit(); const b = nextContext();\n\n\n      var creationVariables = this._bindingScope.viewSnapshotStatements();\n\n      var updateVariables = this._bindingScope.variableDeclarations().concat(this._tempVariables);\n\n      var creationBlock = creationStatements.length > 0 ? [renderFlagCheckIfStmt(1\n      /* Create */\n      , creationVariables.concat(creationStatements))] : [];\n      var updateBlock = updateStatements.length > 0 ? [renderFlagCheckIfStmt(2\n      /* Update */\n      , updateVariables.concat(updateStatements))] : [];\n      return fn( // i.e. (rf: RenderFlags, ctx: any)\n      [new FnParam(RENDER_FLAGS, NUMBER_TYPE), new FnParam(CONTEXT_NAME, null)], [].concat(_toConsumableArray(this._prefixCode), creationBlock, updateBlock), INFERRED_TYPE, null, this.templateName);\n    } // LocalResolver\n\n  }, {\n    key: \"getLocal\",\n    value: function getLocal(name) {\n      return this._bindingScope.get(name);\n    } // LocalResolver\n\n  }, {\n    key: \"notifyImplicitReceiverUse\",\n    value: function notifyImplicitReceiverUse() {\n      this._bindingScope.notifyImplicitReceiverUse();\n    }\n  }, {\n    key: \"i18nTranslate\",\n    value: function i18nTranslate(message) {\n      var _this$constantPool$st;\n\n      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var ref = arguments.length > 2 ? arguments[2] : undefined;\n      var transformFn = arguments.length > 3 ? arguments[3] : undefined;\n\n      var _ref = ref || variable(this.constantPool.uniqueName(TRANSLATION_PREFIX)); // Closure Compiler requires const names to start with `MSG_` but disallows any other const to\n      // start with `MSG_`. We define a variable starting with `MSG_` just for the `goog.getMsg` call\n\n\n      var closureVar = this.i18nGenerateClosureVar(message.id);\n      var statements = getTranslationDeclStmts(message, _ref, closureVar, params, transformFn);\n\n      (_this$constantPool$st = this.constantPool.statements).push.apply(_this$constantPool$st, _toConsumableArray(statements));\n\n      return _ref;\n    }\n  }, {\n    key: \"registerContextVariables\",\n    value: function registerContextVariables(variable$1) {\n      var scopedName = this._bindingScope.freshReferenceName();\n\n      var retrievalLevel = this.level;\n      var lhs = variable(variable$1.name + scopedName);\n\n      this._bindingScope.set(retrievalLevel, variable$1.name, lhs, 1\n      /* CONTEXT */\n      , function (scope, relativeLevel) {\n        var rhs;\n\n        if (scope.bindingLevel === retrievalLevel) {\n          // e.g. ctx\n          rhs = variable(CONTEXT_NAME);\n        } else {\n          var sharedCtxVar = scope.getSharedContextName(retrievalLevel); // e.g. ctx_r0   OR  x(2);\n\n          rhs = sharedCtxVar ? sharedCtxVar : generateNextContextExpr(relativeLevel);\n        } // e.g. const $item$ = x(2).$implicit;\n\n\n        return [lhs.set(rhs.prop(variable$1.value || IMPLICIT_REFERENCE)).toConstDecl()];\n      });\n    }\n  }, {\n    key: \"i18nAppendBindings\",\n    value: function i18nAppendBindings(expressions) {\n      var _this171 = this;\n\n      if (expressions.length > 0) {\n        expressions.forEach(function (expression) {\n          return _this171.i18n.appendBinding(expression);\n        });\n      }\n    }\n  }, {\n    key: \"i18nBindProps\",\n    value: function i18nBindProps(props) {\n      var _this172 = this;\n\n      var bound = {};\n      Object.keys(props).forEach(function (key) {\n        var prop = props[key];\n\n        if (prop instanceof Text) {\n          bound[key] = literal(prop.value);\n        } else {\n          var value = prop.value.visit(_this172._valueConverter);\n\n          _this172.allocateBindingSlots(value);\n\n          if (value instanceof Interpolation) {\n            var strings = value.strings,\n                expressions = value.expressions;\n            var _this172$i18n = _this172.i18n,\n                id = _this172$i18n.id,\n                bindings = _this172$i18n.bindings;\n            var label = assembleI18nBoundString(strings, bindings.size, id);\n\n            _this172.i18nAppendBindings(expressions);\n\n            bound[key] = literal(label);\n          }\n        }\n      });\n      return bound;\n    }\n  }, {\n    key: \"i18nGenerateClosureVar\",\n    value: function i18nGenerateClosureVar(messageId) {\n      var name;\n      var suffix = this.fileBasedI18nSuffix.toUpperCase();\n\n      if (this.i18nUseExternalIds) {\n        var prefix = getTranslationConstPrefix(\"EXTERNAL_\");\n        var uniqueSuffix = this.constantPool.uniqueName(suffix);\n        name = \"\".concat(prefix).concat(sanitizeIdentifier(messageId), \"$$\").concat(uniqueSuffix);\n      } else {\n        var _prefix = getTranslationConstPrefix(suffix);\n\n        name = this.constantPool.uniqueName(_prefix);\n      }\n\n      return variable(name);\n    }\n  }, {\n    key: \"i18nUpdateRef\",\n    value: function i18nUpdateRef(context) {\n      var icus = context.icus,\n          meta = context.meta,\n          isRoot = context.isRoot,\n          isResolved = context.isResolved,\n          isEmitted = context.isEmitted;\n\n      if (isRoot && isResolved && !isEmitted && !isSingleI18nIcu(meta)) {\n        context.isEmitted = true;\n        var placeholders = context.getSerializedPlaceholders();\n        var icuMapping = {};\n        var params = placeholders.size ? placeholdersToParams(placeholders) : {};\n\n        if (icus.size) {\n          icus.forEach(function (refs, key) {\n            if (refs.length === 1) {\n              // if we have one ICU defined for a given\n              // placeholder - just output its reference\n              params[key] = refs[0];\n            } else {\n              // ... otherwise we need to activate post-processing\n              // to replace ICU placeholders with proper values\n              var placeholder = wrapI18nPlaceholder(\"\".concat(I18N_ICU_MAPPING_PREFIX).concat(key));\n              params[key] = literal(placeholder);\n              icuMapping[key] = literalArr(refs);\n            }\n          });\n        } // translation requires post processing in 2 cases:\n        // - if we have placeholders with multiple values (ex. `START_DIV`: [�#1�, �#2�, ...])\n        // - if we have multiple ICUs that refer to the same placeholder name\n\n\n        var needsPostprocessing = Array.from(placeholders.values()).some(function (value) {\n          return value.length > 1;\n        }) || Object.keys(icuMapping).length;\n        var transformFn;\n\n        if (needsPostprocessing) {\n          transformFn = function transformFn(raw) {\n            var args = [raw];\n\n            if (Object.keys(icuMapping).length) {\n              args.push(mapLiteral(icuMapping, true));\n            }\n\n            return instruction(null, Identifiers$1.i18nPostprocess, args);\n          };\n        }\n\n        this.i18nTranslate(meta, params, context.ref, transformFn);\n      }\n    }\n  }, {\n    key: \"i18nStart\",\n    value: function i18nStart() {\n      var span = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var meta = arguments.length > 1 ? arguments[1] : undefined;\n      var selfClosing = arguments.length > 2 ? arguments[2] : undefined;\n      var index = this.allocateDataSlot();\n\n      if (this.i18nContext) {\n        this.i18n = this.i18nContext.forkChildContext(index, this.templateIndex, meta);\n      } else {\n        var _ref18 = variable(this.constantPool.uniqueName(TRANSLATION_PREFIX));\n\n        this.i18n = new I18nContext(index, _ref18, 0, this.templateIndex, meta);\n      } // generate i18nStart instruction\n\n\n      var _this$i18n = this.i18n,\n          id = _this$i18n.id,\n          ref = _this$i18n.ref;\n      var params = [literal(index), ref];\n\n      if (id > 0) {\n        // do not push 3rd argument (sub-block id)\n        // into i18nStart call for top level i18n context\n        params.push(literal(id));\n      }\n\n      this.creationInstruction(span, selfClosing ? Identifiers$1.i18n : Identifiers$1.i18nStart, params);\n    }\n  }, {\n    key: \"i18nEnd\",\n    value: function i18nEnd() {\n      var _this173 = this;\n\n      var span = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var selfClosing = arguments.length > 1 ? arguments[1] : undefined;\n\n      if (!this.i18n) {\n        throw new Error('i18nEnd is executed with no i18n context present');\n      }\n\n      if (this.i18nContext) {\n        this.i18nContext.reconcileChildContext(this.i18n);\n        this.i18nUpdateRef(this.i18nContext);\n      } else {\n        this.i18nUpdateRef(this.i18n);\n      } // setup accumulated bindings\n\n\n      var _this$i18n2 = this.i18n,\n          index = _this$i18n2.index,\n          bindings = _this$i18n2.bindings;\n\n      if (bindings.size) {\n        var chainBindings = [];\n        bindings.forEach(function (binding) {\n          chainBindings.push({\n            sourceSpan: span,\n            value: function value() {\n              return _this173.convertPropertyBinding(binding);\n            }\n          });\n        }); // for i18n block, advance to the most recent element index (by taking the current number of\n        // elements and subtracting one) before invoking `i18nExp` instructions, to make sure the\n        // necessary lifecycle hooks of components/directives are properly flushed.\n\n        this.updateInstructionChainWithAdvance(this.getConstCount() - 1, Identifiers$1.i18nExp, chainBindings);\n        this.updateInstruction(span, Identifiers$1.i18nApply, [literal(index)]);\n      }\n\n      if (!selfClosing) {\n        this.creationInstruction(span, Identifiers$1.i18nEnd);\n      }\n\n      this.i18n = null; // reset local i18n context\n    }\n  }, {\n    key: \"i18nAttributesInstruction\",\n    value: function i18nAttributesInstruction(nodeIndex, attrs, sourceSpan) {\n      var _this174 = this;\n\n      var hasBindings = false;\n      var i18nAttrArgs = [];\n      var bindings = [];\n      attrs.forEach(function (attr) {\n        var message = attr.i18n;\n\n        if (attr instanceof TextAttribute) {\n          i18nAttrArgs.push(literal(attr.name), _this174.i18nTranslate(message));\n        } else {\n          var converted = attr.value.visit(_this174._valueConverter);\n\n          _this174.allocateBindingSlots(converted);\n\n          if (converted instanceof Interpolation) {\n            var placeholders = assembleBoundTextPlaceholders(message);\n            var params = placeholdersToParams(placeholders);\n            i18nAttrArgs.push(literal(attr.name), _this174.i18nTranslate(message, params));\n            converted.expressions.forEach(function (expression) {\n              hasBindings = true;\n              bindings.push({\n                sourceSpan: sourceSpan,\n                value: function value() {\n                  return _this174.convertPropertyBinding(expression);\n                }\n              });\n            });\n          }\n        }\n      });\n\n      if (bindings.length > 0) {\n        this.updateInstructionChainWithAdvance(nodeIndex, Identifiers$1.i18nExp, bindings);\n      }\n\n      if (i18nAttrArgs.length > 0) {\n        var index = literal(this.allocateDataSlot());\n        var args = this.constantPool.getConstLiteral(literalArr(i18nAttrArgs), true);\n        this.creationInstruction(sourceSpan, Identifiers$1.i18nAttributes, [index, args]);\n\n        if (hasBindings) {\n          this.updateInstruction(sourceSpan, Identifiers$1.i18nApply, [index]);\n        }\n      }\n    }\n  }, {\n    key: \"getNamespaceInstruction\",\n    value: function getNamespaceInstruction(namespaceKey) {\n      switch (namespaceKey) {\n        case 'math':\n          return Identifiers$1.namespaceMathML;\n\n        case 'svg':\n          return Identifiers$1.namespaceSVG;\n\n        default:\n          return Identifiers$1.namespaceHTML;\n      }\n    }\n  }, {\n    key: \"addNamespaceInstruction\",\n    value: function addNamespaceInstruction(nsInstruction, element) {\n      this._namespace = nsInstruction;\n      this.creationInstruction(element.sourceSpan, nsInstruction);\n    }\n    /**\n     * Adds an update instruction for an interpolated property or attribute, such as\n     * `prop=\"{{value}}\"` or `attr.title=\"{{value}}\"`\n     */\n\n  }, {\n    key: \"interpolatedUpdateInstruction\",\n    value: function interpolatedUpdateInstruction(instruction, elementIndex, attrName, input, value, params) {\n      var _this175 = this;\n\n      this.updateInstructionWithAdvance(elementIndex, input.sourceSpan, instruction, function () {\n        return [literal(attrName)].concat(_toConsumableArray(_this175.getUpdateInstructionArguments(value)), _toConsumableArray(params));\n      });\n    }\n  }, {\n    key: \"visitContent\",\n    value: function visitContent(ngContent) {\n      var slot = this.allocateDataSlot();\n      var projectionSlotIdx = this._ngContentSelectorsOffset + this._ngContentReservedSlots.length;\n      var parameters = [literal(slot)];\n\n      this._ngContentReservedSlots.push(ngContent.selector);\n\n      var nonContentSelectAttributes = ngContent.attributes.filter(function (attr) {\n        return attr.name.toLowerCase() !== NG_CONTENT_SELECT_ATTR$1;\n      });\n      var attributes = this.getAttributeExpressions(nonContentSelectAttributes, [], []);\n\n      if (attributes.length > 0) {\n        parameters.push(literal(projectionSlotIdx), literalArr(attributes));\n      } else if (projectionSlotIdx !== 0) {\n        parameters.push(literal(projectionSlotIdx));\n      }\n\n      this.creationInstruction(ngContent.sourceSpan, Identifiers$1.projection, parameters);\n\n      if (this.i18n) {\n        this.i18n.appendProjection(ngContent.i18n, slot);\n      }\n    }\n  }, {\n    key: \"visitElement\",\n    value: function visitElement(element) {\n      var _this176 = this;\n\n      var elementIndex = this.allocateDataSlot();\n      var stylingBuilder = new StylingBuilder(null);\n      var isNonBindableMode = false;\n      var isI18nRootElement = isI18nRootNode(element.i18n) && !isSingleI18nIcu(element.i18n);\n      var i18nAttrs = [];\n      var outputAttrs = [];\n\n      var _splitNsName = splitNsName(element.name),\n          _splitNsName2 = _slicedToArray(_splitNsName, 2),\n          namespaceKey = _splitNsName2[0],\n          elementName = _splitNsName2[1];\n\n      var isNgContainer$1 = isNgContainer(element.name); // Handle styling, i18n, ngNonBindable attributes\n\n      var _iterator13 = _createForOfIteratorHelper(element.attributes),\n          _step13;\n\n      try {\n        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n          var attr = _step13.value;\n          var name = attr.name,\n              value = attr.value;\n\n          if (name === NON_BINDABLE_ATTR) {\n            isNonBindableMode = true;\n          } else if (name === 'style') {\n            stylingBuilder.registerStyleAttr(value);\n          } else if (name === 'class') {\n            stylingBuilder.registerClassAttr(value);\n          } else {\n            (attr.i18n ? i18nAttrs : outputAttrs).push(attr);\n          }\n        } // Match directives on non i18n attributes\n\n      } catch (err) {\n        _iterator13.e(err);\n      } finally {\n        _iterator13.f();\n      }\n\n      this.matchDirectives(element.name, element); // Regular element or ng-container creation mode\n\n      var parameters = [literal(elementIndex)];\n\n      if (!isNgContainer$1) {\n        parameters.push(literal(elementName));\n      } // Add the attributes\n\n\n      var allOtherInputs = [];\n      element.inputs.forEach(function (input) {\n        var stylingInputWasSet = stylingBuilder.registerBoundInput(input);\n\n        if (!stylingInputWasSet) {\n          if (input.type === 0\n          /* Property */\n          && input.i18n) {\n            i18nAttrs.push(input);\n          } else {\n            allOtherInputs.push(input);\n          }\n        }\n      }); // add attributes for directive and projection matching purposes\n\n      var attributes = this.getAttributeExpressions(outputAttrs, allOtherInputs, element.outputs, stylingBuilder, [], i18nAttrs);\n      parameters.push(this.addAttrsToConsts(attributes)); // local refs (ex.: <div #foo #bar=\"baz\">)\n\n      var refs = this.prepareRefsArray(element.references);\n      parameters.push(this.addToConsts(refs));\n      var wasInNamespace = this._namespace;\n      var currentNamespace = this.getNamespaceInstruction(namespaceKey); // If the namespace is changing now, include an instruction to change it\n      // during element creation.\n\n      if (currentNamespace !== wasInNamespace) {\n        this.addNamespaceInstruction(currentNamespace, element);\n      }\n\n      if (this.i18n) {\n        this.i18n.appendElement(element.i18n, elementIndex);\n      } // Note that we do not append text node instructions and ICUs inside i18n section,\n      // so we exclude them while calculating whether current element has children\n\n\n      var hasChildren = !isI18nRootElement && this.i18n ? !hasTextChildrenOnly(element.children) : element.children.length > 0;\n      var createSelfClosingInstruction = !stylingBuilder.hasBindingsWithPipes && element.outputs.length === 0 && i18nAttrs.length === 0 && !hasChildren;\n      var createSelfClosingI18nInstruction = !createSelfClosingInstruction && hasTextChildrenOnly(element.children);\n\n      if (createSelfClosingInstruction) {\n        this.creationInstruction(element.sourceSpan, isNgContainer$1 ? Identifiers$1.elementContainer : Identifiers$1.element, trimTrailingNulls(parameters));\n      } else {\n        this.creationInstruction(element.sourceSpan, isNgContainer$1 ? Identifiers$1.elementContainerStart : Identifiers$1.elementStart, trimTrailingNulls(parameters));\n\n        if (isNonBindableMode) {\n          this.creationInstruction(element.sourceSpan, Identifiers$1.disableBindings);\n        }\n\n        if (i18nAttrs.length > 0) {\n          this.i18nAttributesInstruction(elementIndex, i18nAttrs, element.sourceSpan);\n        } // Generate Listeners (outputs)\n\n\n        if (element.outputs.length > 0) {\n          var listeners = element.outputs.map(function (outputAst) {\n            return {\n              sourceSpan: outputAst.sourceSpan,\n              params: _this176.prepareListenerParameter(element.name, outputAst, elementIndex)\n            };\n          });\n          this.creationInstructionChain(Identifiers$1.listener, listeners);\n        } // Note: it's important to keep i18n/i18nStart instructions after i18nAttributes and\n        // listeners, to make sure i18nAttributes instruction targets current element at runtime.\n\n\n        if (isI18nRootElement) {\n          this.i18nStart(element.sourceSpan, element.i18n, createSelfClosingI18nInstruction);\n        }\n      } // the code here will collect all update-level styling instructions and add them to the\n      // update block of the template function AOT code. Instructions like `styleProp`,\n      // `styleMap`, `classMap`, `classProp`\n      // are all generated and assigned in the code below.\n\n\n      var stylingInstructions = stylingBuilder.buildUpdateLevelInstructions(this._valueConverter);\n      var limit = stylingInstructions.length - 1;\n\n      for (var i = 0; i <= limit; i++) {\n        var _instruction = stylingInstructions[i];\n        this._bindingSlots += this.processStylingUpdateInstruction(elementIndex, _instruction);\n      } // the reason why `undefined` is used is because the renderer understands this as a\n      // special value to symbolize that there is no RHS to this binding\n      // TODO (matsko): revisit this once FW-959 is approached\n\n\n      var emptyValueBindInstruction = literal(undefined);\n      var propertyBindings = [];\n      var attributeBindings = []; // Generate element input bindings\n\n      allOtherInputs.forEach(function (input) {\n        var inputType = input.type;\n\n        if (inputType === 4\n        /* Animation */\n        ) {\n            var _value2 = input.value.visit(_this176._valueConverter); // animation bindings can be presented in the following formats:\n            // 1. [@binding]=\"fooExp\"\n            // 2. [@binding]=\"{value:fooExp, params:{...}}\"\n            // 3. [@binding]\n            // 4. @binding\n            // All formats will be valid for when a synthetic binding is created.\n            // The reasoning for this is because the renderer should get each\n            // synthetic binding value in the order of the array that they are\n            // defined in...\n\n\n            var hasValue = _value2 instanceof LiteralPrimitive ? !!_value2.value : true;\n\n            _this176.allocateBindingSlots(_value2);\n\n            propertyBindings.push({\n              name: prepareSyntheticPropertyName(input.name),\n              sourceSpan: input.sourceSpan,\n              value: function value() {\n                return hasValue ? _this176.convertPropertyBinding(_value2) : emptyValueBindInstruction;\n              }\n            });\n          } else {\n          // we must skip attributes with associated i18n context, since these attributes are handled\n          // separately and corresponding `i18nExp` and `i18nApply` instructions will be generated\n          if (input.i18n) return;\n\n          var _value3 = input.value.visit(_this176._valueConverter);\n\n          if (_value3 !== undefined) {\n            var params = [];\n\n            var _splitNsName3 = splitNsName(input.name),\n                _splitNsName4 = _slicedToArray(_splitNsName3, 2),\n                attrNamespace = _splitNsName4[0],\n                attrName = _splitNsName4[1];\n\n            var isAttributeBinding = inputType === 1\n            /* Attribute */\n            ;\n            var sanitizationRef = resolveSanitizationFn(input.securityContext, isAttributeBinding);\n            if (sanitizationRef) params.push(sanitizationRef);\n\n            if (attrNamespace) {\n              var namespaceLiteral = literal(attrNamespace);\n\n              if (sanitizationRef) {\n                params.push(namespaceLiteral);\n              } else {\n                // If there wasn't a sanitization ref, we need to add\n                // an extra param so that we can pass in the namespace.\n                params.push(literal(null), namespaceLiteral);\n              }\n            }\n\n            _this176.allocateBindingSlots(_value3);\n\n            if (inputType === 0\n            /* Property */\n            ) {\n                if (_value3 instanceof Interpolation) {\n                  // prop=\"{{value}}\" and friends\n                  _this176.interpolatedUpdateInstruction(getPropertyInterpolationExpression(_value3), elementIndex, attrName, input, _value3, params);\n                } else {\n                  // [prop]=\"value\"\n                  // Collect all the properties so that we can chain into a single function at the end.\n                  propertyBindings.push({\n                    name: attrName,\n                    sourceSpan: input.sourceSpan,\n                    value: function value() {\n                      return _this176.convertPropertyBinding(_value3);\n                    },\n                    params: params\n                  });\n                }\n              } else if (inputType === 1\n            /* Attribute */\n            ) {\n                if (_value3 instanceof Interpolation && getInterpolationArgsLength(_value3) > 1) {\n                  // attr.name=\"text{{value}}\" and friends\n                  _this176.interpolatedUpdateInstruction(getAttributeInterpolationExpression(_value3), elementIndex, attrName, input, _value3, params);\n                } else {\n                  var boundValue = _value3 instanceof Interpolation ? _value3.expressions[0] : _value3; // [attr.name]=\"value\" or attr.name=\"{{value}}\"\n                  // Collect the attribute bindings so that they can be chained at the end.\n\n                  attributeBindings.push({\n                    name: attrName,\n                    sourceSpan: input.sourceSpan,\n                    value: function value() {\n                      return _this176.convertPropertyBinding(boundValue);\n                    },\n                    params: params\n                  });\n                }\n              } else {\n              // class prop\n              _this176.updateInstructionWithAdvance(elementIndex, input.sourceSpan, Identifiers$1.classProp, function () {\n                return [literal(elementIndex), literal(attrName), _this176.convertPropertyBinding(_value3)].concat(params);\n              });\n            }\n          }\n        }\n      });\n\n      if (propertyBindings.length > 0) {\n        this.updateInstructionChainWithAdvance(elementIndex, Identifiers$1.property, propertyBindings);\n      }\n\n      if (attributeBindings.length > 0) {\n        this.updateInstructionChainWithAdvance(elementIndex, Identifiers$1.attribute, attributeBindings);\n      } // Traverse element child nodes\n\n\n      visitAll(this, element.children);\n\n      if (!isI18nRootElement && this.i18n) {\n        this.i18n.appendElement(element.i18n, elementIndex, true);\n      }\n\n      if (!createSelfClosingInstruction) {\n        // Finish element construction mode.\n        var span = element.endSourceSpan || element.sourceSpan;\n\n        if (isI18nRootElement) {\n          this.i18nEnd(span, createSelfClosingI18nInstruction);\n        }\n\n        if (isNonBindableMode) {\n          this.creationInstruction(span, Identifiers$1.enableBindings);\n        }\n\n        this.creationInstruction(span, isNgContainer$1 ? Identifiers$1.elementContainerEnd : Identifiers$1.elementEnd);\n      }\n    }\n  }, {\n    key: \"visitTemplate\",\n    value: function visitTemplate(template) {\n      var _this177 = this;\n\n      var NG_TEMPLATE_TAG_NAME = 'ng-template';\n      var templateIndex = this.allocateDataSlot();\n\n      if (this.i18n) {\n        this.i18n.appendTemplate(template.i18n, templateIndex);\n      }\n\n      var tagName = sanitizeIdentifier(template.tagName || '');\n      var contextName = \"\".concat(this.contextName).concat(tagName ? '_' + tagName : '', \"_\").concat(templateIndex);\n      var templateName = \"\".concat(contextName, \"_Template\");\n      var parameters = [literal(templateIndex), variable(templateName), // We don't care about the tag's namespace here, because we infer\n      // it based on the parent nodes inside the template instruction.\n      literal(template.tagName ? splitNsName(template.tagName)[1] : template.tagName)]; // find directives matching on a given <ng-template> node\n\n      this.matchDirectives(NG_TEMPLATE_TAG_NAME, template); // prepare attributes parameter (including attributes used for directive matching)\n\n      var _partitionArray = partitionArray(template.attributes, hasI18nMeta),\n          _partitionArray2 = _slicedToArray(_partitionArray, 2),\n          i18nStaticAttrs = _partitionArray2[0],\n          staticAttrs = _partitionArray2[1];\n\n      var attrsExprs = this.getAttributeExpressions(staticAttrs, template.inputs, template.outputs, undefined\n      /* styles */\n      , template.templateAttrs, i18nStaticAttrs);\n      parameters.push(this.addAttrsToConsts(attrsExprs)); // local refs (ex.: <ng-template #foo>)\n\n      if (template.references && template.references.length) {\n        var refs = this.prepareRefsArray(template.references);\n        parameters.push(this.addToConsts(refs));\n        parameters.push(importExpr(Identifiers$1.templateRefExtractor));\n      } // Create the template function\n\n\n      var templateVisitor = new TemplateDefinitionBuilder(this.constantPool, this._bindingScope, this.level + 1, contextName, this.i18n, templateIndex, templateName, this.directiveMatcher, this.directives, this.pipeTypeByName, this.pipes, this._namespace, this.fileBasedI18nSuffix, this.i18nUseExternalIds, this._constants); // Nested templates must not be visited until after their parent templates have completed\n      // processing, so they are queued here until after the initial pass. Otherwise, we wouldn't\n      // be able to support bindings in nested templates to local refs that occur after the\n      // template definition. e.g. <div *ngIf=\"showing\">{{ foo }}</div>  <div #foo></div>\n\n      this._nestedTemplateFns.push(function () {\n        var templateFunctionExpr = templateVisitor.buildTemplateFunction(template.children, template.variables, _this177._ngContentReservedSlots.length + _this177._ngContentSelectorsOffset, template.i18n);\n\n        _this177.constantPool.statements.push(templateFunctionExpr.toDeclStmt(templateName, null));\n\n        if (templateVisitor._ngContentReservedSlots.length) {\n          var _this177$_ngContentRe;\n\n          (_this177$_ngContentRe = _this177._ngContentReservedSlots).push.apply(_this177$_ngContentRe, _toConsumableArray(templateVisitor._ngContentReservedSlots));\n        }\n      }); // e.g. template(1, MyComp_Template_1)\n\n\n      this.creationInstruction(template.sourceSpan, Identifiers$1.templateCreate, function () {\n        parameters.splice(2, 0, literal(templateVisitor.getConstCount()), literal(templateVisitor.getVarCount()));\n        return trimTrailingNulls(parameters);\n      }); // handle property bindings e.g. ɵɵproperty('ngForOf', ctx.items), et al;\n\n      this.templatePropertyBindings(templateIndex, template.templateAttrs); // Only add normal input/output binding instructions on explicit <ng-template> elements.\n\n      if (template.tagName === NG_TEMPLATE_TAG_NAME) {\n        var _partitionArray3 = partitionArray(template.inputs, hasI18nMeta),\n            _partitionArray4 = _slicedToArray(_partitionArray3, 2),\n            i18nInputs = _partitionArray4[0],\n            inputs = _partitionArray4[1];\n\n        var i18nAttrs = [].concat(_toConsumableArray(i18nStaticAttrs), _toConsumableArray(i18nInputs)); // Add i18n attributes that may act as inputs to directives. If such attributes are present,\n        // generate `i18nAttributes` instruction. Note: we generate it only for explicit <ng-template>\n        // elements, in case of inline templates, corresponding instructions will be generated in the\n        // nested template function.\n\n        if (i18nAttrs.length > 0) {\n          this.i18nAttributesInstruction(templateIndex, i18nAttrs, template.sourceSpan);\n        } // Add the input bindings\n\n\n        if (inputs.length > 0) {\n          this.templatePropertyBindings(templateIndex, inputs);\n        } // Generate listeners for directive output\n\n\n        if (template.outputs.length > 0) {\n          var listeners = template.outputs.map(function (outputAst) {\n            return {\n              sourceSpan: outputAst.sourceSpan,\n              params: _this177.prepareListenerParameter('ng_template', outputAst, templateIndex)\n            };\n          });\n          this.creationInstructionChain(Identifiers$1.listener, listeners);\n        }\n      }\n    }\n  }, {\n    key: \"visitBoundText\",\n    value: function visitBoundText(text) {\n      var _this178 = this;\n\n      if (this.i18n) {\n        var _value4 = text.value.visit(this._valueConverter);\n\n        this.allocateBindingSlots(_value4);\n\n        if (_value4 instanceof Interpolation) {\n          this.i18n.appendBoundText(text.i18n);\n          this.i18nAppendBindings(_value4.expressions);\n        }\n\n        return;\n      }\n\n      var nodeIndex = this.allocateDataSlot();\n      this.creationInstruction(text.sourceSpan, Identifiers$1.text, [literal(nodeIndex)]);\n      var value = text.value.visit(this._valueConverter);\n      this.allocateBindingSlots(value);\n\n      if (value instanceof Interpolation) {\n        this.updateInstructionWithAdvance(nodeIndex, text.sourceSpan, getTextInterpolationExpression(value), function () {\n          return _this178.getUpdateInstructionArguments(value);\n        });\n      } else {\n        error('Text nodes should be interpolated and never bound directly.');\n      }\n    }\n  }, {\n    key: \"visitText\",\n    value: function visitText(text) {\n      // when a text element is located within a translatable\n      // block, we exclude this text element from instructions set,\n      // since it will be captured in i18n content and processed at runtime\n      if (!this.i18n) {\n        this.creationInstruction(text.sourceSpan, Identifiers$1.text, [literal(this.allocateDataSlot()), literal(text.value)]);\n      }\n    }\n  }, {\n    key: \"visitIcu\",\n    value: function visitIcu(icu) {\n      var initWasInvoked = false; // if an ICU was created outside of i18n block, we still treat\n      // it as a translatable entity and invoke i18nStart and i18nEnd\n      // to generate i18n context and the necessary instructions\n\n      if (!this.i18n) {\n        initWasInvoked = true;\n        this.i18nStart(null, icu.i18n, true);\n      }\n\n      var i18n = this.i18n;\n      var vars = this.i18nBindProps(icu.vars);\n      var placeholders = this.i18nBindProps(icu.placeholders); // output ICU directly and keep ICU reference in context\n\n      var message = icu.i18n; // we always need post-processing function for ICUs, to make sure that:\n      // - all placeholders in a form of {PLACEHOLDER} are replaced with actual values (note:\n      // `goog.getMsg` does not process ICUs and uses the `{PLACEHOLDER}` format for placeholders\n      // inside ICUs)\n      // - all ICU vars (such as `VAR_SELECT` or `VAR_PLURAL`) are replaced with correct values\n\n      var transformFn = function transformFn(raw) {\n        var params = Object.assign(Object.assign({}, vars), placeholders);\n        var formatted = i18nFormatPlaceholderNames(params,\n        /* useCamelCase */\n        false);\n        return instruction(null, Identifiers$1.i18nPostprocess, [raw, mapLiteral(formatted, true)]);\n      }; // in case the whole i18n message is a single ICU - we do not need to\n      // create a separate top-level translation, we can use the root ref instead\n      // and make this ICU a top-level translation\n      // note: ICU placeholders are replaced with actual values in `i18nPostprocess` function\n      // separately, so we do not pass placeholders into `i18nTranslate` function.\n\n\n      if (isSingleI18nIcu(i18n.meta)) {\n        this.i18nTranslate(message,\n        /* placeholders */\n        {}, i18n.ref, transformFn);\n      } else {\n        // output ICU directly and keep ICU reference in context\n        var ref = this.i18nTranslate(message,\n        /* placeholders */\n        {},\n        /* ref */\n        undefined, transformFn);\n        i18n.appendIcu(icuFromI18nMessage(message).name, ref);\n      }\n\n      if (initWasInvoked) {\n        this.i18nEnd(null, true);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"allocateDataSlot\",\n    value: function allocateDataSlot() {\n      return this._dataIndex++;\n    }\n  }, {\n    key: \"getConstCount\",\n    value: function getConstCount() {\n      return this._dataIndex;\n    }\n  }, {\n    key: \"getVarCount\",\n    value: function getVarCount() {\n      return this._pureFunctionSlots;\n    }\n  }, {\n    key: \"getConsts\",\n    value: function getConsts() {\n      return this._constants;\n    }\n  }, {\n    key: \"getNgContentSelectors\",\n    value: function getNgContentSelectors() {\n      return this._ngContentReservedSlots.length ? this.constantPool.getConstLiteral(asLiteral(this._ngContentReservedSlots), true) : null;\n    }\n  }, {\n    key: \"bindingContext\",\n    value: function bindingContext() {\n      return \"\".concat(this._bindingContext++);\n    }\n  }, {\n    key: \"templatePropertyBindings\",\n    value: function templatePropertyBindings(templateIndex, attrs) {\n      var _this179 = this;\n\n      var propertyBindings = [];\n      attrs.forEach(function (input) {\n        if (input instanceof BoundAttribute) {\n          var _value5 = input.value.visit(_this179._valueConverter);\n\n          if (_value5 !== undefined) {\n            _this179.allocateBindingSlots(_value5);\n\n            if (_value5 instanceof Interpolation) {\n              // Params typically contain attribute namespace and value sanitizer, which is applicable\n              // for regular HTML elements, but not applicable for <ng-template> (since props act as\n              // inputs to directives), so keep params array empty.\n              var params = []; // prop=\"{{value}}\" case\n\n              _this179.interpolatedUpdateInstruction(getPropertyInterpolationExpression(_value5), templateIndex, input.name, input, _value5, params);\n            } else {\n              // [prop]=\"value\" case\n              propertyBindings.push({\n                name: input.name,\n                sourceSpan: input.sourceSpan,\n                value: function value() {\n                  return _this179.convertPropertyBinding(_value5);\n                }\n              });\n            }\n          }\n        }\n      });\n\n      if (propertyBindings.length > 0) {\n        this.updateInstructionChainWithAdvance(templateIndex, Identifiers$1.property, propertyBindings);\n      }\n    } // Bindings must only be resolved after all local refs have been visited, so all\n    // instructions are queued in callbacks that execute once the initial pass has completed.\n    // Otherwise, we wouldn't be able to support local refs that are defined after their\n    // bindings. e.g. {{ foo }} <div #foo></div>\n\n  }, {\n    key: \"instructionFn\",\n    value: function instructionFn(fns, span, reference, paramsOrFn) {\n      var prepend = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      fns[prepend ? 'unshift' : 'push'](function () {\n        var params = Array.isArray(paramsOrFn) ? paramsOrFn : paramsOrFn();\n        return instruction(span, reference, params).toStmt();\n      });\n    }\n  }, {\n    key: \"processStylingUpdateInstruction\",\n    value: function processStylingUpdateInstruction(elementIndex, instruction) {\n      var _this180 = this;\n\n      var allocateBindingSlots = 0;\n\n      if (instruction) {\n        var calls = [];\n        instruction.calls.forEach(function (call) {\n          allocateBindingSlots += call.allocateBindingSlots;\n          calls.push({\n            sourceSpan: call.sourceSpan,\n            value: function value() {\n              return call.params(function (value) {\n                return call.supportsInterpolation && value instanceof Interpolation ? _this180.getUpdateInstructionArguments(value) : _this180.convertPropertyBinding(value);\n              });\n            }\n          });\n        });\n        this.updateInstructionChainWithAdvance(elementIndex, instruction.reference, calls);\n      }\n\n      return allocateBindingSlots;\n    }\n  }, {\n    key: \"creationInstruction\",\n    value: function creationInstruction(span, reference, paramsOrFn, prepend) {\n      this.instructionFn(this._creationCodeFns, span, reference, paramsOrFn || [], prepend);\n    }\n  }, {\n    key: \"creationInstructionChain\",\n    value: function creationInstructionChain(reference, calls) {\n      var span = calls.length ? calls[0].sourceSpan : null;\n\n      this._creationCodeFns.push(function () {\n        return chainedInstruction(reference, calls.map(function (call) {\n          return call.params();\n        }), span).toStmt();\n      });\n    }\n  }, {\n    key: \"updateInstructionWithAdvance\",\n    value: function updateInstructionWithAdvance(nodeIndex, span, reference, paramsOrFn) {\n      this.addAdvanceInstructionIfNecessary(nodeIndex, span);\n      this.updateInstruction(span, reference, paramsOrFn);\n    }\n  }, {\n    key: \"updateInstruction\",\n    value: function updateInstruction(span, reference, paramsOrFn) {\n      this.instructionFn(this._updateCodeFns, span, reference, paramsOrFn || []);\n    }\n  }, {\n    key: \"updateInstructionChain\",\n    value: function updateInstructionChain(reference, bindings) {\n      var span = bindings.length ? bindings[0].sourceSpan : null;\n\n      this._updateCodeFns.push(function () {\n        var calls = bindings.map(function (property) {\n          var value = property.value();\n          var fnParams = Array.isArray(value) ? value : [value];\n\n          if (property.params) {\n            fnParams.push.apply(fnParams, _toConsumableArray(property.params));\n          }\n\n          if (property.name) {\n            // We want the property name to always be the first function parameter.\n            fnParams.unshift(literal(property.name));\n          }\n\n          return fnParams;\n        });\n        return chainedInstruction(reference, calls, span).toStmt();\n      });\n    }\n  }, {\n    key: \"updateInstructionChainWithAdvance\",\n    value: function updateInstructionChainWithAdvance(nodeIndex, reference, bindings) {\n      this.addAdvanceInstructionIfNecessary(nodeIndex, bindings.length ? bindings[0].sourceSpan : null);\n      this.updateInstructionChain(reference, bindings);\n    }\n  }, {\n    key: \"addAdvanceInstructionIfNecessary\",\n    value: function addAdvanceInstructionIfNecessary(nodeIndex, span) {\n      if (nodeIndex !== this._currentIndex) {\n        var delta = nodeIndex - this._currentIndex;\n\n        if (delta < 1) {\n          throw new Error('advance instruction can only go forwards');\n        }\n\n        this.instructionFn(this._updateCodeFns, span, Identifiers$1.advance, [literal(delta)]);\n        this._currentIndex = nodeIndex;\n      }\n    }\n  }, {\n    key: \"allocatePureFunctionSlots\",\n    value: function allocatePureFunctionSlots(numSlots) {\n      var originalSlots = this._pureFunctionSlots;\n      this._pureFunctionSlots += numSlots;\n      return originalSlots;\n    }\n  }, {\n    key: \"allocateBindingSlots\",\n    value: function allocateBindingSlots(value) {\n      this._bindingSlots += value instanceof Interpolation ? value.expressions.length : 1;\n    }\n    /**\n     * Gets an expression that refers to the implicit receiver. The implicit\n     * receiver is always the root level context.\n     */\n\n  }, {\n    key: \"getImplicitReceiverExpr\",\n    value: function getImplicitReceiverExpr() {\n      if (this._implicitReceiverExpr) {\n        return this._implicitReceiverExpr;\n      }\n\n      return this._implicitReceiverExpr = this.level === 0 ? variable(CONTEXT_NAME) : this._bindingScope.getOrCreateSharedContextVar(0);\n    }\n  }, {\n    key: \"convertPropertyBinding\",\n    value: function convertPropertyBinding(value) {\n      var _this$_tempVariables;\n\n      var convertedPropertyBinding = _convertPropertyBinding(this, this.getImplicitReceiverExpr(), value, this.bindingContext(), BindingForm.TrySimple, function () {\n        return error('Unexpected interpolation');\n      });\n\n      var valExpr = convertedPropertyBinding.currValExpr;\n\n      (_this$_tempVariables = this._tempVariables).push.apply(_this$_tempVariables, _toConsumableArray(convertedPropertyBinding.stmts));\n\n      return valExpr;\n    }\n    /**\n     * Gets a list of argument expressions to pass to an update instruction expression. Also updates\n     * the temp variables state with temp variables that were identified as needing to be created\n     * while visiting the arguments.\n     * @param value The original expression we will be resolving an arguments list from.\n     */\n\n  }, {\n    key: \"getUpdateInstructionArguments\",\n    value: function getUpdateInstructionArguments(value) {\n      var _this$_tempVariables2;\n\n      var _convertUpdateArgumen = convertUpdateArguments(this, this.getImplicitReceiverExpr(), value, this.bindingContext()),\n          args = _convertUpdateArgumen.args,\n          stmts = _convertUpdateArgumen.stmts;\n\n      (_this$_tempVariables2 = this._tempVariables).push.apply(_this$_tempVariables2, _toConsumableArray(stmts));\n\n      return args;\n    }\n  }, {\n    key: \"matchDirectives\",\n    value: function matchDirectives(elementName, elOrTpl) {\n      var _this181 = this;\n\n      if (this.directiveMatcher) {\n        var selector = createCssSelector(elementName, getAttrsForDirectiveMatching(elOrTpl));\n        this.directiveMatcher.match(selector, function (cssSelector, staticType) {\n          _this181.directives.add(staticType);\n        });\n      }\n    }\n    /**\n     * Prepares all attribute expression values for the `TAttributes` array.\n     *\n     * The purpose of this function is to properly construct an attributes array that\n     * is passed into the `elementStart` (or just `element`) functions. Because there\n     * are many different types of attributes, the array needs to be constructed in a\n     * special way so that `elementStart` can properly evaluate them.\n     *\n     * The format looks like this:\n     *\n     * ```\n     * attrs = [prop, value, prop2, value2,\n     *   PROJECT_AS, selector,\n     *   CLASSES, class1, class2,\n     *   STYLES, style1, value1, style2, value2,\n     *   BINDINGS, name1, name2, name3,\n     *   TEMPLATE, name4, name5, name6,\n     *   I18N, name7, name8, ...]\n     * ```\n     *\n     * Note that this function will fully ignore all synthetic (@foo) attribute values\n     * because those values are intended to always be generated as property instructions.\n     */\n\n  }, {\n    key: \"getAttributeExpressions\",\n    value: function getAttributeExpressions(renderAttributes, inputs, outputs, styles) {\n      var templateAttrs = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n      var i18nAttrs = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : [];\n      var alreadySeen = new Set();\n      var attrExprs = [];\n      var ngProjectAsAttr;\n      renderAttributes.forEach(function (attr) {\n        if (attr.name === NG_PROJECT_AS_ATTR_NAME) {\n          ngProjectAsAttr = attr;\n        }\n\n        attrExprs.push.apply(attrExprs, _toConsumableArray(getAttributeNameLiterals(attr.name)).concat([asLiteral(attr.value)]));\n      }); // Keep ngProjectAs next to the other name, value pairs so we can verify that we match\n      // ngProjectAs marker in the attribute name slot.\n\n      if (ngProjectAsAttr) {\n        attrExprs.push.apply(attrExprs, _toConsumableArray(getNgProjectAsLiteral(ngProjectAsAttr)));\n      }\n\n      function addAttrExpr(key, value) {\n        if (typeof key === 'string') {\n          if (!alreadySeen.has(key)) {\n            attrExprs.push.apply(attrExprs, _toConsumableArray(getAttributeNameLiterals(key)));\n            value !== undefined && attrExprs.push(value);\n            alreadySeen.add(key);\n          }\n        } else {\n          attrExprs.push(literal(key));\n        }\n      } // it's important that this occurs before BINDINGS and TEMPLATE because once `elementStart`\n      // comes across the BINDINGS or TEMPLATE markers then it will continue reading each value as\n      // as single property value cell by cell.\n\n\n      if (styles) {\n        styles.populateInitialStylingAttrs(attrExprs);\n      }\n\n      if (inputs.length || outputs.length) {\n        var attrsLengthBeforeInputs = attrExprs.length;\n\n        for (var i = 0; i < inputs.length; i++) {\n          var input = inputs[i]; // We don't want the animation and attribute bindings in the\n          // attributes array since they aren't used for directive matching.\n\n          if (input.type !== 4\n          /* Animation */\n          && input.type !== 1\n          /* Attribute */\n          ) {\n              addAttrExpr(input.name);\n            }\n        }\n\n        for (var _i7 = 0; _i7 < outputs.length; _i7++) {\n          var output = outputs[_i7];\n\n          if (output.type !== 1\n          /* Animation */\n          ) {\n              addAttrExpr(output.name);\n            }\n        } // this is a cheap way of adding the marker only after all the input/output\n        // values have been filtered (by not including the animation ones) and added\n        // to the expressions. The marker is important because it tells the runtime\n        // code that this is where attributes without values start...\n\n\n        if (attrExprs.length !== attrsLengthBeforeInputs) {\n          attrExprs.splice(attrsLengthBeforeInputs, 0, literal(3\n          /* Bindings */\n          ));\n        }\n      }\n\n      if (templateAttrs.length) {\n        attrExprs.push(literal(4\n        /* Template */\n        ));\n        templateAttrs.forEach(function (attr) {\n          return addAttrExpr(attr.name);\n        });\n      }\n\n      if (i18nAttrs.length) {\n        attrExprs.push(literal(6\n        /* I18n */\n        ));\n        i18nAttrs.forEach(function (attr) {\n          return addAttrExpr(attr.name);\n        });\n      }\n\n      return attrExprs;\n    }\n  }, {\n    key: \"addToConsts\",\n    value: function addToConsts(expression) {\n      if (isNull(expression)) {\n        return TYPED_NULL_EXPR;\n      } // Try to reuse a literal that's already in the array, if possible.\n\n\n      for (var i = 0; i < this._constants.length; i++) {\n        if (this._constants[i].isEquivalent(expression)) {\n          return literal(i);\n        }\n      }\n\n      return literal(this._constants.push(expression) - 1);\n    }\n  }, {\n    key: \"addAttrsToConsts\",\n    value: function addAttrsToConsts(attrs) {\n      return attrs.length > 0 ? this.addToConsts(literalArr(attrs)) : TYPED_NULL_EXPR;\n    }\n  }, {\n    key: \"prepareRefsArray\",\n    value: function prepareRefsArray(references) {\n      var _this182 = this;\n\n      if (!references || references.length === 0) {\n        return TYPED_NULL_EXPR;\n      }\n\n      var refsParam = flatten(references.map(function (reference) {\n        var slot = _this182.allocateDataSlot(); // Generate the update temporary.\n\n\n        var variableName = _this182._bindingScope.freshReferenceName();\n\n        var retrievalLevel = _this182.level;\n        var lhs = variable(variableName);\n\n        _this182._bindingScope.set(retrievalLevel, reference.name, lhs, 0\n        /* DEFAULT */\n        , function (scope, relativeLevel) {\n          // e.g. nextContext(2);\n          var nextContextStmt = relativeLevel > 0 ? [generateNextContextExpr(relativeLevel).toStmt()] : []; // e.g. const $foo$ = reference(1);\n\n          var refExpr = lhs.set(importExpr(Identifiers$1.reference).callFn([literal(slot)]));\n          return nextContextStmt.concat(refExpr.toConstDecl());\n        }, true);\n\n        return [reference.name, reference.value];\n      }));\n      return asLiteral(refsParam);\n    }\n  }, {\n    key: \"prepareListenerParameter\",\n    value: function prepareListenerParameter(tagName, outputAst, index) {\n      var _this183 = this;\n\n      return function () {\n        var eventName = outputAst.name;\n        var bindingFnName = outputAst.type === 1\n        /* Animation */\n        ? // synthetic @listener.foo values are treated the exact same as are standard listeners\n        prepareSyntheticListenerFunctionName(eventName, outputAst.phase) : sanitizeIdentifier(eventName);\n        var handlerName = \"\".concat(_this183.templateName, \"_\").concat(tagName, \"_\").concat(bindingFnName, \"_\").concat(index, \"_listener\");\n\n        var scope = _this183._bindingScope.nestedScope(_this183._bindingScope.bindingLevel);\n\n        return prepareEventListenerParameters(outputAst, handlerName, scope);\n      };\n    }\n  }]);\n\n  return TemplateDefinitionBuilder;\n}();\n\nvar ValueConverter = /*#__PURE__*/function (_AstMemoryEfficientTr) {\n  _inherits(ValueConverter, _AstMemoryEfficientTr);\n\n  var _super95 = _createSuper(ValueConverter);\n\n  function ValueConverter(constantPool, allocateSlot, allocatePureFunctionSlots, definePipe) {\n    var _this184;\n\n    _classCallCheck(this, ValueConverter);\n\n    _this184 = _super95.call(this);\n    _this184.constantPool = constantPool;\n    _this184.allocateSlot = allocateSlot;\n    _this184.allocatePureFunctionSlots = allocatePureFunctionSlots;\n    _this184.definePipe = definePipe;\n    _this184._pipeBindExprs = [];\n    return _this184;\n  } // AstMemoryEfficientTransformer\n\n\n  _createClass(ValueConverter, [{\n    key: \"visitPipe\",\n    value: function visitPipe(pipe, context) {\n      // Allocate a slot to create the pipe\n      var slot = this.allocateSlot();\n      var slotPseudoLocal = \"PIPE:\".concat(slot); // Allocate one slot for the result plus one slot per pipe argument\n\n      var pureFunctionSlot = this.allocatePureFunctionSlots(2 + pipe.args.length);\n      var target = new PropertyRead(pipe.span, pipe.sourceSpan, pipe.nameSpan, new ImplicitReceiver(pipe.span, pipe.sourceSpan), slotPseudoLocal);\n\n      var _pipeBindingCallInfo = pipeBindingCallInfo(pipe.args),\n          identifier = _pipeBindingCallInfo.identifier,\n          isVarLength = _pipeBindingCallInfo.isVarLength;\n\n      this.definePipe(pipe.name, slotPseudoLocal, slot, importExpr(identifier));\n      var args = [pipe.exp].concat(_toConsumableArray(pipe.args));\n      var convertedArgs = isVarLength ? this.visitAll([new LiteralArray(pipe.span, pipe.sourceSpan, args)]) : this.visitAll(args);\n      var pipeBindExpr = new FunctionCall(pipe.span, pipe.sourceSpan, target, [new LiteralPrimitive(pipe.span, pipe.sourceSpan, slot), new LiteralPrimitive(pipe.span, pipe.sourceSpan, pureFunctionSlot)].concat(_toConsumableArray(convertedArgs)));\n\n      this._pipeBindExprs.push(pipeBindExpr);\n\n      return pipeBindExpr;\n    }\n  }, {\n    key: \"updatePipeSlotOffsets\",\n    value: function updatePipeSlotOffsets(bindingSlots) {\n      this._pipeBindExprs.forEach(function (pipe) {\n        // update the slot offset arg (index 1) to account for binding slots\n        var slotOffset = pipe.args[1];\n        slotOffset.value += bindingSlots;\n      });\n    }\n  }, {\n    key: \"visitLiteralArray\",\n    value: function visitLiteralArray(array, context) {\n      var _this185 = this;\n\n      return new BuiltinFunctionCall(array.span, array.sourceSpan, this.visitAll(array.expressions), function (values) {\n        // If the literal has calculated (non-literal) elements transform it into\n        // calls to literal factories that compose the literal and will cache intermediate\n        // values.\n        var literal = literalArr(values);\n        return getLiteralFactory(_this185.constantPool, literal, _this185.allocatePureFunctionSlots);\n      });\n    }\n  }, {\n    key: \"visitLiteralMap\",\n    value: function visitLiteralMap(map, context) {\n      var _this186 = this;\n\n      return new BuiltinFunctionCall(map.span, map.sourceSpan, this.visitAll(map.values), function (values) {\n        // If the literal has calculated (non-literal) elements  transform it into\n        // calls to literal factories that compose the literal and will cache intermediate\n        // values.\n        var literal = literalMap(values.map(function (value, index) {\n          return {\n            key: map.keys[index].key,\n            value: value,\n            quoted: map.keys[index].quoted\n          };\n        }));\n        return getLiteralFactory(_this186.constantPool, literal, _this186.allocatePureFunctionSlots);\n      });\n    }\n  }]);\n\n  return ValueConverter;\n}(AstMemoryEfficientTransformer); // Pipes always have at least one parameter, the value they operate on\n\n\nvar pipeBindingIdentifiers = [Identifiers$1.pipeBind1, Identifiers$1.pipeBind2, Identifiers$1.pipeBind3, Identifiers$1.pipeBind4];\n\nfunction pipeBindingCallInfo(args) {\n  var identifier = pipeBindingIdentifiers[args.length];\n  return {\n    identifier: identifier || Identifiers$1.pipeBindV,\n    isVarLength: !identifier\n  };\n}\n\nvar pureFunctionIdentifiers = [Identifiers$1.pureFunction0, Identifiers$1.pureFunction1, Identifiers$1.pureFunction2, Identifiers$1.pureFunction3, Identifiers$1.pureFunction4, Identifiers$1.pureFunction5, Identifiers$1.pureFunction6, Identifiers$1.pureFunction7, Identifiers$1.pureFunction8];\n\nfunction pureFunctionCallInfo(args) {\n  var identifier = pureFunctionIdentifiers[args.length];\n  return {\n    identifier: identifier || Identifiers$1.pureFunctionV,\n    isVarLength: !identifier\n  };\n}\n\nfunction instruction(span, reference, params) {\n  return importExpr(reference, null, span).callFn(params, span);\n} // e.g. x(2);\n\n\nfunction generateNextContextExpr(relativeLevelDiff) {\n  return importExpr(Identifiers$1.nextContext).callFn(relativeLevelDiff > 1 ? [literal(relativeLevelDiff)] : []);\n}\n\nfunction getLiteralFactory(constantPool, literal$1, allocateSlots) {\n  var _constantPool$getLite = constantPool.getLiteralFactory(literal$1),\n      literalFactory = _constantPool$getLite.literalFactory,\n      literalFactoryArguments = _constantPool$getLite.literalFactoryArguments; // Allocate 1 slot for the result plus 1 per argument\n\n\n  var startSlot = allocateSlots(1 + literalFactoryArguments.length);\n\n  var _pureFunctionCallInfo = pureFunctionCallInfo(literalFactoryArguments),\n      identifier = _pureFunctionCallInfo.identifier,\n      isVarLength = _pureFunctionCallInfo.isVarLength; // Literal factories are pure functions that only need to be re-invoked when the parameters\n  // change.\n\n\n  var args = [literal(startSlot), literalFactory];\n\n  if (isVarLength) {\n    args.push(literalArr(literalFactoryArguments));\n  } else {\n    args.push.apply(args, _toConsumableArray(literalFactoryArguments));\n  }\n\n  return importExpr(identifier).callFn(args);\n}\n/**\n * Gets an array of literals that can be added to an expression\n * to represent the name and namespace of an attribute. E.g.\n * `:xlink:href` turns into `[AttributeMarker.NamespaceURI, 'xlink', 'href']`.\n *\n * @param name Name of the attribute, including the namespace.\n */\n\n\nfunction getAttributeNameLiterals(name) {\n  var _splitNsName5 = splitNsName(name),\n      _splitNsName6 = _slicedToArray(_splitNsName5, 2),\n      attributeNamespace = _splitNsName6[0],\n      attributeName = _splitNsName6[1];\n\n  var nameLiteral = literal(attributeName);\n\n  if (attributeNamespace) {\n    return [literal(0\n    /* NamespaceURI */\n    ), literal(attributeNamespace), nameLiteral];\n  }\n\n  return [nameLiteral];\n}\n/** The prefix used to get a shared context in BindingScope's map. */\n\n\nvar SHARED_CONTEXT_KEY = '$$shared_ctx$$';\n\nvar BindingScope = /*#__PURE__*/function () {\n  function BindingScope() {\n    var bindingLevel = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    v